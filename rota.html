<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Calpe Ward</title>
  
  <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;500;600;700;800&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="css/styles.css">
  <link rel="stylesheet" href="css/rota.css">
  <link rel="stylesheet" href="css/rota-edit.css">
  <link rel="stylesheet" href="css/user-modal.css">
  <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
  <script src="js/config.js"></script>
  <script src="js/session-validator.js"></script>
  <script src="js/permissions.js"></script>
  <script src="js/nav-bar.js"></script>
  <script src="js/view-as.js?v=8"></script>
  <script src="js/swap-functions.js" defer></script>
  <script src="js/notifications-shared.js" defer></script>
  <script src="js/shift-functions.js" defer></script>
  <script src="js/shift-editor.js" defer></script>
  <script src="js/periods-shared.js" defer></script>
  <script src="js/non-staff-modal-shared.js" defer></script>
</head>

<body>
  <div class="wrap">
    <!-- Page Navigation -->
    <div id="pageNav" style="padding: 8px 12px; background: #f0f0f0; border-bottom: 1px solid #ddd; display: flex; gap: 12px; font-size: 14px; align-items: center;">
      <a href="requests.html" style="color: #4F8DF7; text-decoration: none;">üìã Requests</a>
      <a href="rota.html" style="color: #4F8DF7; text-decoration: none; font-weight: 600;">üìÖ View Rota</a>
      <a href="admin.html" id="navAdminLink" style="color: #4F8DF7; text-decoration: none; display: none;">‚öôÔ∏è Admin</a>
      <button id="viewAsBtn" class="badge" type="button" style="display:none; padding: 6px 12px; white-space: nowrap;">üëÅÔ∏è View As</button>
    </div>
    
    <!-- Title + Controls -->
    <div class="titlebar">
      <div style="display:flex; gap:12px; align-items:center; flex:1;">
        <img
          src="logo.png"
          alt="Calpe Ward"
          style="height:44px; width:auto;"
        />
        <div style="flex:1;">
          <h1>Calpe Ward</h1>
          <div class="header-subrow" style="margin:0;">
            <label for="periodSelect" class="subtitle" style="font-weight: 600;">Period:</label>
            <select id="periodSelect" style="margin: 0 8px;">
              <option>Loading...</option>
            </select>
            <button id="publishBtn" class="btn" style="display: none; background: #059669; color: white; padding: 6px 12px; border-radius: 6px; border: none; font-weight: 600; cursor: pointer; font-size: 13px;">üì§ Publish</button>
            <button id="unpublishBtn" class="btn" style="display: none; background: #dc2626; color: white; padding: 6px 12px; border-radius: 6px; border: none; font-weight: 600; cursor: pointer; font-size: 13px; margin-left: 6px;">‚ö†Ô∏è Unpublish</button>
            <button id="toggleEditingBtn" class="btn" style="margin-left: 8px; padding: 6px 12px; font-size: 13px;">üîí Locked</button>
      <button type="button" id="toggleRequestsBtn" class="btn" style="margin-left: 8px; padding: 6px 12px; font-size: 13px;">üëÅÔ∏è Requests</button>
            <button type="button" id="addNonStaffBtn" class="btn" style="margin-left: 8px; display:none; padding: 6px 12px; font-size: 13px;">‚ûï Non-Staff</button>
          </div>
        </div>
      </div>
      <div class="rightbits">
        <!-- Bell -->
        <button class="badge" id="noticeBell" type="button" title="Notices & notifications">
          üîî <span id="noticeBellDot" style="display:none;">‚Ä¢</span>
        </button>

        <!-- Print button (admin only) -->
        <button class="badge" id="rotaPrintBtn" type="button" title="Print rota" style="display:none; cursor:pointer;">
          üñ®Ô∏è Print
        </button>
        
        <!-- Admin badge -->
        <div class="badge admin" id="adminBadge" style="display:none;">ADMIN</div>
        
        <!-- Account badge (clickable to edit account) -->
        <button class="badge account-badge" id="loginBadge" type="button" title="Edit your account">
          <span class="acc-ic">üë§</span>
          <span class="acc-txt">Not logged in</span>
        </button>
        
        <!-- Logout -->
        <button id="logoutBtn">Logout</button>
      </div>
    </div>

    <!-- Period Status -->
    <div id="periodStatus" class="period-status" style="display: none;">
      <span class="status-badge" id="statusBadge"></span>
      <span id="statusText"></span>
    </div>

    <!-- Metadata Display (shown when editing) -->
    <div id="metadataDisplay" class="metadata-display" style="display: none; padding: 12px; background: #fff3cd; border: 1px solid #ffc107; border-radius: 4px; margin: 0 2px 12px; font-size: 14px;">
      <strong>Draft Editing Mode:</strong> Click any cell to assign shifts. Changes save immediately.
    </div>

    <!-- Published edit warning banner -->
    <div id="publishedEditBanner" class="metadata-display" style="display: none; padding: 12px; background: #ffe4d5; border: 1px solid #f97316; border-radius: 4px; margin: 0 2px 12px; font-size: 14px;">
      <strong>Published Edit Mode:</strong> Use only for post-publish corrections. All changes are recorded.
    </div>

    <!-- Pattern Warnings (admin only, collapsible) -->
    <div id="patternWarnings" class="pattern-warnings">
      <details id="patternWarningsDetails">
        <summary>Pattern Guidance</summary>
        <div id="warningsList"></div>
      </details>
    </div>

    <!-- Rota Table -->
    <div class="rota-scroll">
      <table id="rota"></table>
    </div>

    <!-- Shift Picker Modal -->
    <div class="modal-backdrop" id="shiftPickerBackdrop" aria-hidden="true">
      <div id="shiftPickerModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="shiftPickerTitle">
        <h2 id="shiftPickerTitle">Select shift</h2>
        <p id="shiftPickerDate" class="subtitle"></p>
        <div class="modal-bubble">
          <div id="shiftPickerList"></div>
        </div>
        
        <!-- Override times/hours (shown only for published edits) -->
        <div id="overrideSection" class="modal-bubble" style="display: none; margin-top: 12px; padding: 16px;">
          <div style="font-size: 13px; color: #64748b; margin-bottom: 12px; font-weight: 600;">Override Actual Times</div>
          <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 12px; margin-bottom: 12px;">
            <div>
              <label style="font-size: 12px; color: #64748b; display: block; margin-bottom: 4px;">Start</label>
              <input type="time" id="overrideStartTime" style="width: 100%; padding: 8px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 13px; box-sizing: border-box;">
            </div>
            <div>
              <label style="font-size: 12px; color: #64748b; display: block; margin-bottom: 4px;">End</label>
              <input type="time" id="overrideEndTime" style="width: 100%; padding: 8px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 13px; box-sizing: border-box;">
            </div>
            <div>
              <label style="font-size: 12px; color: #64748b; display: block; margin-bottom: 4px;">Hours</label>
              <input type="number" id="overrideHours" step="0.25" min="0" max="24" style="width: 100%; padding: 8px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 13px; box-sizing: border-box;">
            </div>
          </div>
          <button type="button" id="clearOverrideBtn" style="padding: 6px 12px; font-size: 12px; color: #64748b; border: 1px solid #d1d5db; background: white; border-radius: 6px; cursor: pointer;">Clear Override</button>
        </div>
        
        <script>
          // Auto-calculate hours when times change
          (function() {
            function calculateHours() {
              const startInput = document.getElementById('overrideStartTime');
              const endInput = document.getElementById('overrideEndTime');
              const hoursInput = document.getElementById('overrideHours');
              
              if (!startInput?.value || !endInput?.value) return;
              
              const [startHour, startMin] = startInput.value.split(':').map(Number);
              const [endHour, endMin] = endInput.value.split(':').map(Number);
              
              let hours = (endHour * 60 + endMin) - (startHour * 60 + startMin);
              if (hours < 0) hours += 24 * 60; // Handle overnight shifts
              
              const decimalHours = Math.round((hours / 60) * 4) / 4; // Round to nearest 0.25
              if (hoursInput) hoursInput.value = decimalHours;
            }
            
            // Attach listeners when DOM ready
            document.addEventListener('DOMContentLoaded', () => {
              const startInput = document.getElementById('overrideStartTime');
              const endInput = document.getElementById('overrideEndTime');
              
              if (startInput) startInput.addEventListener('change', calculateHours);
              if (endInput) endInput.addEventListener('change', calculateHours);
            });
          })();
        </script>
        
        <!-- Admin Note (internal only, shown for published edits) -->
        <div id="commentSection" class="modal-bubble" style="display: none; margin-top: 12px; padding: 16px;">
          <label style="font-size: 13px; color: #dc2626; display: block; margin-bottom: 8px; font-weight: 600;">Admin Note (override)</label>
          <textarea id="shiftComment" rows="3" placeholder="Note about time/hours override..." style="width: 100%; padding: 8px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 13px; font-family: inherit; resize: vertical; box-sizing: border-box; margin-bottom: 8px;"></textarea>
          
          <div style="display: flex; gap: 8px; align-items: center;">
            <label for="commentVisibilitySelect" style="font-size: 12px; color: #64748b;">Who can see:</label>
            <select id="commentVisibilitySelect" style="padding: 4px 8px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 12px; cursor: pointer;">
              <option value="admin_only">Admin only</option>
              <option value="all_staff">All staff</option>
              <option value="user_only">User only</option>
            </select>
          </div>
          
          <div style="font-size: 11px; color: #64748b; margin-top: 6px;">For general comments, use View Comments button.</div>
        </div>
        
        <div class="btns">
          <button id="shiftPickerSave" type="button" class="primary" style="display: none;">Save</button>
          <button id="shiftPickerClear" type="button">Clear</button>
          <button id="shiftPickerClose" type="button">Cancel</button>
        </div>
      </div>
    </div>

    <!-- Non-Staff Modal -->
    <div class="modal-backdrop" id="nonStaffModalBackdrop" aria-hidden="true">
      <div class="modal" role="dialog" aria-modal="true" aria-labelledby="nonStaffModalTitle">
        <h2 id="nonStaffModalTitle">Add Non-Staff to Period</h2>
        
        <!-- Tab / Section Toggle -->
        <div class="modal-bubble" style="margin-bottom:16px;">
          <div style="display:flex; gap:0; border-bottom:1px solid #e5e7eb;">
            <button id="nsTabSelect" type="button" style="flex:1; padding:12px; border:none; background:none; color:#0f172a; font-weight:500; cursor:pointer; border-bottom:3px solid #3b82f6; margin-bottom:-1px;">Select Existing</button>
            <button id="nsTabCreate" type="button" style="flex:1; padding:12px; border:none; background:none; color:#94a3b8; font-weight:500; cursor:pointer; border-bottom:3px solid transparent; margin-bottom:-1px;">Create New</button>
          </div>
        </div>

        <!-- Select Existing Section -->
        <div id="nsSelectSection" style="display:block;">
          <div class="modal-bubble" style="margin-bottom:12px;">
            <div style="display:grid; grid-template-columns: 1fr 1fr; gap:12px; margin-bottom:12px;">
              <div>
                <label style="font-size:12px; color:#64748b; font-weight:500;">Category</label>
                <select id="nsCategory" style="width:100%; padding:8px; border:1px solid #d1d5db; border-radius:6px; margin-top:4px;">
                  <option value="student">Student</option>
                  <option value="bank">Bank</option>
                  <option value="agency">Agency</option>
                </select>
              </div>
              <div id="nsRoleGroupWrap">
                <label style="font-size:12px; color:#64748b; font-weight:500;">Role Group</label>
                <select id="nsRoleGroup" style="width:100%; padding:8px; border:1px solid #d1d5db; border-radius:6px; margin-top:4px;">
                  <option value="staff_nurse">Staff Nurse</option>
                  <option value="nursing_assistant">Nursing Assistant</option>
                </select>
              </div>
            </div>
            <div style="display:flex; gap:8px; margin-bottom:12px;">
              <input id="nsSearch" placeholder="Search profiles..." style="flex:1; padding:8px; border:1px solid #d1d5db; border-radius:6px;" />
              <button id="nsSearchBtn" type="button" style="padding:8px 12px; white-space:nowrap;">Search</button>
            </div>
            <div style="max-height:260px; overflow-y:auto; border:1px solid #e5e7eb; border-radius:6px; padding:8px; background:#f8fafc;" id="nsResults"></div>
          </div>
        </div>

        <!-- Create New Section (hidden by default) -->
        <div id="nsCreateSection" style="display:none;">
          <div class="modal-bubble" style="margin-bottom:12px;">
            <div style="display:flex; flex-direction:column; gap:12px;">
              <div>
                <label style="font-size:12px; color:#64748b; font-weight:500; display:block; margin-bottom:4px;">Full Name</label>
                <input id="nsNewName" placeholder="Enter full name" style="width:100%; padding:8px; border:1px solid #d1d5db; border-radius:6px;" />
              </div>
              <div style="display:grid; grid-template-columns: 1fr 1fr; gap:12px;">
                <div>
                  <label style="font-size:12px; color:#64748b; font-weight:500;">Category</label>
                  <select id="nsCategoryCreate" style="width:100%; padding:8px; border:1px solid #d1d5db; border-radius:6px; margin-top:4px;">
                    <option value="student">Student</option>
                    <option value="bank">Bank</option>
                    <option value="agency">Agency</option>
                  </select>
                </div>
                <div id="nsRoleGroupCreateWrap">
                  <label style="font-size:12px; color:#64748b; font-weight:500;">Role Group</label>
                  <select id="nsRoleGroupCreate" style="width:100%; padding:8px; border:1px solid #d1d5db; border-radius:6px; margin-top:4px;">
                    <option value="staff_nurse">Staff Nurse</option>
                    <option value="nursing_assistant">Nursing Assistant</option>
                  </select>
                </div>
              </div>
              <div id="nsCountsWrap" style="display:flex; align-items:center; gap:8px;">
                <input id="nsCounts" type="checkbox" style="width:18px; height:18px; cursor:pointer;" />
                <label style="font-size:12px; color:#64748b; cursor:pointer; margin:0;">Counts towards staffing</label>
              </div>
            </div>
          </div>
        </div>

        <!-- Delete Section (shown in Select Existing when item selected) -->
        <div id="nsDeleteSection" style="display:none;">
          <div class="modal-bubble" style="background:#fef2f2; border:1px solid #fca5a5; margin-bottom:12px;">
            <div style="display:flex; justify-content:space-between; align-items:center;">
              <div>
                <label style="font-size:12px; color:#991b1b; font-weight:500; display:block; margin-bottom:4px;">Remove from Period</label>
                <div id="nsDeleteItemName" style="font-size:14px; color:#0f172a;"></div>
              </div>
              <button id="nsDeleteBtn" type="button" style="padding:6px 12px; background:#dc2626; color:white; border:none; border-radius:6px; cursor:pointer; font-size:12px;">Remove</button>
            </div>
          </div>
        </div>

        <div class="btns">
          <button id="nsAddBtn" type="button" class="primary">Add to Period</button>
          <button id="nsCloseBtn" type="button">Close</button>
        </div>
      </div>
    </div>

    <!-- Published Details / Actions Modal (desktop: right-click, mobile: tap) -->
    <!-- Published Details / Actions Modal (desktop: right-click, mobile: tap) -->
    <div class="modal-backdrop" id="publishedDetailsModal" aria-hidden="true">
      <div class="published-modal" role="dialog" aria-modal="true" aria-labelledby="publishedDetailsTitle">
        <div class="modal-head">
          <div class="modal-title" id="publishedDetailsTitle">Shift Details</div>
          <div class="modal-sub" id="publishedDetailsSubtitle"></div>
        </div>

        <div class="modal-bubble">
          <div style="padding: 12px; background: #f8fafc; border-radius: 6px; margin-bottom: 8px;">
            <div class="shift-display">
              <span class="shift-code" id="publishedShiftCode"></span>
              <span class="shift-name" id="publishedShiftName"></span>
            </div>
          </div>
          <div class="rest-day" id="restDayLabel" style="display:none; margin-top:8px; font-size:13px; color:#64748b; font-style:italic;">Rest day</div>
          
          <!-- Scheduled times (original from shift) -->
          <div class="kv" id="scheduledTimesRow" style="margin-top:12px; display:none;">
            <div class="k">Scheduled</div>
            <div class="v" id="scheduledTimes"></div>
          </div>
          
          <!-- Actual times (override) -->
          <div class="kv" id="actualTimesRow" style="margin-top:10px; display:none;">
            <div class="k" style="color: #dc2626; font-weight: 600;">Actual</div>
            <div class="v" id="actualTimes" style="color: #dc2626; font-weight: 600;"></div>
          </div>
          
          <!-- Hours (scheduled or override) -->
          <div class="kv" id="hoursRow" style="margin-top:10px; display:none;">
            <div class="k">Hours</div>
            <div class="v" id="publishedShiftHours"></div>
          </div>
          
          <!-- Admin Note display (internal only) -->
          <div id="commentDisplay" style="display:none; margin-top:12px; padding:10px; background:#fef2f2; border-left:3px solid #dc2626; border-radius:4px;">
            <div style="font-size:12px; color:#dc2626; margin-bottom:4px; font-weight:600;">Admin Note (internal)</div>
            <div id="commentText" style="font-size:13px; color:#0f172a; white-space:pre-wrap;"></div>
          </div>
        </div>

        <div class="btns">
          <button id="publishedChangeBtn" class="primary" type="button">Change shift</button>
          <button id="publishedOverrideBtn" class="primary" type="button">Override shift</button>
          <button id="publishedCommentsBtn" type="button">View comments</button>
          <button id="publishedSwapBtn" type="button">Swap shift</button>
          <button id="publishedHistoryBtn" type="button">View history</button>
          <div class="close-row">
            <button id="publishedDetailsClose" type="button">Close</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Override Amendment Modal -->
    <div class="modal-backdrop" id="overrideAmendmentModalBackdrop" aria-hidden="true">
      <div class="modal" role="dialog" aria-modal="true" aria-labelledby="overrideAmendmentTitle">
        <h2 id="overrideAmendmentTitle">Override Shift Times</h2>
        <p id="overrideAmendmentSubtitle" class="subtitle"></p>
        
        <div class="modal-bubble" style="padding: 16px;">
          <div style="font-size: 13px; color: #64748b; margin-bottom: 12px; font-weight: 600;">Amendment Details</div>
          <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 12px; margin-bottom: 12px;">
            <div>
              <label style="font-size: 12px; color: #64748b; display: block; margin-bottom: 4px;">Start</label>
              <input type="time" id="amendmentStartTime" style="width: 100%; padding: 8px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 13px; box-sizing: border-box;">
            </div>
            <div>
              <label style="font-size: 12px; color: #64748b; display: block; margin-bottom: 4px;">End</label>
              <input type="time" id="amendmentEndTime" style="width: 100%; padding: 8px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 13px; box-sizing: border-box;">
            </div>
            <div>
              <label style="font-size: 12px; color: #64748b; display: block; margin-bottom: 4px;">Hours</label>
              <input type="number" id="amendmentHours" step="0.25" min="0" max="24" style="width: 100%; padding: 8px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 13px; box-sizing: border-box;">
            </div>
          </div>
          
          <label style="font-size: 13px; color: #dc2626; display: block; margin-bottom: 8px; margin-top: 12px; font-weight: 600;">Reason (internal note)</label>
          <textarea id="amendmentReason" rows="3" placeholder="Reason for override..." style="width: 100%; padding: 8px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 13px; font-family: inherit; resize: vertical; box-sizing: border-box; margin-bottom: 12px;"></textarea>
        </div>
        
        <div class="btns">
          <button id="amendmentSaveBtn" type="button" class="primary">Save Override</button>
          <button id="amendmentCancelBtn" type="button">Cancel</button>
        </div>
      </div>
    </div>

    <!-- Comments Modal -->
    <div class="modal-backdrop" id="commentsModalBackdrop" aria-hidden="true">
      <div class="modal" role="dialog" aria-modal="true" aria-labelledby="commentsModalTitle">
        <h2 id="commentsModalTitle">Comments</h2>
        <p id="commentsModalSubtitle" class="subtitle"></p>
        
        <div class="modal-bubble" style="max-height: 400px; overflow-y: auto;">
          <div id="commentsList" style="display: flex; flex-direction: column; gap: 12px;"></div>
        </div>
        
        <!-- Add comment section -->
        <div class="modal-bubble" style="margin-top: 12px; padding: 16px;">
          <label style="font-size: 13px; display: block; margin-bottom: 8px; font-weight: 600;">Add Comment</label>
          <textarea id="newCommentText" rows="3" placeholder="Type your comment..." style="width: 100%; padding: 8px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 13px; font-family: inherit; resize: vertical; box-sizing: border-box; margin-bottom: 8px;"></textarea>
          
          <div style="display: flex; gap: 8px; align-items: center;">
            <label for="commentVisibilityDropdown" style="font-size: 12px; color: #64748b;">Who can see:</label>
            <select id="commentVisibilityDropdown" style="padding: 4px 8px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 12px; cursor: pointer;">
              <option value="admin_only">Admin only</option>
              <option value="all_staff" selected>All staff</option>
              <option value="user_only">User only</option>
            </select>
          </div>
          
          <button id="addCommentBtn" type="button" class="primary" style="margin-top: 12px; width: 100%;">Add Comment</button>
        </div>
        
        <div class="btns">
          <button id="commentsModalClose" type="button">Close</button>
        </div>
      </div>
    </div>

    <!-- Notices Modal (merged feed) -->
    <div class="modal-backdrop" id="noticeAllModal" aria-hidden="true">
      <div class="modal" role="dialog" aria-modal="true">
        <h2>Notices & Notifications</h2>
        <div class="modal-bubble" style="max-height: 500px; overflow-y: auto;">
          <div id="noticeAllList" style="display: flex; flex-direction: column; gap: 12px;"></div>
        </div>
        <div class="btns">
          <button id="noticeAllClose" type="button">Close</button>
        </div>
      </div>
    </div>

    <!-- Shift Swap Modal -->
    <div class="modal-backdrop" id="shiftSwapModal" aria-hidden="true">
      <div class="modal" role="dialog" aria-modal="true" aria-labelledby="shiftSwapTitle">
        <h2 id="shiftSwapTitle">Propose Shift Swap</h2>
        <p id="shiftSwapSubtitle" class="subtitle"></p>

        <div class="modal-bubble">
          <div style="margin-bottom: 16px;">
            <label style="display: block; font-size: 13px; font-weight: 600; margin-bottom: 6px;">Your shift:</label>
            <div id="swapYourShift" style="padding: 10px; background: #f3f4f6; border-radius: 6px; font-size: 13px;"></div>
          </div>

          <div style="margin-bottom: 16px;">
            <label for="swapPeerSelect" style="display: block; font-size: 13px; font-weight: 600; margin-bottom: 6px;">Swap with:</label>
            <select id="swapPeerSelect" style="width: 100%; padding: 8px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 13px; font-family: inherit;">
              <option value="">Select staff member...</option>
            </select>
          </div>

          <div style="margin-bottom: 16px;">
            <label for="swapDateSelect" style="display: block; font-size: 13px; font-weight: 600; margin-bottom: 6px;">Their shift on:</label>
            <select id="swapDateSelect" style="width: 100%; padding: 8px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 13px; font-family: inherit;" disabled>
              <option value="">Select their shift date...</option>
            </select>
          </div>
        </div>

        <div class="btns">
          <button id="swapSubmitBtn" type="button" class="primary">Send Request</button>
          <button id="swapCancelBtn" type="button">Cancel</button>
        </div>
      </div>
    </div>

    <!-- Print Rota Modal -->
    <div class="modal-backdrop" id="rotaPrintModal" aria-hidden="true" style="display:none;">
      <div class="modal" role="dialog" aria-modal="true" aria-labelledby="rotaPrintTitle">
        <div style="display:flex; justify-content:space-between; align-items:center;">
          <h2 id="rotaPrintTitle" style="margin:0;">Print Rota</h2>
          <button id="rotaPrintCloseX" type="button" style="background:none; border:none; font-size:24px; cursor:pointer; color:#666;">&times;</button>
        </div>
        <p class="subtitle">Generate printouts for the rota schedule</p>

        <!-- ADMIN OPTIONS -->
        <div id="rotaPrintAdminOptions" style="display:none;">
          <div class="card" style="padding:12px; margin-top:12px;">
            <div style="font-weight:800; margin-bottom:12px;">Admin: Advanced Print Configuration</div>
            <p style="font-size:13px; color:#666; margin:0 0 12px;">Configure detailed print options including status filters, role selection, staff filtering, and requests overlay.</p>
            
            <button type="button" onclick="openRotaAdminPrintConfig()" style="width:100%; padding:12px; background:#1976d2; color:white; border:none; border-radius:4px; cursor:pointer; font-weight:600; font-size:14px;">
              Open Advanced Print Configuration
            </button>
          </div>
        </div>

        <div class="btns" style="margin-top:12px;">
          <button id="rotaPrintClose" type="button">Close</button>
        </div>
      </div>
    </div>

    <!-- User Account Modal -->
      <div class="modal-backdrop" id="userModal" aria-hidden="true" style="display:none;">
        <div class="modal" role="dialog" aria-modal="true" aria-labelledby="userTitle">
          <!-- HEADER: title left, language right -->
          <div class="user-head">
            <div class="user-head-left">
              <h2 id="userTitle">Edit your account</h2>
              <p class="subtitle" id="userMeta">∆í?"</p>
            </div>

            <div class="user-flags" aria-label="Language">
              <div class="flags-label">Language</div>
              <div class="flags-buttons">
                <button id="userLangEn" type="button" class="flag-btn" title="English" aria-label="English">
                  <img class="flag-img" src="icons/gb.svg" alt="">
                </button>
                <button id="userLangEs" type="button" class="flag-btn" title="Spanish" aria-label="Spanish">
                  <img class="flag-img" src="icons/es.svg" alt="">
                </button>
              </div>
            </div>
          </div>

          <!-- CHANGE PIN CARD -->
          <div class="card" style="padding:10px; margin:10px 0;">
            <div style="font-weight:800; margin-bottom:6px;">Change PIN</div>

            <div class="row" style="gap:8px;">
              <input id="userOldPin" class="user-pin" inputmode="numeric" maxlength="4" placeholder="Current PIN" />
              <input id="userNewPin" class="user-pin" inputmode="numeric" maxlength="4" placeholder="New PIN" />
              <input id="userNewPin2" class="user-pin" inputmode="numeric" maxlength="4" placeholder="Repeat new PIN" />
            </div>

            <div class="btns" style="margin-top:10px; justify-content:flex-end;">
              <button id="userSavePin" class="primary" type="button">Save new PIN</button>
            </div>

            <div class="err" id="userPinErr">Error.</div>
            <div class="subtitle" id="userPinOk" style="display:none; margin-top:8px; color:#0b6b2b; font-weight:700;">
              PIN updated.
            </div>
          </div>

          <!-- PREFERENCES CARD -->
          <div class="card" style="padding:10px; margin:10px 0;" id="userPrefsCard">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:6px;">
              <div style="font-weight:800;">Preferences (1‚Äì5)</div>
              <button id="userPrefsToggle" class="btn-collapse" style="background:none; border:none; padding:4px 8px; cursor:pointer; font-size:16px; color:var(--text-muted, #666);">‚ñº</button>
            </div>
            <div class="subtitle" id="userPrefsSubtitle" style="display:none; margin:0 0 10px 0; font-size:12px; color:var(--text-muted, #666);">1 = avoid if possible, 3 = neutral, 5 = keen.</div>

            <div class="row" id="userPrefsContent" style="display:none; gap:10px; flex-direction:column; align-items:stretch;">
              <label style="display:flex; justify-content:space-between; align-items:center; gap:10px;">
                <span>Shift clustering</span>
                <span id="prefShiftClusteringValue" style="font-weight:700;">3</span>
              </label>
              <input id="prefShiftClustering" type="range" min="1" max="5" step="1" value="3" aria-label="Shift clustering preference" />
              <div class="subtitle" style="font-size:12px; color:var(--text-muted, #666);">Higher = prefers consecutive shifts; lower = prefers spacing.</div>

              <label style="display:flex; justify-content:space-between; align-items:center; gap:10px;">
                <span>Night appetite</span>
                <span id="prefNightAppetiteValue" style="font-weight:700;">3</span>
              </label>
              <input id="prefNightAppetite" type="range" min="1" max="5" step="1" value="3" aria-label="Night appetite preference" />
              <div class="subtitle" style="font-size:12px; color:var(--text-muted, #666);">Higher = more willing for nights.</div>

              <label style="display:flex; justify-content:space-between; align-items:center; gap:10px;">
                <span>Weekend appetite</span>
                <span id="prefWeekendAppetiteValue" style="font-weight:700;">3</span>
              </label>
              <input id="prefWeekendAppetite" type="range" min="1" max="5" step="1" value="3" aria-label="Weekend appetite preference" />
              <div class="subtitle" style="font-size:12px; color:var(--text-muted, #666);">Higher = more willing for weekends.</div>

              <label style="display:flex; justify-content:space-between; align-items:center; gap:10px;">
                <span>Leave adjacency</span>
                <span id="prefLeaveAdjacencyValue" style="font-weight:700;">3</span>
              </label>
              <input id="prefLeaveAdjacency" type="range" min="1" max="5" step="1" value="3" aria-label="Leave adjacency preference" />
              <div class="subtitle" style="font-size:12px; color:var(--text-muted, #666);">Higher = prefers leave next to days off; lower = fine to separate.</div>
            </div>

            <div class="btns" id="userPrefsBtns" style="display:none; margin-top:12px; justify-content:flex-end; gap:8px;">
              <button id="userSavePrefs" class="primary" type="button">Save preferences</button>
            </div>

            <div class="subtitle" id="userPrefsOk" style="display:none; margin-top:8px; color:#0b6b2b; font-weight:700;">Preferences saved.</div>
            <div class="err" id="userPrefsErr" style="display:none;">Error.</div>
          </div>

          <!-- CALENDAR SUBSCRIPTION CARD -->
          <div class="card" style="padding:10px; margin:10px 0;" id="userCalendarCard">
            <div style="font-weight:800; margin-bottom:6px;">üìÖ Calendar Subscription</div>
            <div class="subtitle" style="margin:0 0 10px 0; font-size:12px; color:var(--text-muted, #666);">
              Subscribe to your published shifts in Apple Calendar, Google Calendar, or Outlook.
            </div>

            <div id="calendarTokenStatus"></div>

            <div class="btns" style="gap:8px; margin-bottom:10px;">
              <button id="generateCalendarToken" class="primary" type="button">Generate Calendar Link</button>
              <button id="revokeCalendarToken" class="secondary" type="button" disabled>Revoke Link</button>
            </div>

            <div id="calendarLinkDisplay" style="display:none;">
              <label style="font-weight:700; margin-top:10px; display:block;">HTTPS URL (Google/Outlook):</label>
              <div style="display:flex; gap:4px; margin-bottom:10px;">
                <input type="text" id="calendarURL" readonly style="flex:1; font-size:11px; padding:8px; border:1px solid #d1d5db; border-radius:4px; background:#f9fafb;" />
                <button id="copyCalendarURL" class="secondary" type="button" title="Copy URL">üìã</button>
              </div>

              <label style="font-weight:700; display:block;">webcal:// URL (Apple Calendar):</label>
              <div style="display:flex; gap:4px;">
                <input type="text" id="webcalURL" readonly style="flex:1; font-size:11px; padding:8px; border:1px solid #d1d5db; border-radius:4px; background:#f9fafb;" />
                <button id="copyWebcalURL" class="secondary" type="button" title="Copy webcal URL">üìã</button>
              </div>

              <div class="subtitle" style="font-size:11px; margin-top:10px; color:var(--text-muted, #666);">
                <strong>‚ö†Ô∏è Keep this link private.</strong> Anyone with this URL can see your published shifts.
                Regenerate the link to invalidate old URLs.
              </div>
            </div>

            <div class="subtitle" id="calendarOk" style="display:none; margin-top:8px; color:#0b6b2b; font-weight:700;">Success.</div>
            <div class="err" id="calendarErr" style="display:none;">Error.</div>
          </div>

          <!-- BOTTOM BUTTONS -->
          <div class="user-footer">
            <button id="userLogout" type="button">Log out</button>
            <button id="userClose" type="button">Close</button>
          </div>
        </div>
      </div>

    </div> <!-- close .wrap -->

  <script src="js/assignment-history.js"></script>
  <script src="js/rota-context-menu.js"></script>
  <script src="js/user-modal.js"></script>
  <script>
    console.log("ROTA.HTML LOADING - VERSION 3", "readyState=", document.readyState);
    // Supabase + storage accessors (tolerate early execution before defer scripts)
    const getSupabase = () => window.supabaseClient;
    const getStorageKey = () => window.STORAGE_KEY || "calpeward.loggedInUserId";

    // Session is handled via token in sessionStorage; no PIN handoff or window.name needed

    let currentPeriod = null;
    let allUsers = [];
    let allWeeks = [];
    let shifts = []; // shift_catalogue rows
    let shiftMap = new Map(); // id -> shift_catalogue row
    let assignmentsMap = new Map(); // user_id_date -> rota_assignment
    let overridesMap = new Map(); // rota_assignment_id -> rota_assignment_override
    let commentsMap = new Map(); // rota_assignment_id -> [comments array]
    let requestsMap = new Map(); // user_id_date -> request
    let patterns = new Map(); // pattern_id -> pattern_definitions
    let userPatterns = new Map(); // user_id -> user_patterns row
    let periodData = null;
    let showRequests = false;
    
    // Permission flags (set during auth)
    let canViewAllRequests = false;
    let canViewOwnRequests = false;
    let canEditDraft = false;
    let canEditPublished = false;
    let currentEditContext = "draft";

    // Expose context for helper modules (context menu, history)
    window.currentEditContext = currentEditContext;
    window.periodData = periodData;
    
    // Load staffing defaults from localStorage (set in admin panel)
    function getStaffingDefaults() {
      const defaults = JSON.parse(localStorage.getItem("calpeward.staffing_defaults") || 
        '{"day_sn_required":3,"day_na_required":3,"night_sn_required":2,"night_na_required":2}');
      return defaults;
    }
    
    // ========== PERIOD LOADING ==========
    /**
     * Load all data for a specific rota period (dates, shifts, assignments, etc.)
     */
    async function loadPeriod(periodId) {
      if (!periodId) return;
      
      console.log("[ROTA] loadPeriod starting for period:", periodId);
      
      try {
        const token = window.currentToken || sessionStorage.getItem('calpe_ward_token');
        if (!token) throw new Error('No session token');
        
        // Load all periods via RPC to get metadata for selected period
        const { data: allPeriods, error: pErr } = await supabaseClient.rpc("rpc_get_rota_periods", {
          p_token: token
        });

        if (pErr) throw new Error(`Periods load failed: ${pErr.message}`);
        const period = (allPeriods || []).find(p => p.id === periodId);
        if (!period) throw new Error("Period not found");
        
        currentPeriod = period;
        periodData = period;
        window.currentPeriod = currentPeriod;
        window.periodData = periodData;
        
        console.log("[ROTA] Generating dates for period...");
        
        // Helper functions for date generation
        function generateDatesForPeriod(startDate, endDate) {
          const dates = [];
          const d = new Date(startDate);
          while (d <= new Date(endDate)) {
            dates.push(new Date(d).toISOString().split('T')[0]);
            d.setDate(d.getDate() + 1);
          }
          return dates;
        }
        
        function groupDatesIntoWeeks(dates) {
          const weeks = [];
          const grouped = {};
          dates.forEach(dateStr => {
            const d = new Date(dateStr + 'T00:00:00Z');
            const dayOfWeek = d.getUTCDay();
            const weekStart = new Date(d);
            weekStart.setUTCDate(d.getUTCDate() - dayOfWeek);
            const weekStartStr = weekStart.toISOString().split('T')[0];
            if (!grouped[weekStartStr]) grouped[weekStartStr] = [];
            grouped[weekStartStr].push(dateStr);
          });
          Object.entries(grouped).forEach(([weekStartStr, dates]) => {
            const weekStartDate = new Date(weekStartStr + 'T00:00:00Z');
            weeks.push({ 
              weekStart: weekStartDate,
              days: dates.map(d => ({ date: d }))
            });
          });
          return weeks;
        }
        
        const dates = generateDatesForPeriod(period.start_date, period.end_date);
        allWeeks = groupDatesIntoWeeks(dates);

        // Load users via RPC (active only)
        console.log("[ROTA] Loading users via RPC...");
        const { data: users, error: uErr } = await supabaseClient.rpc("rpc_get_users_basic", {
          p_token: token,
          p_include_inactive: false
        });

        if (uErr) throw new Error(`Users load failed: ${uErr.message}`);
        allUsers = (users || []).map(u => ({ ...u, is_non_staff: false }));

        // Load non-staff for this period
        console.log("[ROTA] Loading period non-staff...");
        try {
          const { data: nonStaff, error: nsErr } = await supabaseClient.rpc("rpc_get_period_non_staff", {
            p_token: token,
            p_period_id: periodId
          });

          if (nsErr) {
            console.warn("[ROTA] Non-staff load failed:", nsErr);
          } else if (nonStaff && nonStaff.length > 0) {
            console.log("[ROTA] Loaded", nonStaff.length, "non-staff");
            nonStaff.forEach(ns => {
              allUsers.push({
                id: ns.period_non_staff_id,
                period_non_staff_id: ns.period_non_staff_id,
                name: ns.name,
                role_id: ns.role_group === 'staff_nurse' ? 2 : 3,
                category: ns.category,
                is_admin: false,
                is_non_staff: true,
                counts_towards_staffing: ns.counts_towards_staffing,
                display_order: ns.display_order
              });
            });
          }
        } catch (e) {
          console.warn("[ROTA] Failed to load non-staff:", e.message);
        }

        // Load shift catalogue via RPC
        console.log("[ROTA] Loading shifts via RPC...");
        const { data: shiftsData, error: sErr } = await supabaseClient.rpc("rpc_get_shifts", {
          p_token: token
        });

        if (sErr) throw new Error(`Shifts load failed: ${sErr.message}`);
        shifts = shiftsData || [];
        shiftMap.clear();
        (shifts || []).forEach(s => shiftMap.set(s.id, s));
        console.log("[ROTA] Loaded", shiftMap.size, "shifts");

        // Load assignments via RPC
        console.log("[ROTA] Loading assignments via RPC...");
        const canViewDraft = window.PermissionsModule?.hasPermission("rota.view_draft");
        const isPeriodPublished = period.status === "published";

        assignmentsMap.clear();
        overridesMap.clear();
        commentsMap.clear();
        
        if (canViewDraft || isPeriodPublished) {
          const { data: assignments, error: aErr } = await supabaseClient.rpc("rpc_get_rota_assignments", {
            p_token: token,
            p_period_id: periodId,
            p_include_draft: canViewDraft || !isPeriodPublished
          });

          if (aErr) throw new Error(`Assignments load failed: ${aErr.message}`);

          const assignmentIds = [];
          (assignments || []).forEach(a => {
            const userId = a.user_id || a.period_non_staff_id;
            const key = `${userId}_${a.date}`;
            assignmentsMap.set(key, a);
            if (a.id) assignmentIds.push(a.id);
          });
          
          console.log("[ROTA] Loaded", assignmentsMap.size, "assignments");

          // Load overrides for published periods via RPC
          if (isPeriodPublished && assignmentIds.length > 0) {
            const { data: overrides, error: oErr } = await supabaseClient.rpc("rpc_get_rota_assignment_overrides", {
              p_token: token,
              p_assignment_ids: assignmentIds
            });

            if (oErr) console.warn("[ROTA] Error loading overrides:", oErr.message);
            else {
              (overrides || []).forEach(o => {
                overridesMap.set(o.rota_assignment_id, o);
              });
              console.log("[ROTA] Loaded", overridesMap.size, "overrides");
            }
          }

          // Load comments via RPC
          if (assignmentIds.length > 0) {
            const { data: comments, error: cErr } = await supabaseClient.rpc("rpc_get_rota_assignment_comments", {
              p_token: token,
              p_assignment_ids: assignmentIds
            });

            if (cErr) {
              console.warn("[ROTA] Error loading comments:", cErr.message);
            } else {
              (comments || []).forEach(c => {
                if (!commentsMap.has(c.rota_assignment_id)) {
                  commentsMap.set(c.rota_assignment_id, []);
                }
                commentsMap.get(c.rota_assignment_id).push(c);
              });
              console.log("[ROTA] Loaded comments for", commentsMap.size, "assignments");
            }
          }
        }

        // Load requests for this period via RPC
        console.log("[ROTA] Loading requests via RPC...");
        try {
          const { data: requests, error: rErr } = await supabaseClient.rpc("get_requests_for_period", {
            p_token: token,
            p_start_date: period.start_date,
            p_end_date: period.end_date,
            p_force_view_all: canViewAllRequests
          });

          if (rErr) {
            console.warn("[ROTA] Failed to load requests:", rErr.message);
          } else {
            requestsMap.clear();
            (requests || []).forEach(r => {
              const key = `${r.user_id}_${r.date}`;
              requestsMap.set(key, r);
            });
            console.log("[ROTA] Loaded", requestsMap.size, "requests");
          }
        } catch (err) {
          console.warn("[ROTA] Failed to load requests:", err.message);
        }

        // Load user patterns via RPC
        console.log("[ROTA] Loading user patterns via RPC...");
        try {
          const { data: patternsData, error: patErr } = await supabaseClient.rpc("rpc_get_user_patterns", {
            p_token: token
          });

          if (patErr) {
            console.warn("[ROTA] Failed to load user patterns:", patErr.message);
          } else {
            userPatterns.clear();
            (patternsData || []).forEach(p => {
              userPatterns.set(p.user_id, p);
            });
            console.log("[ROTA] Loaded", userPatterns.size, "user patterns");
          }
        } catch (err) {
          console.warn("[ROTA] Failed to load user patterns:", err.message);
        }

        console.log("[ROTA] Period data loaded successfully");
        
        // Display period status and configure editing controls
        displayPeriodStatus(period);
        updateEditingControls(period);
        
        // Render the rota with loaded data
        if (typeof renderRota === 'function') {
          renderRota();
          console.log("[ROTA] Rota rendered");
        } else {
          console.warn("[ROTA] renderRota function not available");
        }
        
      } catch (err) {
        console.error("[ROTA] loadPeriod error:", err);
        throw err;
      }
    }

    // ========== AUTH ==========
    async function checkAuth() {
      console.log("[ROTA] checkAuth starting...");
      
      if (!window.PermissionsModule || typeof window.PermissionsModule.loadCurrentUserPermissions !== "function") {
        console.error("[ROTA] PermissionsModule not available");
        window.location.href = "index.html";
        return null;
      }

      console.log("[ROTA] Calling PermissionsModule.loadCurrentUserPermissions...");
      await window.PermissionsModule.loadCurrentUserPermissions();
      const currentUser = window.PermissionsModule.getCurrentUser();
      console.log("[ROTA] After permissions load, currentUser:", currentUser);

      if (!currentUser) {
        console.warn("[ROTA] No current user - redirecting to login");
        window.location.href = "index.html";
        return null;
      }

      console.log("[ROTA] User authenticated:", currentUser.name);

      // Store globally for rota.html and other scripts
      window.currentUser = currentUser;
      
      // Update loginBadge with user name
      const loginBadge = document.getElementById("loginBadge");
      const txt = loginBadge?.querySelector(".acc-txt");
      if (txt) {
        txt.textContent = currentUser.name;
      } else if (loginBadge) {
        loginBadge.textContent = currentUser.name;
      }
      
      // Update admin badge
      const adminBadge = document.getElementById("adminBadge");
      if (adminBadge) {
        adminBadge.style.display = currentUser.is_admin ? "inline-block" : "none";
      }
      
      // Show navigation admin link only for admins
      const navAdminLink = document.getElementById("navAdminLink");
      if (navAdminLink) navAdminLink.style.display = currentUser.is_admin ? "inline" : "none";

      // Show View As button only for superadmin
      const viewAsBtn = document.getElementById("viewAsBtn");
      if (viewAsBtn) viewAsBtn.style.display = currentUser.is_admin ? "inline-block" : "none";

      // Show Add Non-Staff if admin or mentor
      const addNsBtn = document.getElementById("addNonStaffBtn");
      const isMentor = window.PermissionsModule?.hasPermission?.('non_staff.edit_student_shifts');
      if (addNsBtn) {
        addNsBtn.style.display = (currentUser.is_admin || isMentor) ? "inline-block" : "none";
        addNsBtn.onclick = openNonStaffModal;
      }

      // Show Print button only for admins
      const rotaPrintBtn = document.getElementById("rotaPrintBtn");
      if (rotaPrintBtn) rotaPrintBtn.style.display = currentUser.is_admin ? "inline-block" : "none";

      return currentUser;
    }

    const logoutBtn = document.getElementById("logoutBtn");
    if (logoutBtn) {
      logoutBtn.addEventListener("click", async () => {
        await logout();
      });
    } else {
      console.warn("[ROTA BOOT] logoutBtn not found; skipping logout binding");
    }

    // User modal is now handled by js/user-modal.js

    // ========== HELPERS ==========
    // selectedNonStaffForDelete is declared in non-staff-modal-shared.js
    let bankHolidaysByDate = {}; // Cache bank holidays by date string (YYYY-MM-DD)
    
    function closePublishedDetails() {
      const modal = document.getElementById("publishedDetailsModal");
      if (modal) modal.setAttribute("aria-hidden", "true");
    }

    window.openPublishedDetails = function openPublishedDetails(context) {
      console.log("[OPEN PUBLISHED DETAILS] Called with context:", context);
      window.currentPublishedContext = context;
      window.lastPublishedCell = context;
      const { userId, date } = context;
      
      const user = allUsers?.find(u => u.id === userId);
      const assignment = assignmentsMap?.get(`${userId}_${date}`);
      const shift = assignment ? shiftMap?.get(assignment.shift_id) : null;
      
      // Populate modal header
      const titleEl = document.getElementById("publishedDetailsTitle");
      const subtitleEl = document.getElementById("publishedDetailsSubtitle");
      if (titleEl) titleEl.textContent = user?.name || "Shift Details";
      const dateObj = new Date(date);
      if (subtitleEl) subtitleEl.textContent = dateObj.toLocaleDateString("en-GB", { weekday: "short", day: "numeric", month: "short", year: "numeric" });
      
      // Populate shift details
      const codeEl = document.getElementById("publishedShiftCode");
      const nameEl = document.getElementById("publishedShiftName");
      const restDayLabel = document.getElementById("restDayLabel");
      
      if (shift?.code === "O") {
        // Rest day
        if (codeEl) codeEl.textContent = "OFF";
        if (nameEl) nameEl.textContent = "Rest day";
        if (restDayLabel) restDayLabel.style.display = "";
      } else if (shift) {
        if (codeEl) codeEl.textContent = shift.code || "";
        if (nameEl) nameEl.textContent = shift.shift_name || shift.code || "";
        if (restDayLabel) restDayLabel.style.display = "none";
      } else {
        if (codeEl) codeEl.textContent = "‚Äî";
        if (nameEl) nameEl.textContent = "No shift assigned";
        if (restDayLabel) restDayLabel.style.display = "none";
      }
      
      // Populate times and hours
      const override = assignment ? overridesMap?.get(assignment.id) : null;
      
      const scheduledTimesRow = document.getElementById("scheduledTimesRow");
      const scheduledTimes = document.getElementById("scheduledTimes");
      const actualTimesRow = document.getElementById("actualTimesRow");
      const actualTimes = document.getElementById("actualTimes");
      const hoursRow = document.getElementById("hoursRow");
      const hoursEl = document.getElementById("publishedShiftHours");
      
      if (shift && shift.code !== "O") {
        // Show scheduled times
        const startTime = shift.start_time ? shift.start_time.slice(0, 5) : "‚Äî";
        const endTime = shift.end_time ? shift.end_time.slice(0, 5) : "‚Äî";
        if (scheduledTimes) scheduledTimes.textContent = `${startTime} ‚Äì ${endTime}`;
        if (scheduledTimesRow) scheduledTimesRow.style.display = "";
        if (hoursEl) hoursEl.textContent = shift.hours_value || "‚Äî";
        if (hoursRow) hoursRow.style.display = "";
      } else {
        if (scheduledTimesRow) scheduledTimesRow.style.display = "none";
        if (hoursRow) hoursRow.style.display = "none";
      }
      
      // Show override if present
      if (override && (override.override_start_time || override.override_end_time)) {
        const overrideStart = override.override_start_time || "‚Äî";
        const overrideEnd = override.override_end_time || "‚Äî";
        if (actualTimes) actualTimes.textContent = `${overrideStart} ‚Äì ${overrideEnd}`;
        if (actualTimesRow) actualTimesRow.style.display = "";
        if (hoursEl && override.override_hours) hoursEl.textContent = override.override_hours;
      } else {
        if (actualTimesRow) actualTimesRow.style.display = "none";
      }
      
      // Populate comments if visible
      const commentDisplay = document.getElementById("commentDisplay");
      const commentText = document.getElementById("commentText");
      const comments = assignment ? commentsMap?.get(assignment.id) : null;
      const isAdmin = window.currentUser?.is_admin;
      const visibleComments = (comments || []).filter(c => {
        const vis = c.comment_visibility || (c.is_admin_only ? 'admin_only' : 'all_staff');
        if (vis === 'admin_only') return isAdmin;
        if (vis === 'user_only') return window.currentUser?.id === userId;
        return true;
      });
      
      if (visibleComments.length > 0) {
        const firstComment = visibleComments[0];
        if (commentText) commentText.textContent = firstComment.comment || "";
        if (commentDisplay) commentDisplay.style.display = "";
      } else {
        if (commentDisplay) commentDisplay.style.display = "none";
      }
      
      // Open modal
      const modal = document.getElementById("publishedDetailsModal");
      if (modal) modal.setAttribute("aria-hidden", "false");
    }

    function handlePublishedChange() {
      const cell = window.lastPublishedCell || lastPublishedCell;
      if (!cell) return;
      if (!canEditPublished) {
        alert("You don't have permission to edit published rotas.");
        return;
      }
      closePublishedDetails();
      
      // Try to open shift picker
      if (typeof window.openShiftPickerForPublished === "function") {
        console.log("[ROTA] openShiftPickerForPublished is available, calling it");
        window.openShiftPickerForPublished(cell.userId, cell.date);
      } else {
        console.error("[ROTA] openShiftPickerForPublished not available. Checking shift-editor status...");
        console.log("[ROTA] window.initDraftEditing available?", typeof window.initDraftEditing === "function");
        alert("Shift editor not ready. Please try again or refresh the page.");
      }
    }

    function handlePublishedOverride() {
      const cell = window.lastPublishedCell || lastPublishedCell;
      if (!cell) return;
      if (!canEditPublished) {
        alert("You don't have permission to edit published rotas.");
        return;
      }
      closePublishedDetails();
      openOverrideAmendmentModal(cell.userId, cell.date);
    }

    function openOverrideAmendmentModal(userId, date) {
      try {
        const backdrop = document.getElementById("overrideAmendmentModalBackdrop");
        const title = document.getElementById("overrideAmendmentTitle");
        const subtitle = document.getElementById("overrideAmendmentSubtitle");
        const startTimeInput = document.getElementById("amendmentStartTime");
        const endTimeInput = document.getElementById("amendmentEndTime");
        const hoursInput = document.getElementById("amendmentHours");
        const reasonInput = document.getElementById("amendmentReason");

        if (!backdrop) {
          console.error("[OVERRIDE AMENDMENT] Modal backdrop not found");
          alert("Modal not initialized");
          return;
        }

        const assignment = (typeof getAssignment === "function"
          ? getAssignment(userId, date)
          : window.getAssignment?.(userId, date))
          || assignmentsMap?.get(`${userId}_${date}`);
        const user = allUsers?.find(u => u.id === userId);
        const dateObj = new Date(date);

        console.log("[OVERRIDE AMENDMENT] Opening modal for assignment:", assignment);

        if (title) title.textContent = user ? `${user.name} - Override Shift Times` : "Override Shift Times";
        if (subtitle) subtitle.textContent = dateObj.toLocaleDateString("en-GB", { weekday: "short", day: "numeric", month: "short", year: "numeric" });

        // Load existing override if any
        if (assignment?.id) {
          const override = overridesMap?.get(assignment.id);
          console.log("[OVERRIDE AMENDMENT] Found override:", override);
          if (override) {
            if (startTimeInput) startTimeInput.value = override.override_start_time || "";
            if (endTimeInput) endTimeInput.value = override.override_end_time || "";
            if (hoursInput) hoursInput.value = override.override_hours || "";
            if (reasonInput) reasonInput.value = override.comment || "";
          } else {
            // No override yet ‚Äì prefill with scheduled shift times to make entry quicker
            const shift = assignment.shift_id ? shiftMap?.get(assignment.shift_id) : null;
            const start = shift?.start_time ? shift.start_time.slice(0,5) : "";
            const end = shift?.end_time ? shift.end_time.slice(0,5) : "";
            if (startTimeInput) startTimeInput.value = start;
            if (endTimeInput) endTimeInput.value = end;
            if (hoursInput) {
              if (shift?.hours != null) {
                hoursInput.value = shift.hours;
              } else if (start && end) {
                const [sh, sm] = start.split(":").map(Number);
                const [eh, em] = end.split(":").map(Number);
                let mins = (eh*60 + em) - (sh*60 + sm);
                if (mins < 0) mins += 24*60; // overnight safeguard
                hoursInput.value = Math.round((mins/60)*4)/4;
              } else {
                hoursInput.value = "";
              }
            }
            if (reasonInput) reasonInput.value = "";
          }
        }

        // Store context for save
        window.overrideAmendmentContext = { userId, date, assignmentId: assignment?.id };

        console.log("[OVERRIDE AMENDMENT] Opening modal, context:", window.overrideAmendmentContext);
        backdrop.setAttribute("aria-hidden", "false");
      } catch (err) {
        console.error("[OVERRIDE AMENDMENT] Error opening modal:", err);
        alert("Error opening override modal. Check console.");
      }
    }

    function handlePublishedHistory() {
      const cell = window.lastPublishedCell || lastPublishedCell;
      if (!cell) return;

      if (window.AssignmentHistoryModule?.loadAssignmentHistory) {
        closePublishedDetails();
        window.AssignmentHistoryModule.loadAssignmentHistory(cell.userId, cell.date);
      } else {
        alert("History module not loaded.");
      }
    }

    async function handlePublishedComments() {
      console.log("[COMMENTS DEBUG] handlePublishedComments called");
      console.log("[COMMENTS DEBUG] window.lastPublishedCell:", window.lastPublishedCell);
      if (!window.lastPublishedCell) {
        console.log("[COMMENTS DEBUG] ERROR: window.lastPublishedCell not set!");
        alert("Please select a shift first.");
        return;
      }

      const { userId, date } = window.lastPublishedCell;
      const user = allUsers.find(u => u.id === userId);
      const assignment = assignmentsMap.get(`${userId}_${date}`);

      console.log("[COMMENTS DEBUG] Looking up assignment for key:", `${userId}_${date}`);
      console.log("[COMMENTS DEBUG] Found assignment:", assignment);

      if (!assignment) {
        console.log("[COMMENTS DEBUG] ERROR: No assignment found!");
        alert("No assignment for this date.");
        return;
      }

      // Load comments via RPC instead of direct query
      console.log("[COMMENTS DEBUG] Loading comments for assignment ID:", assignment.id);
      const token = sessionStorage.getItem('calpe_ward_token');
      const { data: comments, error } = await supabaseClient
        .rpc("rpc_get_rota_assignment_comments", { p_assignment_ids: [assignment.id], p_token: token });

      if (error) {
        console.error("Error loading comments:", error);
        alert("Failed to load comments.");
        return;
      }

      console.log("[COMMENTS DEBUG] Loaded comments:", comments);

      // The RPC returns comments for the assignment(s), filter for this specific assignment if needed
      let assignmentComments = comments || [];
      if (assignmentComments.length > 0 && assignmentComments[0].assignment_id !== undefined) {
        // If response includes assignment_id field, filter to just this assignment
        assignmentComments = assignmentComments.filter(c => c.assignment_id === assignment.id);
      }

      // Filter comments based on visibility
      const isAdmin = window.currentUser?.is_admin;
      const visibleComments = assignmentComments.filter(c => {
        const visibility = c.comment_visibility || (c.is_admin_only ? 'admin_only' : 'all_staff');
        if (visibility === 'admin_only') return isAdmin;
        if (visibility === 'all_staff') return true;
        if (visibility === 'user_only') return window.currentUser?.id === userId;
        return false;
      });

      // Populate modal
      const modal = document.getElementById("commentsModalBackdrop");
      const subtitle = document.getElementById("commentsModalSubtitle");
      const commentsList = document.getElementById("commentsList");
      const newCommentText = document.getElementById("newCommentText");
      const isAdminCheckbox = document.getElementById("isAdminOnlyCheckbox");
      const addBtn = document.getElementById("addCommentBtn");

      const dateStr = new Date(date).toLocaleDateString("en-GB", { weekday: "short", day: "numeric", month: "short", year: "numeric" });
      subtitle.textContent = `${user?.name || "Staff"} ‚Äì ${dateStr}`;

      // Render comments
      commentsList.innerHTML = "";
      if (visibleComments.length === 0) {
        const empty = document.createElement("p");
        empty.style.color = "#9ca3af";
        empty.style.fontSize = "13px";
        empty.textContent = "No comments yet.";
        commentsList.appendChild(empty);
      } else {
        visibleComments.forEach(comment => {
          const div = document.createElement("div");
          div.style.padding = "12px";
          div.style.borderLeft = "3px solid #3b82f6";
          div.style.backgroundColor = "#f0f9ff";
          div.style.borderRadius = "4px";
          div.style.position = "relative";

          // User info
          const header = document.createElement("div");
          header.style.fontSize = "12px";
          header.style.color = "#64748b";
          header.style.marginBottom = "6px";
          header.style.display = "flex";
          header.style.justifyContent = "space-between";
          header.style.alignItems = "center";

          const userTime = document.createElement("span");
          const createdUser = allUsers.find(u => u.id === comment.created_by);
          console.log("[COMMENTS RENDER] comment.created_by:", comment.created_by, "createdUser found:", createdUser, "allUsers:", allUsers);
          const createdAt = new Date(comment.created_at).toLocaleString("en-GB");
          userTime.textContent = `${createdUser?.name || "Unknown"} ‚Ä¢ ${createdAt}`;
          header.appendChild(userTime);

          // Delete button (discreet, only visible on hover)
          const canDelete = window.currentUser?.id === comment.created_by || window.currentUser?.is_admin;
          if (canDelete) {
            const deleteBtn = document.createElement("button");
            deleteBtn.type = "button";
            deleteBtn.innerHTML = "√ó";
            deleteBtn.style.background = "none";
            deleteBtn.style.border = "none";
            deleteBtn.style.fontSize = "18px";
            deleteBtn.style.color = "#94a3b8";
            deleteBtn.style.cursor = "pointer";
            deleteBtn.style.padding = "0 4px";
            deleteBtn.style.opacity = "0";
            deleteBtn.style.transition = "opacity 0.2s, color 0.2s";
            deleteBtn.title = "Delete comment";

            deleteBtn.addEventListener("mouseenter", () => {
              deleteBtn.style.color = "#dc2626";
            });
            deleteBtn.addEventListener("mouseleave", () => {
              deleteBtn.style.color = "#94a3b8";
            });

            deleteBtn.addEventListener("click", async (e) => {
              e.stopPropagation();
              if (!confirm("Delete this comment?")) return;

              try {
                const token = sessionStorage.getItem('calpe_ward_token');
                const { error } = await supabaseClient
                  .rpc("rpc_delete_rota_assignment_comment", { p_comment_id: comment.id, p_token: token });

                if (error) throw error;

                // Reload comments
                await handlePublishedComments();
              } catch (err) {
                console.error("[COMMENTS] Delete failed:", err);
                alert("Failed to delete comment.");
              }
            });

            header.appendChild(deleteBtn);

            // Show delete button on hover
            div.addEventListener("mouseenter", () => {
              deleteBtn.style.opacity = "1";
            });
            div.addEventListener("mouseleave", () => {
              deleteBtn.style.opacity = "0";
            });
          }

          // Show visibility badge
          const visibility = comment.comment_visibility || (comment.is_admin_only ? 'admin_only' : 'all_staff');
          if (visibility !== 'all_staff') {
            const badge = document.createElement("span");
            badge.style.fontSize = "11px";
            badge.style.fontWeight = "600";
            if (visibility === 'admin_only') {
              badge.style.color = "#dc2626";
              badge.textContent = "ADMIN ONLY";
            } else if (visibility === 'user_only') {
              badge.style.color = "#2563eb";
              badge.textContent = "USER ONLY";
            }
            header.appendChild(badge);
          }

          div.appendChild(header);

          // Comment text
          const text = document.createElement("div");
          text.style.fontSize = "13px";
          text.style.color = "#0f172a";
          text.style.whiteSpace = "pre-wrap";
          text.textContent = comment.comment;
          div.appendChild(text);

          commentsList.appendChild(div);
        });
      }

      // Clear form
      newCommentText.value = "";
      const visibilityDropdown = document.getElementById("commentVisibilityDropdown");
      if (visibilityDropdown) visibilityDropdown.value = 'all_staff';

      // Store current cell for add handler
      window._commentsModalCell = { userId, assignmentId: assignment.id, date };

      // Clear old listeners and attach new
      addBtn.onclick = null;
      addBtn.addEventListener("click", async () => {
        const commentText = newCommentText.value.trim();
        if (!commentText) {
          alert("Comment cannot be empty.");
          return;
        }

        console.log("[COMMENTS] window.currentUser:", window.currentUser);
        console.log("[COMMENTS] window.currentUser?.id:", window.currentUser?.id);

        const visibilityDropdown = document.getElementById("commentVisibilityDropdown");
        const commentVisibility = visibilityDropdown?.value || 'all_staff';

        console.log("[COMMENTS] Saving comment:", { assignmentId: assignment.id, commentText, commentVisibility, userId: window.currentUser?.id });

        const token = sessionStorage.getItem('calpe_ward_token');
        const { error: insertErr, data: newComment } = await supabaseClient
          .rpc("rpc_add_rota_assignment_comment", {
            p_assignment_id: assignment.id,
            p_comment_text: commentText,
            p_comment_visibility: commentVisibility,
            p_token: token
          });

        if (insertErr) {
          console.error("[COMMENTS] Error saving:", insertErr);
          alert("Failed to save comment.");
          return;
        }

        console.log("[COMMENTS] Comment saved successfully");

        // Update commentsMap with the new comment
        if (newComment) {
          const existing = commentsMap.get(assignment.id) || [];
          existing.push(newComment);
          commentsMap.set(assignment.id, existing);
          renderRota(); // Re-render to show blue dot
        }

        // Reload comments in modal
        await handlePublishedComments();
      });

      modal.setAttribute("aria-hidden", "false");
    }

    async function handlePublishedSwap() {
      const cell = window.lastPublishedCell || lastPublishedCell;
      if (!cell) return;
      if (!window.currentUser) return;

      const { userId, date } = cell;
      // Allow all logged-in staff; admins can still act. Permission gate removed for staff.
      const isAdmin = !!window.currentUser.is_admin;

      // Get initiator's user data and shift
      const initiatorUser = allUsers.find(u => u.id === userId);
      const initiatorAssignment = assignmentsMap.get(`${userId}_${date}`);
      const initiatorShift = shiftMap.get(initiatorAssignment?.shift_id);

      if (!initiatorUser || !initiatorShift) {
        alert("Could not load your shift details.");
        return;
      }

      const initiatorRoleId = initiatorUser.role_id;
      const initiatorDate = new Date(date);
      const initiatorWeekStart = new Date(initiatorDate);
      initiatorWeekStart.setDate(initiatorDate.getDate() - initiatorDate.getDay() + 1); // Monday

      // Helper: check if two dates are in the same week
      function isSameWeek(date1Str, date2Str) {
        const d1 = new Date(date1Str);
        const d2 = new Date(date2Str);
        const week1 = new Date(d1);
        week1.setDate(d1.getDate() - d1.getDay() + 1);
        const week2 = new Date(d2);
        week2.setDate(d2.getDate() - d2.getDay() + 1);
        return week1.getTime() === week2.getTime();
      }

      // Get list of other staff with shifts on other dates
      const candidates = allUsers
        .filter(u => u.id !== userId) // Remove is_active check - it's not in the users selection
        .map(u => ({
          id: u.id,
          name: u.name,
          role_id: u.role_id,
          dates: Array.from(assignmentsMap.entries())
            .filter(([key, asn]) => {
              if (!key.startsWith(u.id + "_")) return false;
              const shift = shiftMap.get(asn.shift_id);
              if (!shift || shift.code === "O") return false;

              const shiftDate = key.split("_")[1];

              // Swap must be within roles (RN‚ÜîRN or NA‚ÜîNA only)
              const initiatorRole = initiatorRoleId; // 1 or 2 = RN, 3 = NA
              const counterpartyRole = u.role_id;
              const isInitiatorRN = initiatorRole === 1 || initiatorRole === 2;
              const isCounterpartyRN = counterpartyRole === 1 || counterpartyRole === 2;

              // Must be within same role group (RN with RN, NA with NA)
              if (isInitiatorRN !== isCounterpartyRN) return false;

              // Must be same week
              if (!isSameWeek(date, shiftDate)) return false;

              return true;
            })
            .map(([key, asn]) => {
              const d = key.split("_")[1];
              const shift = shiftMap.get(asn.shift_id);
              const code = shift?.code || "?";
              return {
                date: d,
                code: code,
                label: new Date(d).toLocaleDateString("en-GB", { weekday: "short", day: "numeric", month: "short" }) + ` (${code})`
              };
            })
        }))
        .filter(c => c.dates.length > 0);

      if (!candidates.length) {
        alert("No compatible staff with shifts to swap with.");
        return;
      }

      // Show swap picker modal
      const swapModal = document.getElementById("shiftSwapModal");
      if (!swapModal) {
        alert("Swap interface not ready.");
        return;
      }

      // Display current shift info
      const currentShift = shiftMap.get(assignmentsMap.get(`${userId}_${date}`)?.shift_id);
      const currentCode = currentShift?.code || "?";
      const dateStr = new Date(date).toLocaleDateString("en-GB", { weekday: "short", day: "numeric", month: "short" });
      document.getElementById("swapYourShift").textContent = `${currentCode} on ${dateStr}`;

      // Store context for swap submission
      window.swapInitiatorContext = { userId, date, isAdmin };
      window.swapCandidates = candidates;

      // Populate peer dropdown
      const peerSelect = document.getElementById("swapPeerSelect");
      peerSelect.innerHTML = `<option value="">Select staff member...</option>` +
        candidates.map(c => `<option value="${c.id}">${c.name}</option>`).join("");

      // Clear date dropdown
      const dateSelect = document.getElementById("swapDateSelect");
      dateSelect.innerHTML = `<option value="">Select their shift date...</option>`;
      dateSelect.disabled = true;

      // Wire peer change event
      peerSelect.onchange = () => {
        const peerId = peerSelect.value;
        if (!peerId) {
          dateSelect.innerHTML = `<option value="">Select their shift date...</option>`;
          dateSelect.disabled = true;
          return;
        }
        const peer = candidates.find(c => c.id === peerId);
        if (peer) {
          dateSelect.innerHTML = `<option value="">Select their shift date...</option>` +
            peer.dates.map(d => `<option value="${d.date}">${d.label}</option>`).join("");
          dateSelect.disabled = false;
        }
      };

      swapModal.setAttribute("aria-hidden", "false");
      closePublishedDetails();
    }

    function saveOverrideAmendment() {
      const modal = document.getElementById("overrideAmendmentModalBackdrop");
      if (modal) modal.setAttribute("aria-hidden", "true");
      alert("Override amendment saved (placeholder).");
    }

    function closeOverrideAmendmentModal() {
      const modal = document.getElementById("overrideAmendmentModalBackdrop");
      if (modal) modal.setAttribute("aria-hidden", "true");
    }

    function attachAmendmentHourAutoCalc() {
      const start = document.getElementById("amendmentStartTime");
      const end = document.getElementById("amendmentEndTime");
      const hours = document.getElementById("amendmentHours");
      const update = () => {
        if (!start?.value || !end?.value) return;
        const [sh, sm] = start.value.split(":").map(Number);
        const [eh, em] = end.value.split(":").map(Number);
        let mins = (eh * 60 + em) - (sh * 60 + sm);
        if (mins < 0) mins += 24 * 60;
        const decimal = Math.round((mins / 60) * 4) / 4;
        if (hours) hours.value = decimal.toString();
      };
      if (start) start.addEventListener("change", update);
      if (end) end.addEventListener("change", update);
    }

    // Load bank holidays for the current and next few years
    async function loadBankHolidays() {
      bankHolidaysByDate = {};
      try {
        const currentYear = new Date().getFullYear();
        const years = [currentYear, currentYear + 1];
        for (const year of years) {
          const { data: holidays, error } = await supabaseClient.rpc("rpc_list_bank_holidays", {
            p_year: year
          });
          if (error) throw error;
          (holidays || []).forEach(row => {
            if (row?.holiday_date) {
              bankHolidaysByDate[row.holiday_date] = row;
            }
          });
        }
      } catch (e) {
        console.error("Failed to load bank holidays:", e);
      }
    }

    // ========== PERIOD STATUS DISPLAY ==========
    
    function displayPeriodStatus(period) {
      const status = document.getElementById("periodStatus");
      const badge = document.getElementById("statusBadge");
      const text = document.getElementById("statusText");

      const rawStatus = (period?.status || "draft").toString().toLowerCase();
      const isPublished = rawStatus === "published";

      badge.textContent = isPublished ? "Published" : "Draft";
      badge.className = `status-badge status-${isPublished ? "published" : "draft"}`;

      const start = new Date(period.start_date).toLocaleDateString('en-GB', { day: 'numeric', month: 'short', year: 'numeric' });
      const end = new Date(period.end_date).toLocaleDateString('en-GB', { day: 'numeric', month: 'short', year: 'numeric' });
      text.textContent = `${period.label || period.name || 'Period'} (${start} - ${end})`;

      status.style.display = "flex";

      const publishBtn = document.getElementById("publishBtn");
      const unpublishBtn = document.getElementById("unpublishBtn");
      const canPublish = window.PermissionsModule?.hasPermission("rota.publish") || window.currentUser?.is_admin;
      if (canPublish) {
        publishBtn.style.display = isPublished ? "none" : "inline-block";
        unpublishBtn.style.display = isPublished ? "inline-block" : "none";
      } else {
        publishBtn.style.display = "none";
        unpublishBtn.style.display = "none";
      }
    }

    function updateEditingControls(period) {
      const toggleEditingBtn = document.getElementById("toggleEditingBtn");
      const addNsBtn = document.getElementById("addNonStaffBtn");
      const metadataDisplay = document.getElementById("metadataDisplay");
      const publishedBanner = document.getElementById("publishedEditBanner");
      const isPublished = period?.status === "published";
      const canEditCurrent = isPublished ? canEditPublished : canEditDraft;

      if (toggleEditingBtn) {
        if (isPublished) {
          toggleEditingBtn.style.display = "none";
        } else {
          toggleEditingBtn.style.display = canEditCurrent ? "inline-block" : "none";
          toggleEditingBtn.textContent = "üîí Locked";
          toggleEditingBtn.classList.remove("primary");
        }
      }

      if (addNsBtn) {
        const isMentor = window.PermissionsModule?.hasPermission?.('non_staff.edit_student_shifts');
        const canShowNonStaff = isPublished && (window.currentUser?.is_admin || isMentor);
        addNsBtn.style.display = canShowNonStaff ? "inline-block" : "none";
      }

      // Show published edit banner when period is published
      if (publishedBanner) {
        if (isPublished) {
          publishedBanner.style.display = canEditCurrent ? "block" : "none";
        } else {
          publishedBanner.style.display = "none";
        }
      }

      if (typeof window.setShiftEditContext === "function") {
        if (isPublished) {
          window.setShiftEditContext({
            permissionKey: "rota.edit_published",
            contextLabel: "published rota",
            mode: "published",
            lockedLabelText: "üîí Published Locked",
            unlockedLabelText: "üîì Published Editing",
            shiftFilter: (shift) => shift?.allow_post_publish === true
          });
          currentEditContext = "published";
          window.currentEditContext = currentEditContext;
        } else {
          window.setShiftEditContext({
            permissionKey: "rota.edit_draft",
            contextLabel: "draft rota",
            mode: "draft",
            lockedLabelText: "üîí Locked",
            unlockedLabelText: "üîì Editing",
            shiftFilter: (shift) => shift?.allow_draft !== false
          });
          currentEditContext = "draft";
          window.currentEditContext = currentEditContext;
        }
      }
    }

    async function publishPeriod() {
      if (!periodData?.id) return;
      if (!window.currentUser?.is_admin) {
        alert("Admin access required.");
        return;
      }
      if (!confirm(`Publish "${periodData.name}"? This will make the rota visible to staff.`)) return;

      try {
        const { data: published, error } = await supabaseClient.rpc("admin_publish_rota_period", {
          p_token: window.currentToken,
          p_period_id: periodData.id
        });

        if (error) throw error;
        const publishedRow = Array.isArray(published) ? published[0] : published;
        if (!publishedRow) throw new Error("Publish succeeded but no period returned (check RLS)");

        periodData = publishedRow;
        displayPeriodStatus(periodData);
        updateEditingControls(periodData);
        await loadPeriod(periodData.id);

        alert("Period published.");
      } catch (e) {
        console.error("Error publishing period:", e);
        alert("Failed to publish period: " + e.message);
      }
    }

    async function unpublishPeriod() {
      if (!periodData?.id) return;
      if (!window.currentUser?.is_admin) {
        alert("Admin access required.");
        return;
      }
      if (!confirm(`Unpublish "${periodData.name}"? Staff will only see the last published rota.`)) return;

      try {
        const { data: unpublished, error } = await supabaseClient.rpc("admin_unpublish_rota_period", {
          p_token: window.currentToken,
          p_period_id: periodData.id
        });

        if (error) throw error;
        const unpublishedRow = Array.isArray(unpublished) ? unpublished[0] : unpublished;
        if (!unpublishedRow) throw new Error("Unpublish succeeded but no period returned (check RLS)");

        periodData = unpublishedRow;
        displayPeriodStatus(periodData);
        updateEditingControls(periodData);
        await loadPeriod(periodData.id);

        alert("Period unpublished. Status reverted to draft.");
      } catch (e) {
        console.error("Error unpublishing period:", e);
        alert("Failed to unpublish period: " + e.message);
      }
    }

    // ========== DRAFT EDITING ==========

    function toggleRequests() {
      const canViewAll = window.PermissionsModule.hasPermission("requests.view_all");
      const canViewOwn = window.PermissionsModule.hasPermission("requests.view_own");
      
      if (!canViewAll && !canViewOwn) {
        alert("You don't have permission to view requests.");
        return;
      }
      
      showRequests = !showRequests;
      const btn = document.getElementById("toggleRequestsBtn");
      btn.textContent = showRequests ? "üëÅÔ∏è Hide Requests" : "üëÅÔ∏è Show Requests";
      btn.classList.toggle("primary", showRequests);
      
      // Debug: log what's in requestsMap
      console.log("[REQUESTS DEBUG] showRequests toggled to:", showRequests);
      console.log("[REQUESTS DEBUG] requestsMap size:", requestsMap.size);
      console.log("[REQUESTS DEBUG] requestsMap contents:", Array.from(requestsMap.entries()));
      
      // Re-render the table to apply request visibility
      renderRota();
    }

    function toggleEditing() {
      if (!window.PermissionsModule.hasPermission("rota.edit_draft")) {
        alert("You don't have permission to edit draft rotas.");
        return;
      }

      isEditingUnlocked = !isEditingUnlocked;
      const btn = document.getElementById("toggleEditingBtn");
      const metadataDisplay = document.getElementById("metadataDisplay");
      
      btn.textContent = isEditingUnlocked ? "üîì Editing" : "üîí Locked";
      btn.classList.toggle("primary", isEditingUnlocked);
      
      // Show/hide metadata display
      if (metadataDisplay) {
        metadataDisplay.style.display = isEditingUnlocked ? "block" : "none";
      }

      // Update cell editability
      document.querySelectorAll("#rota td.cell").forEach(td => {
        td.classList.toggle("editable", isEditingUnlocked);
      });
    }



    // ========== HELPER FUNCTIONS ==========
    
    function fmt(date) {
      const d = new Date(date);
      return d.toLocaleDateString("en-GB", { day: "numeric", month: "short" });
    }

    function isBankHoliday(date) {
      if (!date) return false;
      const dateStr = date.toISOString().split('T')[0];
      return bankHolidaysByDate.hasOwnProperty(dateStr);
    }

    function getWeekStart(date) {
      const d = new Date(date);
      const day = d.getDay();
      d.setDate(d.getDate() - day);
      d.setHours(0, 0, 0, 0);
      return d;
    }

    function getRoleGroupKey(user) {
      if (!user) return "staff_nurse";
      const roleIdNum = Number(user.role_id);
      if (roleIdNum === 1) return "charge_nurse";
      if (roleIdNum === 2) return "staff_nurse";
      if (roleIdNum === 3) return "nursing_assistant";
      return "staff_nurse";
    }

    function groupUsers(users) {
      const buckets = {
        charge_nurse: [],
        staff_nurse: [],
        nursing_assistant: [],
        students: []
      };

      users.forEach(u => {
        if (u.is_non_staff && u.category === 'student') {
          buckets.students.push(u);
        } else {
          const groupKey = getRoleGroupKey(u);
          (buckets[groupKey] || buckets.staff_nurse).push(u);
        }
      });

      const sortBucket = (arr) => {
        arr.sort((a, b) => {
          if (a.is_non_staff && !b.is_non_staff) return 1;
          if (!a.is_non_staff && b.is_non_staff) return -1;

          const aOrder = a.display_order ?? 9999;
          const bOrder = b.display_order ?? 9999;
          if (aOrder !== bOrder) return aOrder - bOrder;
          return (a.name || "").localeCompare(b.name || "");
        });
      };

      sortBucket(buckets.charge_nurse);
      sortBucket(buckets.staff_nurse);
      sortBucket(buckets.nursing_assistant);
      sortBucket(buckets.students);

      const groups = [
        { title: "Charge Nurses", className: "section-cn", items: buckets.charge_nurse },
        { title: "Staff Nurses", className: "section-sn", items: buckets.staff_nurse }
      ];

      if (buckets.students.length > 0) {
        groups.push({ title: "Students", className: "section-students", items: buckets.students });
      }

      groups.push({ title: "Nursing Assistants", className: "section-na", items: buckets.nursing_assistant });

      return groups.filter(g => g.items.length > 0);
    }

    function getStaffingDefaults() {
      return {
        day_sn_required: 3,
        day_na_required: 1,
        night_sn_required: 2,
        night_na_required: 1
      };
    }

    function renderTotals() {
      const table = document.getElementById("rota");
      const existingTfoot = table.querySelector("tfoot");
      if (existingTfoot) existingTfoot.remove();

      const tfoot = document.createElement("tfoot");
      const STAFFING_DEFAULTS = getStaffingDefaults();

      function getStaffingCount(shiftObj) {
        if (!shiftObj) return 0;
        if (shiftObj.is_time_off === true) return 0;
        const hours = Number(shiftObj.hours_value) || 0;
        if (hours >= 12) return 1;
        return 0.5;
      }

      function isNightShift(shiftCode) {
        if (!shiftCode) return false;
        return shiftCode.toUpperCase().trim() === "N";
      }

      const separatorTr = document.createElement("tr");
      separatorTr.className = "totals-separator";
      const separatorTd = document.createElement("td");
      separatorTd.className = "name-col";
      separatorTd.colSpan = 1 + (allWeeks.length * 7) + allWeeks.length;
      separatorTd.style.background = "#e0e0e0";
      separatorTd.style.height = "8px";
      separatorTr.appendChild(separatorTd);
      tfoot.appendChild(separatorTr);

      const sections = [
        {
          sectionLabel: "Day Shift",
          rows: [
            { label: "Staff Nurse", roleIds: [1, 2], isNight: false, reqField: "day_sn_required" },
            { label: "Nursing Assistant", roleIds: [3], isNight: false, reqField: "day_na_required" }
          ]
        },
        {
          sectionLabel: "Night Shift",
          rows: [
            { label: "Staff Nurse", roleIds: [1, 2], isNight: true, reqField: "night_sn_required" },
            { label: "Nursing Assistant", roleIds: [3], isNight: true, reqField: "night_na_required" }
          ]
        }
      ];

      sections.forEach(section => {
        const sectionTr = document.createElement("tr");
        sectionTr.className = "totals-section-row";
        const sectionTd = document.createElement("td");
        sectionTd.className = "name-col";
        sectionTd.colSpan = 1 + (allWeeks.length * 7) + allWeeks.length;
        sectionTd.textContent = section.sectionLabel;
        sectionTr.appendChild(sectionTd);
        tfoot.appendChild(sectionTr);

        section.rows.forEach(rowDef => {
          const tr = document.createElement("tr");
          tr.className = "totals-row";

          const labelTd = document.createElement("td");
          labelTd.className = "name-col";
          labelTd.textContent = rowDef.label;
          labelTd.style.fontWeight = "600";
          labelTd.style.paddingLeft = "16px";
          tr.appendChild(labelTd);

          allWeeks.forEach(w => {
            w.days.forEach(day => {
              const cell = document.createElement("td");
              cell.className = "totals-cell";

              let total = 0;
              allUsers
                .filter(u => rowDef.roleIds.includes(u.role_id))
                .filter(u => !u.is_non_staff || u.counts_towards_staffing)
                .forEach(u => {
                  const assignment = assignmentsMap.get(`${u.id}_${day.date}`);
                  if (assignment) {
                    const shift = shiftMap.get(assignment.shift_id);
                    if (shift) {
                      const shiftNight = isNightShift(shift.code);
                      if (shiftNight === rowDef.isNight) {
                        total += getStaffingCount(shift);
                      }
                    }
                  }
                });

              const required = STAFFING_DEFAULTS[rowDef.reqField];
              const displayValue = total % 1 === 0 ? total.toString() : total.toFixed(1);
              cell.textContent = displayValue;

              if (total < required) {
                cell.style.backgroundColor = "#ffc599";
                cell.style.color = "#5d3e1f";
                cell.style.fontWeight = "600";
              }

              cell.style.textAlign = "center";
              tr.appendChild(cell);
            });

            const sep = document.createElement("td");
            sep.className = "week-sep";
            tr.appendChild(sep);
          });

          tfoot.appendChild(tr);
        });
      });

      table.appendChild(tfoot);
    }

    function renderRota() {
      const table = document.getElementById("rota");
      table.innerHTML = "";

      const thead = document.createElement("thead");
      const tbody = document.createElement("tbody");
      table.appendChild(thead);
      table.appendChild(tbody);

      const r1 = document.createElement("tr");
      const h1 = document.createElement("th");
      h1.className = "name-col";
      h1.textContent = "Name";
      r1.appendChild(h1);

      allWeeks.forEach(w => {
        const th = document.createElement("th");
        th.className = "week-head";
        th.colSpan = 7;
        const weekEnd = new Date(w.weekStart);
        weekEnd.setDate(weekEnd.getDate() + 6);
        th.innerHTML = `<span class="week-label">${fmt(w.weekStart)} ‚Äî ${fmt(weekEnd)}</span>`;
        r1.appendChild(th);

        const sep = document.createElement("th");
        sep.className = "week-sep";
        r1.appendChild(sep);
      });
      thead.appendChild(r1);

      const r2 = document.createElement("tr");
      const h2 = document.createElement("th");
      h2.className = "name-col";
      r2.appendChild(h2);

      const dayLetters = ["S", "M", "T", "W", "T", "F", "S"];
      allWeeks.forEach(w => {
        for (let i = 0; i < 7; i++) {
          const th = document.createElement("th");
          th.className = "day";
          th.textContent = dayLetters[i];
          r2.appendChild(th);
        }
        const sep = document.createElement("th");
        sep.className = "week-sep";
        r2.appendChild(sep);
      });
      thead.appendChild(r2);

      const r3 = document.createElement("tr");
      const h3 = document.createElement("th");
      h3.className = "name-col";
      r3.appendChild(h3);

      allWeeks.forEach(w => {
        for (let i = 0; i < 7; i++) {
          const d = new Date(w.weekStart);
          d.setDate(d.getDate() + i);
          const isWeekend = (d.getDay() === 0 || d.getDay() === 6);
          const isBankHol = isBankHoliday(d);
          const th = document.createElement("th");
          th.className = "date" + (isWeekend ? " weekend" : "") + (isBankHol ? " bank-holiday" : "");
          th.textContent = d.getDate();
          r3.appendChild(th);
        }
        const sep = document.createElement("th");
        sep.className = "week-sep";
        r3.appendChild(sep);
      });
      thead.appendChild(r3);

      const groups = groupUsers(allUsers);

      for (const g of groups) {
        const sectionTr = document.createElement("tr");
        sectionTr.className = "section-row";
        const sectionTd = document.createElement("td");
        sectionTd.className = `name-col ${g.className}`;
        sectionTd.colSpan = 1 + (allWeeks.length * 7) + allWeeks.length;
        sectionTd.innerHTML = `<span>${g.title}</span>`;
        sectionTr.appendChild(sectionTd);
        tbody.appendChild(sectionTr);

        for (const u of g.items) {
          const tr = document.createElement("tr");
          tr.dataset.userId = u.id;

          const nameTd = document.createElement("td");
          nameTd.className = "name-col";
          nameTd.textContent = u.name;

          if (u.is_non_staff) {
            const badge = document.createElement("span");
            badge.className = "badge pill";
            badge.style.marginLeft = "8px";
            badge.style.fontSize = "11px";
            badge.style.padding = "2px 6px";
            badge.style.borderRadius = "999px";

            if (u.category !== "student") {
              if (u.category === "agency") {
                badge.textContent = "AGENCY";
                badge.style.background = "#fef3c7";
                badge.style.color = "#92400e";
              } else if (u.category === "bank") {
                badge.textContent = "BANK";
                badge.style.background = "#ecfccb";
                badge.style.color = "#365314";
              }
              nameTd.appendChild(badge);
            }
          }

          tr.appendChild(nameTd);

          allWeeks.forEach(w => {
            for (let i = 0; i < 7; i++) {
              const dayDate = new Date(w.weekStart);
              dayDate.setDate(dayDate.getDate() + i);
              const dateStr = dayDate.toISOString().split('T')[0];
              const isWeekend = (dayDate.getDay() === 0 || dayDate.getDay() === 6);

              const td = document.createElement("td");
              td.className = "cell" + (isWeekend ? " weekend" : "");
              td.dataset.userId = u.id;
              if (u.is_non_staff && u.category === "student") {
                td.dataset.isStudentNonStaff = "true";
              }
              td.dataset.date = dateStr;

              const key = `${u.id}_${dateStr}`;
              const assignment = assignmentsMap.get(key);

              if (assignment) {
                td.dataset.assignmentId = assignment.id;
                const shift = shiftMap.get(assignment.shift_id);
                const override = (periodData?.status === "published" && assignment.id) ? overridesMap.get(assignment.id) : null;

                if (shift) {
                  const wrapper = document.createElement("div");
                  wrapper.style.position = "relative";
                  wrapper.style.width = "100%";
                  wrapper.style.height = "100%";
                  wrapper.style.display = "flex";
                  wrapper.style.flexDirection = "column";
                  wrapper.style.alignItems = "stretch";
                  wrapper.style.justifyContent = "flex-start";
                  wrapper.style.padding = "4px 2px";
                  wrapper.style.boxSizing = "border-box";
                  wrapper.style.rowGap = "2px";

                  const shiftBlock = document.createElement("div");
                  shiftBlock.className = "shift-block";
                  const codeSpan = document.createElement("span");
                  codeSpan.textContent = shift.code;
                  shiftBlock.appendChild(codeSpan);
                  wrapper.appendChild(shiftBlock);

                  if (periodData?.status === "published" && assignment.id) {
                    const badges = document.createElement("div");
                    badges.style.position = "absolute";
                    badges.style.top = "2px";
                    badges.style.right = "2px";
                    badges.style.display = "flex";
                    badges.style.gap = "2px";

                    if (override) {
                      const hasOverride = override.override_start_time || override.override_end_time || override.override_hours;
                      if (hasOverride) {
                        const overrideBadge = document.createElement("span");
                        overrideBadge.style.width = "6px";
                        overrideBadge.style.height = "6px";
                        overrideBadge.style.borderRadius = "50%";
                        overrideBadge.style.backgroundColor = "#dc2626";
                        overrideBadge.title = "Actual times/hours differ from scheduled";
                        badges.appendChild(overrideBadge);
                      }
                    }

                    const assignmentComments = commentsMap.get(assignment.id);
                    if (assignmentComments && assignmentComments.length > 0) {
                      const visibleComments = assignmentComments.filter(c => {
                        const visibility = c.comment_visibility || (c.is_admin_only ? 'admin_only' : 'all_staff');
                        if (visibility === 'admin_only') return window.currentUser?.is_admin;
                        if (visibility === 'all_staff') return true;
                        if (visibility === 'user_only') return window.currentUser?.id === u.id;
                        return false;
                      });

                      if (visibleComments.length > 0) {
                        const commentBadge = document.createElement("span");
                        commentBadge.style.width = "6px";
                        commentBadge.style.height = "6px";
                        commentBadge.style.borderRadius = "50%";
                        commentBadge.style.backgroundColor = "#3b82f6";
                        commentBadge.title = "Has comments";
                        badges.appendChild(commentBadge);
                      }
                    }

                    if (badges.children.length > 0) {
                      wrapper.appendChild(badges);
                    }
                  }

                  td.appendChild(wrapper);

                  if (shift.text_bold) {
                    shiftBlock.style.fontWeight = "700";
                  }
                  if (shift.text_italic) {
                    shiftBlock.style.fontStyle = "italic";
                  }
                  if (shift.text_color) {
                    shiftBlock.style.color = shift.text_color;
                  }
                  if (shift.fill_color) {
                    td.style.backgroundColor = shift.fill_color;
                  }

                  if (showRequests) {
                    const request = requestsMap.get(key);
                    if (request) {
                      const hint = document.createElement("div");
                      const requestValue = (request.value || "").trim();
                      const isImportant = request.important_rank && (request.important_rank === 1 || request.important_rank === 2);

                      hint.className = "request-hint";
                      hint.classList.add(isImportant ? "important" : "normal");
                      hint.textContent = isImportant
                        ? `${requestValue}${request.important_rank === 1 ? "¬π" : "¬≤"}`
                        : requestValue;

                      wrapper.appendChild(hint);
                    }
                  }
                }
              } else {
                if (showRequests) {
                  const request = requestsMap.get(key);
                  if (request) {
                    const requestValue = request.value?.trim();
                    const isImportant = request.important_rank && (request.important_rank === 1 || request.important_rank === 2);

                    if (isImportant) {
                      const superscript = request.important_rank === 1 ? "¬π" : "¬≤";
                      td.textContent = `${requestValue}${superscript}`;
                      td.style.color = "#e57373";
                    } else {
                      td.textContent = requestValue || "";
                      td.style.color = "#d1d5db";
                      td.style.fontStyle = "italic";
                    }
                  }
                }
              }

              tr.appendChild(td);
            }

            const sep = document.createElement("td");
            sep.className = "week-sep";
            sep.dataset.userId = u.id;
            sep.dataset.weekStart = w.weekStart.toISOString().split('T')[0];

            const upat = userPatterns.get(u.id);
            let assignedCount = 0;
            for (let i = 0; i < 7; i++) {
              const dayDate = new Date(w.weekStart);
              dayDate.setDate(dayDate.getDate() + i);
              const dateStr = dayDate.toISOString().split('T')[0];
              const assignment = assignmentsMap.get(`${u.id}_${dateStr}`);
              if (assignment) {
                const shift = shiftMap.get(assignment.shift_id);
                if (shift && shift.is_time_off !== true) {
                  assignedCount++;
                }
              }
            }

            if (upat && upat.pattern_id) {
              const pat = patterns.get(upat.pattern_id);
              if (pat && pat.requires_anchor && upat.anchor_week_start_date && Array.isArray(pat.weekly_targets) && pat.weekly_targets.length) {
                const weekStart = new Date(sep.dataset.weekStart);
                const anchorDateRaw = new Date(upat.anchor_week_start_date);
                const anchorDate = getWeekStart(anchorDateRaw);
                const weeksDiff = Math.floor((weekStart - anchorDate) / (7 * 24 * 60 * 60 * 1000));
                const cycleLen = pat.weekly_targets.length;
                const weekInCycle = ((weeksDiff % cycleLen) + cycleLen) % cycleLen;
                const target = pat.weekly_targets[weekInCycle];
                sep.textContent = String(target);
                const baseline = Math.min(...pat.weekly_targets);

                if (assignedCount >= target && assignedCount <= target) {
                  sep.style.backgroundColor = "#c1ffc1";
                  sep.style.color = "#1a5c1a";
                  sep.style.fontWeight = "700";
                } else if (assignedCount > target || target > baseline) {
                  sep.style.color = "#dc2626";
                  sep.style.fontWeight = "700";
                }
              } else {
                const baselineCandidates = Array.isArray(pat?.weekly_targets) && pat.weekly_targets.length ? pat.weekly_targets : [];
                let baseline = baselineCandidates.length ? Math.min(...baselineCandidates) : null;
                if (baseline == null && (u.role_id === 1 || u.role_id === 2)) baseline = 3;
                sep.textContent = String(assignedCount > 0 ? assignedCount : (baseline ?? ""));

                if (baseline != null) {
                  if (assignedCount >= baseline && assignedCount <= baseline) {
                    sep.style.backgroundColor = "#c1ffc1";
                    sep.style.color = "#1a5c1a";
                    sep.style.fontWeight = "700";
                  } else if (assignedCount > baseline) {
                    sep.style.color = "#dc2626";
                    sep.style.fontWeight = "700";
                  }
                }
              }
            } else {
              sep.textContent = "";
            }

            tr.appendChild(sep);
          });

          tbody.appendChild(tr);
        }
      }

      renderTotals();
    }

    function isTimeOff(shiftObj) {
      if (!shiftObj) return false;
      return shiftObj.is_time_off === true;
    }

    function describeAssignment(assignment) {
      if (!assignment) return "N/A";
      
      const shift = shiftMap?.get(assignment.shift_id);
      const user = allUsers?.find(u => u.id === assignment.user_id);
      const override = overridesMap?.get(assignment.id);
      
      if (!shift) return "No shift assigned";
      if (isTimeOff(shift)) return `Time Off`;
      
      // Use override times if available, otherwise use shift times
      const startTime = override?.override_start_time || shift.start_time;
      const endTime = override?.override_end_time || shift.end_time;
      const hours = override?.override_hours || shift.hours || 0;
      
      const start = startTime ? startTime.slice(0, 5) : "??:??";
      const end = endTime ? endTime.slice(0, 5) : "??:??";
      
      return `${shift.code} ${start}‚Äì${end} (${hours}h)`;
    }

    function generatePatternWarnings(userId, date) {
      const warnings = [];
      const userPatterns = patternsMap?.get(userId);
      
      if (!userPatterns) return warnings;
      
      const dateObj = new Date(date);
      const dayOfWeek = dateObj.getDay(); // 0 = Sunday, 1 = Monday, etc.
      const weekStart = getWeekStart(dateObj);
      
      // Check for patterns
      const shiftCode = assignmentsMap?.get(`${userId}_${date}`)?.shift_id
        ? shiftMap?.get(assignmentsMap.get(`${userId}_${date}`).shift_id)?.code
        : null;
      
      if (shiftCode === "N") {
        // Night shift - check if pattern discourages nights
        if (userPatterns.avoid_nights === true) {
          warnings.push("User prefers to avoid night shifts");
        }
      }
      
      // Check consecutive days pattern
      if (userPatterns.max_consecutive_days) {
        let consecutive = 1;
        let checkDate = new Date(dateObj);
        
        // Count forward
        for (let i = 1; i < 7; i++) {
          checkDate = new Date(dateObj);
          checkDate.setDate(checkDate.getDate() + i);
          const nextKey = checkDate.toISOString().split('T')[0];
          const nextAssignment = assignmentsMap?.get(`${userId}_${nextKey}`);
          if (nextAssignment?.shift_id && !isTimeOff(shiftMap.get(nextAssignment.shift_id))) {
            consecutive++;
          } else {
            break;
          }
        }
        
        if (consecutive > userPatterns.max_consecutive_days) {
          warnings.push(`Exceeds ${userPatterns.max_consecutive_days}-day limit (${consecutive} assigned)`);
        }
      }
      
      return warnings;
    }

    function getBankHolidayName(date) {
      if (!date) return null;
      const dateStr = date.toISOString().split('T')[0];
      const holiday = bankHolidaysByDate[dateStr];
      if (!holiday) return null;
      return holiday.holiday_name || "Bank Holiday";
    }

    // ========== INIT ==========
    async function bootRotaPage(){
      try {
        console.log("[ROTA BOOT] Starting boot sequence.");
        
        // Safe element getter with null check logging
        const getElement = (id) => {
          const el = document.getElementById(id);
          if (!el) console.warn(`[ROTA BOOT] Element not found: ${id}`);
          return el;
        };

        // Attach period change handler
        const periodSelect = getElement("periodSelect");
        if (periodSelect) periodSelect.addEventListener("change", (e) => {
          loadPeriod(e.target.value);
        });
        
        // Attach toggle requests handler
        const toggleRequestsBtn = getElement("toggleRequestsBtn");
        if (toggleRequestsBtn) toggleRequestsBtn.addEventListener("click", toggleRequests);
        
        // Attach publish/unpublish handlers
        const publishBtn = getElement("publishBtn");
        if (publishBtn) publishBtn.addEventListener("click", publishPeriod);
        const unpublishBtn = getElement("unpublishBtn");
        if (unpublishBtn) unpublishBtn.addEventListener("click", unpublishPeriod);

        // Published details modal handlers
        const publishedDetailsClose = getElement("publishedDetailsClose");
        if (publishedDetailsClose) publishedDetailsClose.addEventListener("click", closePublishedDetails);
        const publishedDetailsModal = getElement("publishedDetailsModal");
        if (publishedDetailsModal) publishedDetailsModal.addEventListener("click", (e) => {
          if (e.target.id === "publishedDetailsModal") closePublishedDetails();
        });
        const publishedChangeBtn = getElement("publishedChangeBtn");
        if (publishedChangeBtn) publishedChangeBtn.addEventListener("click", handlePublishedChange);
        const publishedOverrideBtn = getElement("publishedOverrideBtn");
        if (publishedOverrideBtn) publishedOverrideBtn.addEventListener("click", handlePublishedOverride);
        const publishedHistoryBtn = getElement("publishedHistoryBtn");
        if (publishedHistoryBtn) publishedHistoryBtn.addEventListener("click", handlePublishedHistory);
        const publishedCommentsBtn = getElement("publishedCommentsBtn");
        if (publishedCommentsBtn) publishedCommentsBtn.addEventListener("click", handlePublishedComments);
        const publishedSwapBtn = getElement("publishedSwapBtn");
        if (publishedSwapBtn) publishedSwapBtn.addEventListener("click", handlePublishedSwap);

        // Comments modal handlers
        const commentsModalClose = getElement("commentsModalClose");
        if (commentsModalClose) commentsModalClose.addEventListener("click", () => {
          const backdrop = getElement("commentsModalBackdrop");
          if (backdrop) backdrop.setAttribute("aria-hidden", "true");
        });
        const commentsModalBackdrop = getElement("commentsModalBackdrop");
        if (commentsModalBackdrop) commentsModalBackdrop.addEventListener("click", (e) => {
          if (e.target.id === "commentsModalBackdrop") {
            commentsModalBackdrop.setAttribute("aria-hidden", "true");
          }
        });

        // Override amendment modal handlers
        const amendmentSaveBtn = getElement("amendmentSaveBtn");
        if (amendmentSaveBtn) amendmentSaveBtn.addEventListener("click", saveOverrideAmendment);
        const amendmentCancelBtn = getElement("amendmentCancelBtn");
        if (amendmentCancelBtn) amendmentCancelBtn.addEventListener("click", closeOverrideAmendmentModal);
        const overrideAmendmentModalBackdrop = getElement("overrideAmendmentModalBackdrop");
        if (overrideAmendmentModalBackdrop) overrideAmendmentModalBackdrop.addEventListener("click", (e) => {
          if (e.target.id === "overrideAmendmentModalBackdrop") {
            closeOverrideAmendmentModal();
          }
        });
        attachAmendmentHourAutoCalc();

        // Shift swap modal handlers
        const swapCancelBtn = getElement("swapCancelBtn");
        if (swapCancelBtn) swapCancelBtn.addEventListener("click", () => {
          const modal = getElement("shiftSwapModal");
          if (modal) modal.setAttribute("aria-hidden", "true");
        });
        const shiftSwapModal = getElement("shiftSwapModal");
        if (shiftSwapModal) shiftSwapModal.addEventListener("click", (e) => {
          if (e.target.id === "shiftSwapModal") {
            e.target.setAttribute("aria-hidden", "true");
          }
        });
        const swapSubmitBtn = getElement("swapSubmitBtn");
        if (swapSubmitBtn) swapSubmitBtn.addEventListener("click", async () => {
          if (!window.swapInitiatorContext) return;

          const { userId: initiatorId, date: initiatorDate, isAdmin } = window.swapInitiatorContext;
          const peerId = document.getElementById("swapPeerSelect").value;
          const peerDate = document.getElementById("swapDateSelect").value;

          if (!peerId || !peerDate) {
            alert("Please select both staff member and their shift date.");
            return;
          }

          try {
            const btn = swapSubmitBtn;
            btn.disabled = true;

            if (isAdmin) {
              // Admin direct swap - call directly from window context
              if (typeof window.adminExecuteShiftSwap === "function") {
                console.log("[SWAP] Admin swap: initiator=", initiatorId, "peer=", peerId, "initiator_date=", initiatorDate, "peer_date=", peerDate);
                const result = await window.adminExecuteShiftSwap(peerId, peerDate);
                console.log("[SWAP] Admin swap result:", result);
                closePublishedDetails();
                alert("Swap executed successfully.");
              } else {
                alert("Admin swap function not ready.");
              }
            } else {
              // Staff propose swap
              if (typeof window.staffRequestShiftSwap === "function") {
                console.log("[SWAP] Staff swap request: initiator=", initiatorId, "peer=", peerId, "initiator_date=", initiatorDate, "peer_date=", peerDate);
                const result = await window.staffRequestShiftSwap(peerId, peerDate);
                console.log("[SWAP] Staff swap result:", result);
                alert("Swap request sent. Awaiting peer and admin approval.");
              } else {
                alert("Swap function not ready.");
              }
            }

            const modal = getElement("shiftSwapModal");
            if (modal) modal.setAttribute("aria-hidden", "true");
            window.swapInitiatorContext = null;
            
            // Reload rota to show updated shifts - fetch fresh data from database
            if (typeof loadPeriod === "function" && window.currentPeriod && window.currentPeriod.id) {
              console.log("[SWAP] Reloading period:", window.currentPeriod.id);
              await loadPeriod(window.currentPeriod.id);
              console.log("[SWAP] Period reload complete");
            }
          } catch (err) {
            console.error("[SWAP] Error:", err);
            alert(`Swap failed: ${err.message}`);
          } finally {
            swapSubmitBtn.disabled = false;
          }
        });

        const user = await checkAuth();
        console.log("[ROTA BOOT] checkAuth returned:", user);
        if (!user) {
          console.error("[ROTA BOOT] No user, returning");
          return;
        }

        // Signal other deferred modules (e.g., shift-functions.js) that auth is complete
        window.dispatchEvent(new Event("calpe:user-ready"));

        console.log("[ROTA BOOT] User authenticated, loading periods...");
        // Apply permission-based UI visibility and store globally
        // For now, default to true if PermissionsModule not available (will be replaced with real permission system)
        canViewAllRequests = window.PermissionsModule?.hasPermission("requests.view_all") ?? false;
        canViewOwnRequests = window.PermissionsModule?.hasPermission("requests.view_own") ?? false;
        canEditDraft = window.PermissionsModule?.hasPermission("rota.edit_draft") ?? false;
        canEditPublished = window.PermissionsModule?.hasPermission("rota.edit_published") ?? false;
        
        console.log("[ROTA] Permission check: canViewAllRequests=", canViewAllRequests, "canViewOwnRequests=", canViewOwnRequests);
        
        // Hide buttons if user lacks permissions
        const toggleRequestsBtnPerm = document.getElementById("toggleRequestsBtn");
        const toggleEditingBtn = document.getElementById("toggleEditingBtn");
        
        // Show requests button if user can view all OR view own
        if (!canViewAllRequests && !canViewOwnRequests && toggleRequestsBtnPerm) {
          console.log("[ROTA] Hiding Show Requests button - no request view permissions");
          toggleRequestsBtnPerm.style.display = "none";
        } else {
          console.log("[ROTA] Show Requests button visible");
        }

        // Initialize modular draft editing (shift-editor.js) after auth
        const bootEditing = () => {
          if (typeof window.initDraftEditing !== "function") {
            console.error("initDraftEditing not ready yet; retrying...");
            setTimeout(bootEditing, 50);
            return;
          }
          window.initDraftEditing({
            onUnlock: () => {
              const metadataDisplay = document.getElementById("metadataDisplay");
              if (currentEditContext === "draft") {
                if (metadataDisplay) metadataDisplay.style.display = "block";
              } else {
                if (metadataDisplay) metadataDisplay.style.display = "none";
              }
            },
            onLock: () => {
              const metadataDisplay = document.getElementById("metadataDisplay");
              if (metadataDisplay) metadataDisplay.style.display = "none";
            },
            onPublishedCellClick: ({ userId, date }) => {
              openPublishedDetails({ userId, date });
            },
            onSave: async (userId, date, shiftId, overrideData) => {
              console.log("[ROTA ONSAVE] Called with:", { userId, date, shiftId, overrideData });
              
              const key = `${userId}_${date}`;
              const newShift = draftShifts.find(s => s.id === shiftId);
              const userMeta = allUsers.find(u => u.id === userId);
              const isNonStaff = userMeta?.is_non_staff;
              const historyAssignee = isNonStaff
                ? { user_id: null, period_non_staff_id: userId }
                : { user_id: userId, period_non_staff_id: null };
              
              // Optimistic update: update local map immediately
              const existing = assignmentsMap.get(key);
              let oldShiftId = null;
              let oldShiftCode = null;
              if (existing) {
                oldShiftId = existing.shift_id;
                const oldShift = shiftMap.get(oldShiftId);
                oldShiftCode = oldShift?.code || 'UNKNOWN';
                existing.shift_id = shiftId;
              } else {
                assignmentsMap.set(key, {
                  user_id: isNonStaff ? null : userId,
                  period_non_staff_id: isNonStaff ? userId : null,
                  date,
                  shift_id: shiftId,
                  status: currentEditContext === "published" ? "published" : "draft"
                });
              }
              
              // Re-render immediately
              renderRota();

              try {
                const { data: assignmentId, error: saveErr } = await supabaseClient.rpc("admin_upsert_rota_assignment", {
                  p_token: window.currentToken,
                  p_user_id: isNonStaff ? null : userId,
                  p_period_non_staff_id: isNonStaff ? userId : null,
                  p_date: date,
                  p_shift_id: shiftId,
                  p_status: currentEditContext === "published" ? "published" : "draft"
                });

                if (saveErr) throw saveErr;
                const assignmentIdValue = Array.isArray(assignmentId) ? assignmentId[0] : assignmentId;
                if (assignmentIdValue) {
                  const existing = assignmentsMap.get(key);
                  if (existing) existing.id = assignmentIdValue;
                }

                if (currentEditContext === "published") {
                  if (!oldShiftId || oldShiftId !== shiftId) {
                    const { error: histErr } = await supabaseClient.rpc("admin_insert_rota_assignment_history", {
                      p_token: window.currentToken,
                      p_assignment_id: assignmentIdValue,
                      p_user_id: historyAssignee.user_id,
                      p_period_non_staff_id: historyAssignee.period_non_staff_id,
                      p_date: date,
                      p_old_shift_id: oldShiftId || null,
                      p_old_shift_code: oldShiftCode || null,
                      p_new_shift_id: shiftId,
                      p_new_shift_code: newShift?.code || 'UNKNOWN',
                      p_change_reason: oldShiftId ? 'Admin changed shift' : 'Admin added shift',
                      p_changed_by_name: window.currentUser?.name
                    });
                    if (histErr) {
                      console.error("[ROTA ONSAVE] Error recording history:", histErr);
                    }
                  }
                }

                const hasActualOverride = overrideData && (
                  overrideData.override_start_time || 
                  overrideData.override_end_time || 
                  overrideData.override_hours
                );

                if (hasActualOverride && assignmentIdValue) {
                  const { data: overrideRow, error: overrideErr } = await supabaseClient.rpc("admin_upsert_rota_assignment_override", {
                    p_token: window.currentToken,
                    p_assignment_id: assignmentIdValue,
                    p_override_start_time: overrideData.override_start_time,
                    p_override_end_time: overrideData.override_end_time,
                    p_override_hours: overrideData.override_hours,
                    p_comment: overrideData.comment,
                    p_comment_visibility: overrideData.comment_visibility || 'admin_only'
                  });
                  if (overrideErr) {
                    console.error("[ROTA ONSAVE] Error saving override:", overrideErr);
                  } else {
                    const row = Array.isArray(overrideRow) ? overrideRow[0] : overrideRow;
                    if (row) overridesMap.set(assignmentIdValue, row);
                    renderRota();
                  }
                } else if (assignmentIdValue) {
                  const { error: deleteErr } = await supabaseClient.rpc("admin_delete_rota_assignment_override", {
                    p_token: window.currentToken,
                    p_assignment_id: assignmentIdValue
                  });
                  if (deleteErr) {
                    console.error("[ROTA ONSAVE] Error deleting override:", deleteErr);
                  } else {
                    overridesMap.delete(assignmentIdValue);
                    renderRota();
                  }
                }
              } catch (err) {
                console.error("[ROTA ONSAVE] Error saving assignment:", err);
              }
            },onClear: async (userId, date) => {
              const key = `${userId}_${date}`;
              const userMeta = allUsers.find(u => u.id === userId);
              const isNonStaff = userMeta?.is_non_staff;
              const historyAssignee = isNonStaff
                ? { user_id: null, period_non_staff_id: userId }
                : { user_id: userId, period_non_staff_id: null };
              
              const existingAssignment = assignmentsMap.get(key);
              const oldShiftId = existingAssignment?.shift_id;
              const oldShift = oldShiftId ? shiftMap.get(oldShiftId) : null;
              const oldShiftCode = oldShift?.code;
              
              assignmentsMap.delete(key);
              renderRota();

              try {
                if (currentEditContext === "published" && oldShiftId && existingAssignment?.id) {
                  const { error: histErr } = await supabaseClient.rpc("admin_insert_rota_assignment_history", {
                    p_token: window.currentToken,
                    p_assignment_id: existingAssignment.id,
                    p_user_id: historyAssignee.user_id,
                    p_period_non_staff_id: historyAssignee.period_non_staff_id,
                    p_date: date,
                    p_old_shift_id: oldShiftId,
                    p_old_shift_code: oldShiftCode || 'UNKNOWN',
                    p_new_shift_id: null,
                    p_new_shift_code: null,
                    p_change_reason: 'Admin cleared shift',
                    p_changed_by_name: window.currentUser?.name
                  });
                  if (histErr) {
                    console.error("[ROTA ONCLEAR] Error recording history:", histErr);
                  }
                }

                const { error: deleteErr } = await supabaseClient.rpc("admin_delete_rota_assignment", {
                  p_token: window.currentToken,
                  p_user_id: isNonStaff ? null : userId,
                  p_period_non_staff_id: isNonStaff ? userId : null,
                  p_date: date
                });
                if (deleteErr) throw deleteErr;
              } catch (err) {
                console.error("[ROTA ONCLEAR] Error clearing assignment:", err);
              }
            },
            getCurrentUser: () => window.currentUser,
            getCurrentPeriod: () => currentPeriod,
            getAllUsers: () => allUsers,
            getDraftShifts: () => shifts, // Return main shifts array
            getAssignment: (userId, date) => assignmentsMap.get(`${userId}_${date}`),
            getOverride: (assignmentId) => overridesMap.get(assignmentId),
            refreshGrid: () => {
              renderRota();
            },
          });
        };

        bootEditing();
        
        console.log("[ROTA BOOT] Loading bank holidays...");
        await loadBankHolidays();
        
        console.log("[ROTA BOOT] Calling loadPeriods...");
        try {
          const loadPeriodsPromise = loadPeriods();
          await Promise.race([
            loadPeriodsPromise,
            new Promise((_, reject) => setTimeout(() => reject(new Error("loadPeriods timeout after 10s")), 10000))
          ]);
          console.log("[ROTA BOOT] loadPeriods completed");
        } catch (err) {
          console.error("[ROTA BOOT] loadPeriods failed:", err);
          throw err;
        }
        
        // Auto-select and load the first available period
        console.log("[ROTA BOOT] Auto-selecting first period...");
        // periodSelect was already retrieved at line 1127 with getElement()
        if (periodSelect && periodSelect.options && periodSelect.options.length > 0) {
          const firstPeriodId = periodSelect.options[0].value;
          periodSelect.value = firstPeriodId;
          console.log("[ROTA BOOT] Auto-loading period:", firstPeriodId);
          try {
            if (typeof loadPeriod === "function") {
              await loadPeriod(firstPeriodId);
              console.log("[ROTA BOOT] Period loaded successfully");
            } else {
              console.warn("[ROTA BOOT] loadPeriod function not available");
            }
          } catch (err) {
            console.error("[ROTA BOOT] Failed to load first period:", err);
            throw err;
          }
        } else {
          console.warn("[ROTA BOOT] No periods available in dropdown");
        }
        
        // Initialize notices/notifications (from app.js)
        console.log("[ROTA BOOT] Loading notices bell...");
        try {
          await loadNoticesBell();
          console.log("[ROTA BOOT] Notices bell loaded");
        } catch (err) {
          console.error("[ROTA BOOT] Failed to load notices bell:", err);
          // Don't throw - notices are not critical to showing the rota
        }
        console.log("[ROTA BOOT] Boot complete!");
      } catch (err) {
        console.error("Rota boot failed:", err);
        alert("Failed to load rota: " + err.message);
      }
    }

    console.log("[ROTA BOOT] installing boot hooks, readyState=", document.readyState);

    // Kick off boot when ready. If DOMContentLoaded already fired, start immediately.
    async function startBoot() {
      console.log("[ROTA BOOT] startBoot invoked");
      // Session is already validated by session-validator.js (runs before this)
      // Token is stored in sessionStorage via login.html
      await bootRotaPage();
    }

    if (document.readyState === "loading") {
      window.addEventListener("DOMContentLoaded", () => {
        console.log("[ROTA BOOT] DOMContentLoaded - initializing session and boot");
        startBoot();
      }, { once: true });
    } else {
      console.log("[ROTA BOOT] DOMContentLoaded already fired - starting boot now");
      startBoot();
    }

    // ========== NOTICES/NOTIFICATIONS BELL ==========
    const noticeBell = document.getElementById("noticeBell");
    const noticeBellDot = document.getElementById("noticeBellDot");
    const noticeAllModal = document.getElementById("noticeAllModal");
    const noticeAllClose = document.getElementById("noticeAllClose");
    const noticeAllList = document.getElementById("noticeAllList");

    let noticesCache = [];
    let notificationsCache = [];
    let unreadCount = 0;
    let notificationsUnreadCount = 0;

    function escapeHtml(str){
      return String(str || "")
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll("\"","&quot;")
        .replaceAll("'","&#039;");
    }

    function getNoticeBody(n){
      return n.body_en || "";
    }

    function isNoticeAcked(n){
      if (!n.acknowledged_at) return false;
      if (
        n.ack_version != null &&
        Number(n.ack_version) !== Number(n.version)
      ) {
        return false;
      }
      return true;
    }

    async function fetchNoticesForMe(){
      if (!window.currentUser) return [];

      const { data, error } = await supabaseClient.rpc(
        "get_notices_for_user",
        {
          p_token: window.currentToken
        }
      );
      if (error) throw error;

      const map = new Map();
      for (const row of (data || [])){
        const key = String(row.id);
        const prev = map.get(key);
        if (!prev) {
          map.set(key, row);
          continue;
        }

        const prevT = prev.updated_at ? new Date(prev.updated_at).getTime() : 0;
        const rowT  = row.updated_at  ? new Date(row.updated_at).getTime()  : 0;

        if (rowT > prevT) map.set(key, row);
      }

      return [...map.values()].sort((a,b) => new Date(b.updated_at) - new Date(a.updated_at));
    }

    async function fetchNotificationsForMe(){
      if (!window.currentUser) return [];

      const roleId = Number(window.currentUser.role_id);
      const isAdmin = !!window.currentUser.is_admin;
      
      const { data, error } = await supabaseClient
        .rpc("rpc_get_notifications", { p_token: window.currentToken });

      if (error) throw error;

      // Client-side filtering to ensure notifications are properly targeted
      const filtered = (data || []).filter(item => {
        // Only show pending notifications
        if ((item.status || 'pending') !== 'pending') return false;
        
        // all/all_staff scope matches everyone
        if (item.target_scope === 'all' || item.target_scope === 'all_staff') return true;
        
        // user scope must match current user ID
        if (item.target_scope === 'user') {
          return item.target_user_id === window.currentUser.id;
        }
        
        // role scope must include current user's role
        if (item.target_scope === 'role') {
          const roleId = Number(window.currentUser.role_id);
          const targetRoles = item.target_role_ids || [];
          return targetRoles.includes(roleId);
        }
        
        return false;
      });

      return filtered;
    }

    function computeNoticeState(list){
      noticesCache = Array.isArray(list) ? list : [];
      unreadCount = 0;

      for (const n of noticesCache){
        if (n.is_active === false) continue;

        const acked = isNoticeAcked(n);

        if (!acked){
          unreadCount++;
        }
      }
    }

    function computeNotificationState(list){
      notificationsCache = Array.isArray(list) ? list : [];
      notificationsUnreadCount = (notificationsCache || []).filter(n => (n.status || "pending") === "pending").length;
    }

    function updateNoticeBell(){
      if (!noticeBell || !noticeBellDot) return;

      if (!window.currentUser){
        noticeBell.style.display = "none";
        noticeBellDot.style.display = "none";
        return;
      }

      noticeBell.style.display = "inline-flex";
      const hasUnread = (unreadCount + notificationsUnreadCount) > 0;
      noticeBellDot.style.display = hasUnread ? "inline" : "none";
    }

    function renderAllNoticesList(){
      if (!noticeAllList) return;

      // Separate notices and notifications
      const notices = [];
      const notifications = [];

      // Build notices array
      (noticesCache || []).forEach(n => {
        const bodyText = getNoticeBody(n);
        notices.push({
          _type: "notice",
          id: String(n.id),
          title: n.title || "Notice",
          body: bodyText || '',
          when: n.updated_at ? new Date(n.updated_at).toLocaleString("en-GB") : "",
          who: n.created_by_name || "Unknown",
          acked: isNoticeAcked(n),
          data: n
        });
      });

      // Build notifications array using shared formatting functions
      (notificationsCache || []).forEach(n => {
        notifications.push({
          _type: "notification",
          id: String(n.id),
          title: getNotificationTitle(n),
          body: getNotificationBody(n),
          when: n.updated_at ? new Date(n.updated_at).toLocaleString("en-GB") : "",
          status: n.status || "pending",
          requiresAction: !!n.requires_action,
          data: n
        });
      });

      // Sort by updated_at (newest first)
      const allItems = [...notices, ...notifications];
      allItems.sort((a,b) => {
        const aTime = a.data.updated_at ? new Date(a.data.updated_at).getTime() : 0;
        const bTime = b.data.updated_at ? new Date(b.data.updated_at).getTime() : 0;
        return bTime - aTime;
      });

      // Render using shared function
      if (allItems.length === 0) {
        noticeAllList.innerHTML = `<div class="subtitle">No notices or notifications</div>`;
        return;
      }

      // Separate again for grouped display
      const noticesForDisplay = allItems.filter(i => i._type === "notice");
      const notificationsForDisplay = allItems.filter(i => i._type === "notification");

      noticeAllList.innerHTML = renderAllNoticesAndNotifications(noticesForDisplay, notificationsForDisplay);
    }

    async function refreshNotices(){
      const list = await fetchNoticesForMe();
      computeNoticeState(list);
      updateNoticeBell();
    }

    async function refreshNotifications(){
      const list = await fetchNotificationsForMe();
      computeNotificationState(list);
      updateNoticeBell();
    }

    async function refreshNoticesAndNotifications(){
      await Promise.all([refreshNotices(), refreshNotifications()]);
    }

    async function ackOneNotice(noticeId, noticeVersion){
      if (!window.currentUser) return;

      const { error } = await supabaseClient.rpc("ack_notice", {
        p_notice_id: noticeId,
        p_version: noticeVersion,
        p_user_id: window.currentUser.id
      });

      if (error) throw error;

      await refreshNotices();
    }

    async function updateNotificationStatus(notifId, status){
      if (!window.currentUser) throw new Error("Not logged in.");
      const { error } = await supabaseClient
        .rpc("rpc_update_notification_status", {
          p_token: window.currentToken,
          p_notification_id: notifId,
          p_status: status
        });

      if (error) throw error;
    }

    async function loadNoticesBell(){
      try {
        // Race against 5 second timeout - notices are non-critical
        await Promise.race([
          refreshNoticesAndNotifications(),
          new Promise((_, reject) => setTimeout(() => reject(new Error("Notices timeout")), 5000))
        ]);
      } catch (e) {
        console.warn("Failed to load notices/notifications:", e);
      }
    }

    function openAllNoticesModal(){
      if (!noticeAllModal) return;

      renderAllNoticesList();

      document.body.classList.add("modal-open");
      noticeAllModal.style.display = "flex";
      noticeAllModal.setAttribute("aria-hidden","false");
    }

    function closeAllNoticesModal(){
      if (!noticeAllModal) return;

      noticeAllModal.style.display = "none";
      noticeAllModal.setAttribute("aria-hidden","true");
      document.body.classList.remove("modal-open");
    }

    noticeBell?.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (!window.currentUser) return;
      openAllNoticesModal();
    });

    noticeAllClose?.addEventListener("click", closeAllNoticesModal);
    noticeAllModal?.addEventListener("click", (e) => {
      if (e.target === noticeAllModal) closeAllNoticesModal();
    });

    noticeAllList?.addEventListener("click", async (e) => {
      const ackBtn = e.target.closest("button[data-ack]");
      if (ackBtn) {
        const id = String(ackBtn.dataset.ack);

        const n = (noticesCache || []).find(x => String(x.id) === id);
        if (!n) {
          alert("Notice not found in cache. Reload and try again.");
          return;
        }

        try {
          ackBtn.disabled = true;

          await ackOneNotice(n.id, n.version);

          await refreshNoticesAndNotifications();
          renderAllNoticesList();
        } catch (err) {
          console.error(err);
          alert("Failed to acknowledge notice.");
        } finally {
          ackBtn.disabled = false;
        }
        return;
      }

      const acceptBtn = e.target.closest("button[data-notif-accept]");
      if (acceptBtn) {
        const id = String(acceptBtn.dataset.notifAccept);
        try {
          acceptBtn.disabled = true;
          
          // Check if this is a swap request notification
          const notification = notificationsCache.find(n => String(n.id) === id);
          console.log("[DEBUG] Accept clicked - notification:", notification);
          
          if (notification && notification.type === "swap_request") {
            let payload = notification.payload;
            if (typeof payload === 'string') {
              payload = JSON.parse(payload);
            }
            
            // Check if this is an admin approval notification (swap_accepted)
            if (payload?.notification_type === "swap_accepted" && window.currentUser?.is_admin) {
              console.log("[DEBUG] Admin approving swap request with:", {
                admin_id: window.currentUser.id,
                swap_request_id: payload?.swap_request_id
              });
              
              // Call admin_approve_swap_request for admin approval
              const { data, error } = await supabaseClient.rpc(
                "admin_approve_swap_request",
                {
                  p_token: window.currentToken,
                  p_swap_request_id: payload?.swap_request_id
                }
              );
              console.log("[DEBUG] Admin approve RPC response:", { data, error });
              if (error) throw error;
              if (data && data.length > 0 && !data[0].success) {
                throw new Error(data[0].error_message || "Unknown error");
              }
              console.log("[DEBUG] Swap request approved successfully!");
              alert("Swap approved!");
            } else {
              // Staff responding to swap request (not an admin)
              console.log("[DEBUG] Calling staff_respond_to_swap_request with:", {
                user_id: window.currentUser.id,
                swap_request_id: payload?.swap_request_id,
                response: "accepted"
              });
              
              // Call staff_respond_to_swap_request for swap acceptance
              const { data, error } = await supabaseClient.rpc(
                "staff_respond_to_swap_request",
                {
                  p_token: window.currentToken,
                  p_swap_request_id: payload?.swap_request_id,
                  p_response: "accepted"
                }
              );
              console.log("[DEBUG] RPC response:", { data, error });
              if (error) throw error;
              if (data && data.length > 0 && !data[0].success) {
                throw new Error(data[0].error_message || "Unknown error");
              }
              console.log("[DEBUG] Swap request accepted successfully!");
              alert("Swap request accepted!");
            }
          } else {
            // Standard notification acceptance
            await updateNotificationStatus(id, "accepted");
          }
          
          console.log("[DEBUG] Refreshing notices and notifications...");
          await refreshNoticesAndNotifications();
          console.log("[DEBUG] Rendering notices list...");
          renderAllNoticesList();
          console.log("[DEBUG] Done refreshing");
        } catch (err) {
          console.error(err);
          alert("Failed to accept notification.");
        } finally {
          acceptBtn.disabled = false;
        }
        return;
      }

      const declineBtn = e.target.closest("button[data-notif-decline]");
      if (declineBtn) {
        const id = String(declineBtn.dataset.notifDecline);
        try {
          declineBtn.disabled = true;
          
          // Check if this is a swap request notification
          const notification = notificationsCache.find(n => String(n.id) === id);
          console.log("[DEBUG] Decline clicked - notification:", notification);
          
          if (notification && notification.type === "swap_request") {
            let payload = notification.payload;
            if (typeof payload === 'string') {
              payload = JSON.parse(payload);
            }
            
            // Check if this is an admin approval notification (swap_accepted)
            if (payload?.notification_type === "swap_accepted" && window.currentUser?.is_admin) {
              console.log("[DEBUG] Admin declining swap request with:", {
                admin_id: window.currentUser.id,
                swap_request_id: payload?.swap_request_id
              });
              
              // Call admin_decline_swap_request for admin decline
              const { data, error } = await supabaseClient.rpc(
                "admin_decline_swap_request",
                {
                  p_token: window.currentToken,
                  p_swap_request_id: payload?.swap_request_id
                }
              );
              console.log("[DEBUG] Admin decline RPC response:", { data, error });
              if (error) throw error;
              if (data && data.length > 0 && !data[0].success) {
                throw new Error(data[0].error_message || "Unknown error");
              }
              console.log("[DEBUG] Swap request declined successfully!");
              alert("Swap declined!");
            } else {
              // Staff responding to swap request (not an admin)
              console.log("[DEBUG] Calling staff_respond_to_swap_request with:", {
                user_id: window.currentUser.id,
                swap_request_id: payload?.swap_request_id,
                response: "declined"
              });
              
              // Call staff_respond_to_swap_request for swap decline
              const { data, error } = await supabaseClient.rpc(
                "staff_respond_to_swap_request",
                {
                  p_token: window.currentToken,
                  p_swap_request_id: payload?.swap_request_id,
                  p_response: "declined"
                }
              );
              console.log("[DEBUG] RPC response:", { data, error });
              if (error) throw error;
              if (data && data.length > 0 && !data[0].success) {
                throw new Error(data[0].error_message || "Unknown error");
              }
              alert("Swap request declined!");
            }
          } else {
            // Standard notification decline
            await updateNotificationStatus(id, "declined");
          }
          
          await refreshNoticesAndNotifications();
          renderAllNoticesList();
        } catch (err) {
          console.error(err);
          alert("Failed to decline notification.");
        } finally {
          declineBtn.disabled = false;
        }
        return;
      }

      const ignoreBtn = e.target.closest("button[data-notif-ignore]");
      if (ignoreBtn) {
        const id = String(ignoreBtn.dataset.notifIgnore);
        try {
          ignoreBtn.disabled = true;
          await updateNotificationStatus(id, "ignored");
          await refreshNotifications();
          renderAllNoticesList();
        } catch (err) {
          console.error(err);
          alert("Failed to ignore notification.");
        } finally {
          ignoreBtn.disabled = false;
        }
        return;
      }

      const ackNotifBtn = e.target.closest("button[data-notif-ack]");
      if (ackNotifBtn) {
        const id = String(ackNotifBtn.dataset.notifAck);
        try {
          ackNotifBtn.disabled = true;
          await updateNotificationStatus(id, "ack");
          await refreshNotifications();
          renderAllNoticesList();
        } catch (err) {
          console.error(err);
          alert("Failed to acknowledge notification.");
        } finally {
          ackNotifBtn.disabled = false;
        }
        return;
      }

      // Admin approve swap (from swap_pending notification)
      const adminApproveBtn = e.target.closest("button[data-admin-approve-swap]");
      if (adminApproveBtn) {
        const notifId = String(adminApproveBtn.dataset.adminApproveSwap);
        try {
          adminApproveBtn.disabled = true;
          
          // Find the notification to get swap_request_id
          const notification = notificationsCache.find(n => String(n.id) === notifId);
          if (!notification || !notification.payload?.swap_request_id) {
            throw new Error("Swap request ID not found in notification");
          }
          
          const swapRequestId = notification.payload.swap_request_id;
          
          // Call admin approval RPC
          const { data, error } = await window.supabaseClient.rpc("admin_approve_swap_request", {
            p_token: window.currentToken,
            p_swap_request_id: swapRequestId
          });
          
          if (error) throw error;
          if (data && data.length > 0 && !data[0].success) {
            throw new Error(data[0].error_message || "Failed to approve swap");
          }
          
          alert("Swap approved successfully!");
          await refreshNotifications();
          renderAllNoticesList();
        } catch (err) {
          console.error(err);
          alert("Failed to approve swap: " + err.message);
        } finally {
          adminApproveBtn.disabled = false;
        }
        return;
      }

      // Admin decline swap (from swap_pending notification)
      const adminDeclineBtn = e.target.closest("button[data-admin-decline-swap]");
      if (adminDeclineBtn) {
        const notifId = String(adminDeclineBtn.dataset.adminDeclineSwap);
        try {
          adminDeclineBtn.disabled = true;
          
          // Find the notification to get swap_request_id
          const notification = notificationsCache.find(n => String(n.id) === notifId);
          if (!notification || !notification.payload?.swap_request_id) {
            throw new Error("Swap request ID not found in notification");
          }
          
          const swapRequestId = notification.payload.swap_request_id;
          
          // Call admin decline RPC
          const { data, error } = await window.supabaseClient.rpc("admin_decline_swap_request", {
            p_token: window.currentToken,
            p_swap_request_id: swapRequestId
          });
          
          if (error) throw error;
          if (data && data.length > 0 && !data[0].success) {
            throw new Error(data[0].error_message || "Failed to decline swap");
          }
          
          alert("Swap declined successfully!");
          await refreshNotifications();
          renderAllNoticesList();
        } catch (err) {
          console.error(err);
          alert("Failed to decline swap: " + err.message);
        } finally {
          adminDeclineBtn.disabled = false;
        }
        return;
      }
    });

    // Add hover effects to publish/unpublish buttons
    const publishBtn = document.getElementById("publishBtn");
    const unpublishBtn = document.getElementById("unpublishBtn");
    
    if (publishBtn) {
      publishBtn.addEventListener("mouseenter", function() {
        this.style.background = "#047857";
        this.style.boxShadow = "0 4px 8px rgba(0,0,0,0.15)";
        this.style.transform = "translateY(-2px)";
      });
      publishBtn.addEventListener("mouseleave", function() {
        this.style.background = "#059669";
        this.style.boxShadow = "0 2px 4px rgba(0,0,0,0.1)";
        this.style.transform = "translateY(0)";
      });
    }
    
    if (unpublishBtn) {
      unpublishBtn.addEventListener("mouseenter", function() {
        this.style.background = "#b91c1c";
        this.style.boxShadow = "0 4px 8px rgba(0,0,0,0.15)";
        this.style.transform = "translateY(-2px)";
      });
      unpublishBtn.addEventListener("mouseleave", function() {
        this.style.background = "#dc2626";
        this.style.boxShadow = "0 2px 4px rgba(0,0,0,0.1)";
        this.style.transform = "translateY(0)";
      });
    }

    // ========== PRINT ROTA FUNCTIONALITY ==========
    const rotaPrintBtn = document.getElementById("rotaPrintBtn");
    const rotaPrintModal = document.getElementById("rotaPrintModal");
    const rotaPrintClose = document.getElementById("rotaPrintClose");
    const rotaPrintCloseX = document.getElementById("rotaPrintCloseX");
    const rotaPrintAdminOptions = document.getElementById("rotaPrintAdminOptions");
    
    function openRotaPrintModal() {
      if (!window.currentUser) { alert("Please log in first."); return; }
      rotaPrintAdminOptions.style.display = window.currentUser.is_admin ? "block" : "none";
      rotaPrintModal.setAttribute("aria-hidden", "false");
      rotaPrintModal.style.display = "flex";
    }
    
    function closeRotaPrintModal() {
      rotaPrintModal.setAttribute("aria-hidden", "true");
      rotaPrintModal.style.display = "none";
    }

    function cloneRotaForPrint() {
      const rota = document.getElementById("rota");
      return rota ? rota.cloneNode(true) : null;
    }

    function openFittedRotaPrintWindow({ title, subtitle, rotaClone }) {
      if (!rotaClone) {
        alert("Nothing to print.");
        return;
      }

      const win = window.open("", "_blank");
      if (!win) {
        alert("Pop-up blocked. Please allow pop-ups for printing.");
        return;
      }

      const doc = win.document;
      doc.open();
      doc.write('<!doctype html><html lang="en"><head><meta charset="utf-8"><title>Print</title></head><body></body></html>');
      doc.close();

      const style = doc.createElement('style');
      style.textContent = `
:root { --print-scale: 1; }
@page { size: A4 landscape; margin: 4mm; }
html, body { margin: 0; padding: 0; background: #fff; color: #222; }
body { font-family: 'Segoe UI', Roboto, system-ui, -apple-system, sans-serif; }
#mmProbe { width: 100mm; height: 0; position: absolute; left: -9999px; top: -9999px; visibility: hidden; }
#printArea { transform: scale(var(--print-scale)); transform-origin: top left; width: calc(100% / var(--print-scale)); }
.print-header { padding: 0 0 3mm 0; margin: 0 0 3mm 0; border-bottom: 2pt solid #333; page-break-after: avoid; }
.print-header h1 { margin: 0 0 1.5mm 0; font-size: 14pt; font-weight: 800; line-height: 1; color: #111; }
.print-header .print-meta { font-size: 8pt; color: #666; line-height: 1.3; }
table { border-collapse: collapse; width: 100%; }
#rota { table-layout: auto; }
#rota th { background: #e0e0e0; border: 1pt solid #888; padding: 3px 2px; font-size: 7pt; font-weight: 700; color: #000; }
#rota td { border: 1pt solid #ccc; padding: 3px 2px; font-size: 6.8pt; text-align: center; line-height: 1.4; }
#rota tbody th { background: #f5f5f5; font-weight: 600; text-align: left; padding: 3px 4px; font-size: 7pt; border: 1pt solid #888; }
#rota thead { display: table-row-group; }
#rota tbody tr { page-break-inside: avoid; }
.weekend { background: #fafafa; }
.closed { background: #f0f0f0; }
tr { page-break-inside: avoid; }
* { -webkit-print-color-adjust: exact; print-color-adjust: exact; }
`;
      doc.head.appendChild(style);

      const period = window.currentPeriod?.name || "";
      const printedAt = new Date().toLocaleDateString("en-GB") + " " + new Date().toLocaleTimeString("en-GB", { hour: "2-digit", minute: "2-digit" });
      
      const printHeader = doc.createElement('div');
      printHeader.className = 'print-header';
      const h1 = doc.createElement('h1');
      h1.textContent = "Calpe Ward Rota - " + title;
      const meta = doc.createElement('div');
      meta.className = 'print-meta';
      meta.textContent = subtitle + "\nPeriod: " + period + " | Printed: " + printedAt;
      printHeader.appendChild(h1);
      printHeader.appendChild(meta);

      const mmProbe = doc.createElement('div');
      mmProbe.id = 'mmProbe';

      const printArea = doc.createElement('div');
      printArea.id = 'printArea';
      printArea.appendChild(printHeader);
      printArea.appendChild(rotaClone);

      doc.body.appendChild(mmProbe);
      doc.body.appendChild(printArea);

      const script = doc.createElement('script');
      script.textContent = `(function(){
function mmToPx(mm){var probe=document.getElementById('mmProbe');return(probe.getBoundingClientRect().width/100)*mm;}
function fit(){var p=document.getElementById('printArea');document.documentElement.style.setProperty('--print-scale','1');var r=p.getBoundingClientRect();var s=Math.min(mmToPx(293)/r.width,mmToPx(206)/r.height);document.documentElement.style.setProperty('--print-scale',(Math.max(0.1,Math.min(1,s*0.995))).toFixed(4));}
window.addEventListener('load',function(){requestAnimationFrame(function(){requestAnimationFrame(function(){fit();setTimeout(function(){window.focus();window.print();setTimeout(function(){window.close();},250);},50);});});});
})();`;
      doc.body.appendChild(script);
    }

    // Admin print configuration modal
    function openRotaAdminPrintConfig() {
      if (!window.currentUser?.is_admin) { alert("Admin access required"); return; }
      closeRotaPrintModal();
      
      const modal = document.createElement("div");
      modal.style.cssText = "position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(15,23,42,0.28);backdrop-filter:blur(3px);display:flex;align-items:center;justify-content:center;z-index:10001;overflow-y:auto;padding:14px";
      
      const dialog = document.createElement("div");
      dialog.style.cssText = "background:linear-gradient(180deg,#ffffff 0%,#f6f8fc 100%);padding:18px;border-radius:22px;max-width:620px;width:min(620px,100%);box-shadow:0 28px 80px rgba(15,23,42,0.14);border:1px solid rgba(15,23,42,0.05);margin:20px auto;font-family:'Manrope',ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;color:#0f172a";
      
      let html = `
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:18px;">
          <h2 style="margin:0;font-size:17px;font-weight:700;letter-spacing:0.1px;">Admin Print Configuration</h2>
          <button type="button" onclick="this.closest('[data-modal]').remove()" style="width:32px;height:32px;border-radius:10px;border:1px solid #e5eaf3;background:#ffffff;cursor:pointer;color:#94a3b8;box-shadow:0 3px 8px rgba(15,23,42,0.05);font-size:18px;line-height:1;">√ó</button>
        </div>
        
        <!-- STATUS SECTION -->
        <div style="margin-bottom:18px;padding:14px;background:#f5f7fb;border-radius:14px;border:1px solid #e7ebf3">
          <label style="display:block;font-weight:600;margin-bottom:10px;font-size:12.5px;color:#6b7387">Rota Status:</label>
          <label style="display:flex;align-items:center;gap:8px;cursor:pointer;margin-bottom:12px">
            <input type="radio" name="adminRotaStatus" value="both" checked style="width:16px;height:16px;cursor:pointer"> All shifts (published & draft)
          </label>
          <label style="display:flex;align-items:center;gap:8px;cursor:pointer;margin-bottom:12px">
            <input type="radio" name="adminRotaStatus" value="published" style="width:16px;height:16px;cursor:pointer"> Published shifts only
          </label>
          <label style="display:flex;align-items:center;gap:8px;cursor:pointer">
            <input type="radio" name="adminRotaStatus" value="draft" style="width:16px;height:16px;cursor:pointer"> Draft shifts only
          </label>
        </div>
        
        <!-- ROLES SECTION -->
        <div style="margin-bottom:18px">
          <label style="display:block;font-weight:600;margin-bottom:10px;font-size:12.5px;color:#6b7387">Select Roles:</label>
          <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:10px">
            <label style="display:flex;align-items:center;gap:8px;cursor:pointer">
              <input type="checkbox" class="admin-rota-role-check" value="1" checked style="width:18px;height:18px;cursor:pointer"> Charge Nurses
            </label>
            <label style="display:flex;align-items:center;gap:8px;cursor:pointer">
              <input type="checkbox" class="admin-rota-role-check" value="2" checked style="width:18px;height:18px;cursor:pointer"> Staff Nurses
            </label>
            <label style="display:flex;align-items:center;gap:8px;cursor:pointer">
              <input type="checkbox" class="admin-rota-role-check" value="3" checked style="width:18px;height:18px;cursor:pointer"> Nursing Assistants
            </label>
          </div>
        </div>
        
        <!-- USERS SECTION -->
        <div style="margin-bottom:18px">
          <label style="display:block;font-weight:600;margin-bottom:10px;font-size:12.5px;color:#6b7387">Select Staff (or leave empty for all):</label>
          <input type="text" id="rotaUserSearchInput" placeholder="Search staff..." style="width:100%;padding:8px 12px;margin-bottom:12px;border:1px solid #e5eaf3;border-radius:10px;font-size:12.5px;background:#ffffff;box-shadow:inset 0 1px 2px rgba(15,23,42,0.06)">
          <div id="rotaUserList" style="max-height:200px;overflow-y:auto;border:1px solid #e7ebf3;border-radius:12px;padding:8px;background:#ffffff;box-shadow:inset 0 1px 2px rgba(15,23,42,0.06)">`;
      
      allUsers.forEach(u => {
        const roleName = u.role_id === 1 ? "CN" : u.role_id === 2 ? "SN" : u.role_id === 3 ? "NA" : "";
        html += `<label style="display:flex;align-items:center;gap:8px;cursor:pointer;padding:6px;margin:0">
          <input type="checkbox" class="admin-rota-user-check" value="${u.id}" style="width:16px;height:16px;cursor:pointer"> ${u.name}${roleName ? " (" + roleName + ")" : ""}
        </label>`;
      });
      
      html += `</div>
        </div>
        
        <!-- BUTTONS -->
        <div style="display:flex;gap:12px;justify-content:flex-end">
          <button type="button" onclick="this.closest('[data-modal]').remove()" style="height:32px;padding:0 14px;border:1px solid #e5eaf3;background:#ffffff;border-radius:12px;cursor:pointer;font-weight:600;font-size:12.5px;box-shadow:0 3px 8px rgba(15,23,42,0.05)">Cancel</button>
          <button type="button" id="adminRotaPrintExecBtn" style="height:32px;padding:0 16px;background:linear-gradient(180deg,#6f8bff 0%,#5472f2 100%);color:white;border:1px solid rgba(84,114,242,0.5);border-radius:12px;cursor:pointer;font-weight:600;font-size:12.5px;box-shadow:0 6px 14px rgba(66,95,210,0.25)">Print</button>
        </div>
      `;
      
      dialog.innerHTML = html;
      dialog.setAttribute("data-modal", "true");
      modal.appendChild(dialog);
      document.body.appendChild(modal);
      
      // User search functionality
      const rotaUserSearchInput = document.getElementById("rotaUserSearchInput");
      const rotaUserCheckboxes = document.querySelectorAll(".admin-rota-user-check");
      rotaUserSearchInput.addEventListener("input", (e) => {
        const query = e.target.value.toLowerCase();
        rotaUserCheckboxes.forEach(checkbox => {
          const label = checkbox.closest("label");
          const userName = label.textContent.toLowerCase();
          label.style.display = userName.includes(query) ? "flex" : "none";
        });
      });
      
      // Print execution
      document.getElementById("adminRotaPrintExecBtn").addEventListener("click", () => {
        const selectedRoles = Array.from(document.querySelectorAll(".admin-rota-role-check:checked")).map(el => parseInt(el.value));
        const selectedUsers = Array.from(document.querySelectorAll(".admin-rota-user-check:checked")).map(el => el.value);
        const statusValue = document.querySelector("input[name='adminRotaStatus']:checked").value;
        
        modal.remove();
        executeAdminRotaPrint(selectedRoles, selectedUsers, statusValue);
      });
      
      modal.addEventListener("click", (e) => {
        if (e.target === modal) modal.remove();
      });
    }

    function executeAdminRotaPrint(selectedRoles, selectedUsers, statusValue) {
      console.log("[ROTA PRINT] Roles:", selectedRoles, "Users:", selectedUsers, "Status:", statusValue);
      
      // Build list of users to keep visible
      let filteredUsers = allUsers;
      if (selectedRoles.length > 0) {
        filteredUsers = allUsers.filter(u => selectedRoles.includes(u.role_id));
      }
      if (selectedUsers.length > 0) {
        filteredUsers = filteredUsers.filter(u => selectedUsers.includes(String(u.id)));
      }
      
      if (filteredUsers.length === 0) {
        alert("No staff selected.");
        return;
      }
      
      // Filter the rota table to show only selected users and status
      const restore = (() => {
        const original = new Map();
        const selectedUserIds = new Set(filteredUsers.map(u => String(u.id)));
        
        document.querySelectorAll("#rota tbody tr").forEach(row => {
          original.set(row, row.style.display);
          const userIdStr = row.dataset.userId;
          if (userIdStr && !selectedUserIds.has(userIdStr)) {
            row.style.display = "none";
          }
        });
        
        // Filter cells by status
        if (statusValue !== "both") {
          document.querySelectorAll("#rota tbody td.cell").forEach(cell => {
            const cellStatus = cell.dataset.status;
            if (statusValue === "published" && cellStatus !== "published") {
              const prev = cell.textContent;
              original.set(cell, { display: cell.style.display, text: prev });
              cell.textContent = "";
            } else if (statusValue === "draft" && cellStatus === "published") {
              const prev = cell.textContent;
              original.set(cell, { display: cell.style.display, text: prev });
              cell.textContent = "";
            }
          });
        }
        
        return () => {
          original.forEach((val, el) => {
            if (el.tagName === "TR") {
              el.style.display = val;
            } else if (el.tagName === "TD" && val.text !== undefined) {
              el.textContent = val.text;
            }
          });
        };
      })();
      
      // Clone the filtered rota
      const rotaClone = cloneRotaForPrint();
      restore();
      
      // Build title based on selections
      let title = "Rota Schedule";
      let subtitle = "";
      
      if (statusValue === "published") subtitle = "Published shifts only";
      else if (statusValue === "draft") subtitle = "Draft shifts only";
      else subtitle = "All shifts (published & draft)";
      
      if (selectedRoles.length > 0 && selectedUsers.length === 0) {
        const roleNames = selectedRoles.map(rid => {
          if (rid === 1) return "Charge Nurses";
          if (rid === 2) return "Staff Nurses";
          if (rid === 3) return "Nursing Assistants";
          return "";
        }).join(", ");
        subtitle += " | " + roleNames;
      } else if (selectedUsers.length > 0) {
        const userNames = filteredUsers.map(u => u.name).join(", ");
        subtitle += " | " + (userNames.length > 50 ? userNames.substring(0, 47) + "..." : userNames);
      }
      
      openFittedRotaPrintWindow({ title, subtitle, rotaClone });
    }

    // Event listeners
    rotaPrintBtn?.addEventListener("click", openRotaPrintModal);
    rotaPrintClose?.addEventListener("click", closeRotaPrintModal);
    rotaPrintCloseX?.addEventListener("click", closeRotaPrintModal);
    rotaPrintModal?.addEventListener("click", (e) => {
      if (e.target === rotaPrintModal) closeRotaPrintModal();
    });

  </script>
</body>
</html>












