<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Calpe Ward</title>
  
  <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;500;600;700;800&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="css/styles.css">
  <link rel="stylesheet" href="css/rota.css">
  <link rel="stylesheet" href="css/rota-edit.css">
  <link rel="stylesheet" href="css/user-modal.css">
  <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
  <script src="js/config.js"></script>
  <script src="js/session-validator.js"></script>
  <script src="js/permissions.js"></script>
  <script src="js/nav-bar.js"></script>
  <script src="js/view-as.js?v=8"></script>
  <script src="js/swap-functions.js" defer></script>
  <script src="js/notifications-shared.js" defer></script>
  <script src="js/shift-functions.js" defer></script>
  <script src="js/shift-editor.js" defer></script>
</head>

<body>
  <div class="wrap">
    <!-- Page Navigation -->
    <div id="pageNav" style="padding: 8px 12px; background: #f0f0f0; border-bottom: 1px solid #ddd; display: flex; gap: 12px; font-size: 14px; align-items: center;">
      <a href="#" onclick="navigateToRequests(); return false;" style="color: #4F8DF7; text-decoration: none;">üìã Requests</a>
      <a href="rota.html" style="color: #4F8DF7; text-decoration: none; font-weight: 600;">üìÖ View Rota</a>
      <a href="#" id="navAdminLink" onclick="navigateToAdmin(); return false;" style="color: #4F8DF7; text-decoration: none; display: none;">‚öôÔ∏è Admin</a>
      <button id="viewAsBtn" class="badge" type="button" style="display:none; padding: 6px 12px; white-space: nowrap;">üëÅ View As</button>
    </div>
    
    <!-- Title + Controls -->
    <div class="titlebar">
      <div style="display:flex; gap:12px; align-items:center; flex:1;">
        <img
          src="logo.png"
          alt="Calpe Ward"
          style="height:44px; width:auto;"
        />
        <div style="flex:1;">
          <h1>Calpe Ward</h1>
          <div class="header-subrow" style="margin:0;">
            <label for="periodSelect" class="subtitle" style="font-weight: 600;">Period:</label>
            <select id="periodSelect" style="margin: 0 8px;">
              <option>Loading...</option>
            </select>
            <button id="publishBtn" class="btn" style="display: none; background: #059669; color: white; padding: 6px 12px; border-radius: 6px; border: none; font-weight: 600; cursor: pointer; font-size: 13px;">üì§ Publish</button>
            <button id="unpublishBtn" class="btn" style="display: none; background: #dc2626; color: white; padding: 6px 12px; border-radius: 6px; border: none; font-weight: 600; cursor: pointer; font-size: 13px; margin-left: 6px;">‚ö†Ô∏è Unpublish</button>
            <button id="toggleEditingBtn" class="btn" style="margin-left: 8px; padding: 6px 12px; font-size: 13px;">üîí Locked</button>
            <button type="button" id="toggleRequestsBtn" class="btn" style="margin-left: 8px; padding: 6px 12px; font-size: 13px;">üëÅÔ∏è Requests</button>
            <button type="button" id="addNonStaffBtn" class="btn" style="margin-left: 8px; display:none; padding: 6px 12px; font-size: 13px;">‚ûï Non‚ÄëStaff</button>
          </div>
        </div>
      </div>
      <div class="rightbits">
        <!-- Bell -->
        <button class="badge" id="noticeBell" type="button" title="Notices & notifications">
          üîî <span id="noticeBellDot" style="display:none;">‚Ä¢</span>
        </button>
        
        <!-- Admin badge -->
        <div class="badge admin" id="adminBadge" style="display:none;">ADMIN</div>
        
        <!-- Account badge (clickable to edit account) -->
        <button class="badge account-badge" id="loginBadge" type="button" title="Edit your account">
          <span class="acc-ic">üë§</span>
          <span class="acc-txt">Not logged in</span>
        </button>
        
        <!-- Logout -->
        <button id="logoutBtn">Logout</button>
      </div>
    </div>

    <!-- Period Status -->
    <div id="periodStatus" class="period-status" style="display: none;">
      <span class="status-badge" id="statusBadge"></span>
      <span id="statusText"></span>
    </div>

    <!-- Metadata Display (shown when editing) -->
    <div id="metadataDisplay" class="metadata-display" style="display: none; padding: 12px; background: #fff3cd; border: 1px solid #ffc107; border-radius: 4px; margin: 0 2px 12px; font-size: 14px;">
      <strong>Draft Editing Mode:</strong> Click any cell to assign shifts. Changes save immediately.
    </div>

    <!-- Published edit warning banner -->
    <div id="publishedEditBanner" class="metadata-display" style="display: none; padding: 12px; background: #ffe4d5; border: 1px solid #f97316; border-radius: 4px; margin: 0 2px 12px; font-size: 14px;">
      <strong>Published Edit Mode:</strong> Use only for post-publish corrections. All changes are recorded.
    </div>

    <!-- Pattern Warnings (admin only, collapsible) -->
    <div id="patternWarnings" class="pattern-warnings">
      <details id="patternWarningsDetails">
        <summary>Pattern Guidance</summary>
        <div id="warningsList"></div>
      </details>
    </div>

    <!-- Rota Table -->
    <div class="rota-scroll">
      <table id="rota"></table>
    </div>

    <!-- Shift Picker Modal -->
    <div class="modal-backdrop" id="shiftPickerBackdrop" aria-hidden="true">
      <div id="shiftPickerModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="shiftPickerTitle">
        <h2 id="shiftPickerTitle">Select shift</h2>
        <p id="shiftPickerDate" class="subtitle"></p>
        <div class="modal-bubble">
          <div id="shiftPickerList"></div>
        </div>
        
        <!-- Override times/hours (shown only for published edits) -->
        <div id="overrideSection" class="modal-bubble" style="display: none; margin-top: 12px; padding: 16px;">
          <div style="font-size: 13px; color: #64748b; margin-bottom: 12px; font-weight: 600;">Override Actual Times</div>
          <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 12px; margin-bottom: 12px;">
            <div>
              <label style="font-size: 12px; color: #64748b; display: block; margin-bottom: 4px;">Start</label>
              <input type="time" id="overrideStartTime" style="width: 100%; padding: 8px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 13px; box-sizing: border-box;">
            </div>
            <div>
              <label style="font-size: 12px; color: #64748b; display: block; margin-bottom: 4px;">End</label>
              <input type="time" id="overrideEndTime" style="width: 100%; padding: 8px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 13px; box-sizing: border-box;">
            </div>
            <div>
              <label style="font-size: 12px; color: #64748b; display: block; margin-bottom: 4px;">Hours</label>
              <input type="number" id="overrideHours" step="0.25" min="0" max="24" style="width: 100%; padding: 8px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 13px; box-sizing: border-box;">
            </div>
          </div>
          <button type="button" id="clearOverrideBtn" style="padding: 6px 12px; font-size: 12px; color: #64748b; border: 1px solid #d1d5db; background: white; border-radius: 6px; cursor: pointer;">Clear Override</button>
        </div>
        
        <script>
          // Auto-calculate hours when times change
          (function() {
            function calculateHours() {
              const startInput = document.getElementById('overrideStartTime');
              const endInput = document.getElementById('overrideEndTime');
              const hoursInput = document.getElementById('overrideHours');
              
              if (!startInput?.value || !endInput?.value) return;
              
              const [startHour, startMin] = startInput.value.split(':').map(Number);
              const [endHour, endMin] = endInput.value.split(':').map(Number);
              
              let hours = (endHour * 60 + endMin) - (startHour * 60 + startMin);
              if (hours < 0) hours += 24 * 60; // Handle overnight shifts
              
              const decimalHours = Math.round((hours / 60) * 4) / 4; // Round to nearest 0.25
              if (hoursInput) hoursInput.value = decimalHours;
            }
            
            // Attach listeners when DOM ready
            document.addEventListener('DOMContentLoaded', () => {
              const startInput = document.getElementById('overrideStartTime');
              const endInput = document.getElementById('overrideEndTime');
              
              if (startInput) startInput.addEventListener('change', calculateHours);
              if (endInput) endInput.addEventListener('change', calculateHours);
            });
          })();
        </script>
        
        <!-- Admin Note (internal only, shown for published edits) -->
        <div id="commentSection" class="modal-bubble" style="display: none; margin-top: 12px; padding: 16px;">
          <label style="font-size: 13px; color: #dc2626; display: block; margin-bottom: 8px; font-weight: 600;">Admin Note (override)</label>
          <textarea id="shiftComment" rows="3" placeholder="Note about time/hours override..." style="width: 100%; padding: 8px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 13px; font-family: inherit; resize: vertical; box-sizing: border-box; margin-bottom: 8px;"></textarea>
          
          <div style="display: flex; gap: 8px; align-items: center;">
            <label for="commentVisibilitySelect" style="font-size: 12px; color: #64748b;">Who can see:</label>
            <select id="commentVisibilitySelect" style="padding: 4px 8px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 12px; cursor: pointer;">
              <option value="admin_only">Admin only</option>
              <option value="all_staff">All staff</option>
              <option value="user_only">User only</option>
            </select>
          </div>
          
          <div style="font-size: 11px; color: #64748b; margin-top: 6px;">For general comments, use View Comments button.</div>
        </div>
        
        <div class="btns">
          <button id="shiftPickerSave" type="button" class="primary" style="display: none;">Save</button>
          <button id="shiftPickerClear" type="button">Clear</button>
          <button id="shiftPickerClose" type="button">Cancel</button>
        </div>
      </div>
    </div>

    <!-- Non-Staff Modal -->
    <div class="modal-backdrop" id="nonStaffModalBackdrop" aria-hidden="true">
      <div class="modal" role="dialog" aria-modal="true" aria-labelledby="nonStaffModalTitle">
        <h2 id="nonStaffModalTitle">Add Non‚ÄëStaff to Period</h2>
        
        <!-- Tab / Section Toggle -->
        <div class="modal-bubble" style="margin-bottom:16px;">
          <div style="display:flex; gap:0; border-bottom:1px solid #e5e7eb;">
            <button id="nsTabSelect" type="button" style="flex:1; padding:12px; border:none; background:none; color:#0f172a; font-weight:500; cursor:pointer; border-bottom:3px solid #3b82f6; margin-bottom:-1px;">Select Existing</button>
            <button id="nsTabCreate" type="button" style="flex:1; padding:12px; border:none; background:none; color:#94a3b8; font-weight:500; cursor:pointer; border-bottom:3px solid transparent; margin-bottom:-1px;">Create New</button>
          </div>
        </div>

        <!-- Select Existing Section -->
        <div id="nsSelectSection" style="display:block;">
          <div class="modal-bubble" style="margin-bottom:12px;">
            <div style="display:grid; grid-template-columns: 1fr 1fr; gap:12px; margin-bottom:12px;">
              <div>
                <label style="font-size:12px; color:#64748b; font-weight:500;">Category</label>
                <select id="nsCategory" style="width:100%; padding:8px; border:1px solid #d1d5db; border-radius:6px; margin-top:4px;">
                  <option value="student">Student</option>
                  <option value="bank">Bank</option>
                  <option value="agency">Agency</option>
                </select>
              </div>
              <div id="nsRoleGroupWrap">
                <label style="font-size:12px; color:#64748b; font-weight:500;">Role Group</label>
                <select id="nsRoleGroup" style="width:100%; padding:8px; border:1px solid #d1d5db; border-radius:6px; margin-top:4px;">
                  <option value="staff_nurse">Staff Nurse</option>
                  <option value="nursing_assistant">Nursing Assistant</option>
                </select>
              </div>
            </div>
            <div style="display:flex; gap:8px; margin-bottom:12px;">
              <input id="nsSearch" placeholder="Search profiles..." style="flex:1; padding:8px; border:1px solid #d1d5db; border-radius:6px;" />
              <button id="nsSearchBtn" type="button" style="padding:8px 12px; white-space:nowrap;">Search</button>
            </div>
            <div style="max-height:260px; overflow-y:auto; border:1px solid #e5e7eb; border-radius:6px; padding:8px; background:#f8fafc;" id="nsResults"></div>
          </div>
        </div>

        <!-- Create New Section (hidden by default) -->
        <div id="nsCreateSection" style="display:none;">
          <div class="modal-bubble" style="margin-bottom:12px;">
            <div style="display:flex; flex-direction:column; gap:12px;">
              <div>
                <label style="font-size:12px; color:#64748b; font-weight:500; display:block; margin-bottom:4px;">Full Name</label>
                <input id="nsNewName" placeholder="Enter full name" style="width:100%; padding:8px; border:1px solid #d1d5db; border-radius:6px;" />
              </div>
              <div style="display:grid; grid-template-columns: 1fr 1fr; gap:12px;">
                <div>
                  <label style="font-size:12px; color:#64748b; font-weight:500;">Category</label>
                  <select id="nsCategoryCreate" style="width:100%; padding:8px; border:1px solid #d1d5db; border-radius:6px; margin-top:4px;">
                    <option value="student">Student</option>
                    <option value="bank">Bank</option>
                    <option value="agency">Agency</option>
                  </select>
                </div>
                <div id="nsRoleGroupCreateWrap">
                  <label style="font-size:12px; color:#64748b; font-weight:500;">Role Group</label>
                  <select id="nsRoleGroupCreate" style="width:100%; padding:8px; border:1px solid #d1d5db; border-radius:6px; margin-top:4px;">
                    <option value="staff_nurse">Staff Nurse</option>
                    <option value="nursing_assistant">Nursing Assistant</option>
                  </select>
                </div>
              </div>
              <div id="nsCountsWrap" style="display:flex; align-items:center; gap:8px;">
                <input id="nsCounts" type="checkbox" style="width:18px; height:18px; cursor:pointer;" />
                <label style="font-size:12px; color:#64748b; cursor:pointer; margin:0;">Counts towards staffing</label>
              </div>
            </div>
          </div>
        </div>

        <!-- Delete Section (shown in Select Existing when item selected) -->
        <div id="nsDeleteSection" style="display:none;">
          <div class="modal-bubble" style="background:#fef2f2; border:1px solid #fca5a5; margin-bottom:12px;">
            <div style="display:flex; justify-content:space-between; align-items:center;">
              <div>
                <label style="font-size:12px; color:#991b1b; font-weight:500; display:block; margin-bottom:4px;">Remove from Period</label>
                <div id="nsDeleteItemName" style="font-size:14px; color:#0f172a;"></div>
              </div>
              <button id="nsDeleteBtn" type="button" style="padding:6px 12px; background:#dc2626; color:white; border:none; border-radius:6px; cursor:pointer; font-size:12px;">Remove</button>
            </div>
          </div>
        </div>

        <div class="btns">
          <button id="nsAddBtn" type="button" class="primary">Add to Period</button>
          <button id="nsCloseBtn" type="button">Close</button>
        </div>
      </div>
    </div>

    <!-- Published Details / Actions Modal (desktop: right-click, mobile: tap) -->
    <!-- Published Details / Actions Modal (desktop: right-click, mobile: tap) -->
    <div class="modal-backdrop" id="publishedDetailsModal" aria-hidden="true">
      <div class="published-modal" role="dialog" aria-modal="true" aria-labelledby="publishedDetailsTitle">
        <div class="modal-head">
          <div class="modal-title" id="publishedDetailsTitle">Shift Details</div>
          <div class="modal-sub" id="publishedDetailsSubtitle"></div>
        </div>

        <div class="modal-bubble">
          <div style="padding: 12px; background: #f8fafc; border-radius: 6px; margin-bottom: 8px;">
            <div class="shift-display">
              <span class="shift-code" id="publishedShiftCode"></span>
              <span class="shift-name" id="publishedShiftName"></span>
            </div>
          </div>
          <div class="rest-day" id="restDayLabel" style="display:none; margin-top:8px; font-size:13px; color:#64748b; font-style:italic;">Rest day</div>
          
          <!-- Scheduled times (original from shift) -->
          <div class="kv" id="scheduledTimesRow" style="margin-top:12px; display:none;">
            <div class="k">Scheduled</div>
            <div class="v" id="scheduledTimes"></div>
          </div>
          
          <!-- Actual times (override) -->
          <div class="kv" id="actualTimesRow" style="margin-top:10px; display:none;">
            <div class="k" style="color: #dc2626; font-weight: 600;">Actual</div>
            <div class="v" id="actualTimes" style="color: #dc2626; font-weight: 600;"></div>
          </div>
          
          <!-- Hours (scheduled or override) -->
          <div class="kv" id="hoursRow" style="margin-top:10px; display:none;">
            <div class="k">Hours</div>
            <div class="v" id="publishedShiftHours"></div>
          </div>
          
          <!-- Admin Note display (internal only) -->
          <div id="commentDisplay" style="display:none; margin-top:12px; padding:10px; background:#fef2f2; border-left:3px solid #dc2626; border-radius:4px;">
            <div style="font-size:12px; color:#dc2626; margin-bottom:4px; font-weight:600;">Admin Note (internal)</div>
            <div id="commentText" style="font-size:13px; color:#0f172a; white-space:pre-wrap;"></div>
          </div>
        </div>

        <div class="btns">
          <button id="publishedChangeBtn" class="primary" type="button">Change shift</button>
          <button id="publishedOverrideBtn" class="primary" type="button">Override shift</button>
          <button id="publishedCommentsBtn" type="button">View comments</button>
          <button id="publishedSwapBtn" type="button">Swap shift</button>
          <button id="publishedHistoryBtn" type="button">View history</button>
          <div class="close-row">
            <button id="publishedDetailsClose" type="button">Close</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Override Amendment Modal -->
    <div class="modal-backdrop" id="overrideAmendmentModalBackdrop" aria-hidden="true">
      <div class="modal" role="dialog" aria-modal="true" aria-labelledby="overrideAmendmentTitle">
        <h2 id="overrideAmendmentTitle">Override Shift Times</h2>
        <p id="overrideAmendmentSubtitle" class="subtitle"></p>
        
        <div class="modal-bubble" style="padding: 16px;">
          <div style="font-size: 13px; color: #64748b; margin-bottom: 12px; font-weight: 600;">Amendment Details</div>
          <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 12px; margin-bottom: 12px;">
            <div>
              <label style="font-size: 12px; color: #64748b; display: block; margin-bottom: 4px;">Start</label>
              <input type="time" id="amendmentStartTime" style="width: 100%; padding: 8px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 13px; box-sizing: border-box;">
            </div>
            <div>
              <label style="font-size: 12px; color: #64748b; display: block; margin-bottom: 4px;">End</label>
              <input type="time" id="amendmentEndTime" style="width: 100%; padding: 8px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 13px; box-sizing: border-box;">
            </div>
            <div>
              <label style="font-size: 12px; color: #64748b; display: block; margin-bottom: 4px;">Hours</label>
              <input type="number" id="amendmentHours" step="0.25" min="0" max="24" style="width: 100%; padding: 8px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 13px; box-sizing: border-box;">
            </div>
          </div>
          
          <label style="font-size: 13px; color: #dc2626; display: block; margin-bottom: 8px; margin-top: 12px; font-weight: 600;">Reason (internal note)</label>
          <textarea id="amendmentReason" rows="3" placeholder="Reason for override..." style="width: 100%; padding: 8px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 13px; font-family: inherit; resize: vertical; box-sizing: border-box; margin-bottom: 12px;"></textarea>
        </div>
        
        <div class="btns">
          <button id="amendmentSaveBtn" type="button" class="primary">Save Override</button>
          <button id="amendmentCancelBtn" type="button">Cancel</button>
        </div>
      </div>
    </div>

    <!-- Comments Modal -->
    <div class="modal-backdrop" id="commentsModalBackdrop" aria-hidden="true">
      <div class="modal" role="dialog" aria-modal="true" aria-labelledby="commentsModalTitle">
        <h2 id="commentsModalTitle">Comments</h2>
        <p id="commentsModalSubtitle" class="subtitle"></p>
        
        <div class="modal-bubble" style="max-height: 400px; overflow-y: auto;">
          <div id="commentsList" style="display: flex; flex-direction: column; gap: 12px;"></div>
        </div>
        
        <!-- Add comment section -->
        <div class="modal-bubble" style="margin-top: 12px; padding: 16px;">
          <label style="font-size: 13px; display: block; margin-bottom: 8px; font-weight: 600;">Add Comment</label>
          <textarea id="newCommentText" rows="3" placeholder="Type your comment..." style="width: 100%; padding: 8px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 13px; font-family: inherit; resize: vertical; box-sizing: border-box; margin-bottom: 8px;"></textarea>
          
          <div style="display: flex; gap: 8px; align-items: center;">
            <label for="commentVisibilityDropdown" style="font-size: 12px; color: #64748b;">Who can see:</label>
            <select id="commentVisibilityDropdown" style="padding: 4px 8px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 12px; cursor: pointer;">
              <option value="admin_only">Admin only</option>
              <option value="all_staff" selected>All staff</option>
              <option value="user_only">User only</option>
            </select>
          </div>
          
          <button id="addCommentBtn" type="button" class="primary" style="margin-top: 12px; width: 100%;">Add Comment</button>
        </div>
        
        <div class="btns">
          <button id="commentsModalClose" type="button">Close</button>
        </div>
      </div>
    </div>

    <!-- Notices Modal (merged feed) -->
    <div class="modal-backdrop" id="noticeAllModal" aria-hidden="true">
      <div class="modal" role="dialog" aria-modal="true">
        <h2>Notices & Notifications</h2>
        <div class="modal-bubble" style="max-height: 500px; overflow-y: auto;">
          <div id="noticeAllList" style="display: flex; flex-direction: column; gap: 12px;"></div>
        </div>
        <div class="btns">
          <button id="noticeAllClose" type="button">Close</button>
        </div>
      </div>
    </div>

    <!-- Shift Swap Modal -->
    <div class="modal-backdrop" id="shiftSwapModal" aria-hidden="true">
      <div class="modal" role="dialog" aria-modal="true" aria-labelledby="shiftSwapTitle">
        <h2 id="shiftSwapTitle">Propose Shift Swap</h2>
        <p id="shiftSwapSubtitle" class="subtitle"></p>

        <div class="modal-bubble">
          <div style="margin-bottom: 16px;">
            <label style="display: block; font-size: 13px; font-weight: 600; margin-bottom: 6px;">Your shift:</label>
            <div id="swapYourShift" style="padding: 10px; background: #f3f4f6; border-radius: 6px; font-size: 13px;"></div>
          </div>

          <div style="margin-bottom: 16px;">
            <label for="swapPeerSelect" style="display: block; font-size: 13px; font-weight: 600; margin-bottom: 6px;">Swap with:</label>
            <select id="swapPeerSelect" style="width: 100%; padding: 8px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 13px; font-family: inherit;">
              <option value="">Select staff member...</option>
            </select>
          </div>

          <div style="margin-bottom: 16px;">
            <label for="swapDateSelect" style="display: block; font-size: 13px; font-weight: 600; margin-bottom: 6px;">Their shift on:</label>
            <select id="swapDateSelect" style="width: 100%; padding: 8px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 13px; font-family: inherit;" disabled>
              <option value="">Select their shift date...</option>
            </select>
          </div>
        </div>

        <div class="btns">
          <button id="swapSubmitBtn" type="button" class="primary">Send Request</button>
          <button id="swapCancelBtn" type="button">Cancel</button>
        </div>
      </div>
    </div>

    <!-- User Account Modal -->
    <div class="modal-backdrop" id="userModal" aria-hidden="true" style="display:none;">
      <div class="modal" role="dialog" aria-modal="true" aria-labelledby="userTitle">
        <h2 id="userTitle">Edit your account</h2>
        <p class="subtitle" id="userMeta">‚Äî</p>

        <!-- CHANGE PIN CARD -->
        <div class="modal-bubble" style="padding:16px; margin:12px 0;">
          <div style="font-weight:700; margin-bottom:12px; font-size:14px;">Change PIN</div>

          <div style="display:grid; grid-template-columns:1fr 1fr 1fr; gap:8px; margin-bottom:12px;">
            <input id="userOldPin" class="control" type="password" inputmode="numeric" maxlength="4" placeholder="Current PIN" />
            <input id="userNewPin" class="control" type="password" inputmode="numeric" maxlength="4" placeholder="New PIN" />
            <input id="userNewPin2" class="control" type="password" inputmode="numeric" maxlength="4" placeholder="Repeat new PIN" />
          </div>

          <div class="btns" style="margin-top:12px; justify-content:flex-end;">
            <button id="userSavePin" class="primary" type="button">Save new PIN</button>
          </div>

          <div id="userPinErr" style="display:none; margin-top:8px; color:#dc2626; font-size:13px;"></div>
          <div id="userPinOk" style="display:none; margin-top:8px; color:#059669; font-weight:600; font-size:13px;">
            PIN updated successfully.
          </div>
        </div>

        <!-- BOTTOM BUTTONS -->
        <div class="btns">
          <button id="userLogout" type="button">Log out</button>
          <button id="userClose" type="button">Close</button>
        </div>
      </div>
    </div>

  </div> <!-- close .wrap -->

  <script src="js/assignment-history.js"></script>
  <script src="js/rota-context-menu.js"></script>
  <script src="js/user-modal.js"></script>
  <script>
    console.log("ROTA.HTML LOADING - VERSION 3", "readyState=", document.readyState);
    // Supabase + storage accessors (tolerate early execution before defer scripts)
    const getSupabase = () => window.supabaseClient;
    const getStorageKey = () => window.STORAGE_KEY || "calpeward.loggedInUserId";

    // Session is handled via token in sessionStorage; no PIN handoff or window.name needed

    let currentPeriod = null;
    let allUsers = [];
    let allWeeks = [];
    let shiftMap = new Map(); // id -> shift_catalogue row
    let assignmentsMap = new Map(); // user_id_date -> rota_assignment
    let overridesMap = new Map(); // rota_assignment_id -> rota_assignment_override
    let commentsMap = new Map(); // rota_assignment_id -> [comments array]
    let requestsMap = new Map(); // user_id_date -> request
    let patterns = new Map(); // pattern_id -> pattern_definitions
    let userPatterns = new Map(); // user_id -> user_patterns row
    let periodData = null;
    let showRequests = false;
    
    // Permission flags (set during auth)
    let canViewAllRequests = false;
    let canViewOwnRequests = false;
    let canEditDraft = false;
    let canEditPublished = false;
    let currentEditContext = "draft";
    let lastPublishedCell = null;

    // Expose context for helper modules (context menu, history)
    window.currentEditContext = currentEditContext;
    window.periodData = periodData;
    
    // Load staffing defaults from localStorage (set in admin panel)
    function getStaffingDefaults() {
      const defaults = JSON.parse(localStorage.getItem("calpeward.staffing_defaults") || 
        '{"day_sn_required":3,"day_na_required":3,"night_sn_required":2,"night_na_required":2}');
      return defaults;
    }
    


    // ========== AUTH ==========
    async function checkAuth() {
      console.log("[ROTA DEBUG] checkAuth starting...");

      console.log("[ROTA DEBUG] STORAGE_KEY getter returns", getStorageKey());
      console.log("[ROTA DEBUG] localStorage userId", localStorage.getItem(getStorageKey()));
      console.log("[ROTA DEBUG] supabaseClient available?", !!getSupabase());

      if (!window.PermissionsModule || typeof window.PermissionsModule.loadCurrentUserPermissions !== "function") {
        console.error("[ROTA DEBUG] PermissionsModule not available");
        window.location.href = "index.html";
        return null;
      }

      console.log("[ROTA DEBUG] Calling PermissionsModule.loadCurrentUserPermissions...");
      await window.PermissionsModule.loadCurrentUserPermissions();
      const currentUser = window.PermissionsModule.getCurrentUser();
      console.log("[ROTA DEBUG] PermissionsModule currentUser:", currentUser);

      if (!currentUser) {
        console.warn("[ROTA DEBUG] No current user after permissions load; redirecting");
        window.location.href = "index.html";
        return null;
      }

      // Store globally for rota.html and other scripts
      window.currentUser = currentUser;
      console.log("[ROTA DEBUG] User loaded:", currentUser.name);
      
      // Update loginBadge with user name
      const loginBadge = document.getElementById("loginBadge");
      const txt = loginBadge?.querySelector(".acc-txt");
      if (txt) {
        txt.textContent = currentUser.name;
      } else if (loginBadge) {
        loginBadge.textContent = currentUser.name;
      }
      
      // Update admin badge
      const adminBadge = document.getElementById("adminBadge");
      if (adminBadge) {
        adminBadge.style.display = currentUser.is_admin ? "inline-block" : "none";
      }
      
      // Show navigation admin link only for admins
      const navAdminLink = document.getElementById("navAdminLink");
      if (navAdminLink) navAdminLink.style.display = currentUser.is_admin ? "inline" : "none";

      // Show View As button only for superadmin
      const viewAsBtn = document.getElementById("viewAsBtn");
      if (viewAsBtn) viewAsBtn.style.display = currentUser.is_admin ? "inline-block" : "none";

      // Show Add Non-Staff if admin or mentor
      const addNsBtn = document.getElementById("addNonStaffBtn");
      const isMentor = window.PermissionsModule?.hasPermission?.('non_staff.edit_student_shifts');
      if (addNsBtn) addNsBtn.style.display = (currentUser.is_admin || isMentor) ? "inline-block" : "none";
      if (addNsBtn) addNsBtn.onclick = openNonStaffModal;

      return currentUser;
    }

    const logoutBtn = document.getElementById("logoutBtn");
    if (logoutBtn) {
      logoutBtn.addEventListener("click", async () => {
        await logout();
      });
    } else {
      console.warn("[ROTA BOOT] logoutBtn not found; skipping logout binding");
    }

    // User modal is now handled by js/user-modal.js

    // ========== HELPERS ==========
    let selectedNonStaffForDelete = null; // Track which person is selected for deletion
    let bankHolidaysByDate = {}; // Cache bank holidays by date string (YYYY-MM-DD)
    
    // Load bank holidays for the current and next few years
    async function loadBankHolidays() {
      try {
        const currentYear = new Date().getFullYear();
        const { data, error } = await supabaseClient.rpc('rpc_get_all_bank_holidays', {
          p_start_year: currentYear,
          p_end_year: currentYear + 3
        });
        if (error) throw error;
        if (data) {
          data.forEach(holiday => {
            const dateStr = holiday.holiday_date; // YYYY-MM-DD format from DB
            bankHolidaysByDate[dateStr] = holiday.name;
          });
        }
      } catch (e) {
        console.warn('Failed to load bank holidays:', e);
      }
    }
    
    function isBankHoliday(date) {
      if (!date) return false;
      const dateStr = date.toISOString().split('T')[0]; // Convert to YYYY-MM-DD
      return bankHolidaysByDate.hasOwnProperty(dateStr);
    }
    
    function getBankHolidayName(date) {
      if (!date) return null;
      const dateStr = date.toISOString().split('T')[0];
      return bankHolidaysByDate[dateStr] || null;
    }
    
    function getWeekStart(date) {
      const d = new Date(date);
      const day = d.getDay(); // 0 = Sunday
      d.setDate(d.getDate() - day);
      d.setHours(0, 0, 0, 0);
      return d;
    }

    function fmt(date) {
      const d = new Date(date);
      return d.toLocaleDateString("en-GB", { day: "numeric", month: "short" });
    }

    // ========== LOAD PERIODS ==========
    async function loadPeriods() {
      const { data, error } = await supabaseClient
        .from("rota_periods")
        .select("*")
        .order("start_date", { ascending: false });

      if (error) {
        console.error("Error loading periods:", error);
        alert("Failed to load rota periods: " + error.message);
        return;
      }

      const select = document.getElementById("periodSelect");
      select.innerHTML = '<option value="">Select period...</option>';
      
      if (!data || data.length === 0) {
        select.innerHTML = '<option value="">No periods available</option>';
        console.warn("No rota periods found in database");
        return;
      }
      
      data.forEach(p => {
        const opt = document.createElement("option");
        opt.value = p.id;
        opt.textContent = `${fmt(new Date(p.start_date))} ‚Äì ${fmt(new Date(p.end_date))}`;
        select.appendChild(opt);
      });

      if (data.length > 0) {
        select.value = data[0].id;
        await loadPeriod(data[0].id);
      }
    }

    // ========== NON-STAFF MODAL LOGIC ==========
    function openNonStaffModal() {
      const backdrop = document.getElementById('nonStaffModalBackdrop');
      if (!backdrop) return;
      const isMentor = window.PermissionsModule?.hasPermission?.('non_staff.edit_student_shifts');
      // Mentors default to students and lock categories
      const categorySel = document.getElementById('nsCategory');
      const categorySelCreate = document.getElementById('nsCategoryCreate');
      if (categorySel) {
        categorySel.value = 'student';
        categorySel.disabled = !window.currentUser?.is_admin && isMentor;
      }
      if (categorySelCreate) {
        categorySelCreate.value = 'student';
        categorySelCreate.disabled = !window.currentUser?.is_admin && isMentor;
      }
      // Initialize role group + counts UI for default (student)
      updateNonStaffModalFields();
      updateNonStaffModalFieldsCreate();
      document.getElementById('nsSearch')?.setAttribute('value','');
      document.getElementById('nsResults').innerHTML = '';
      document.getElementById('nsNewName').value = '';
      // Switch to Select tab by default
      switchNonStaffTab('select');
      backdrop.setAttribute('aria-hidden','false');
    }

    function closeNonStaffModal() {
      const backdrop = document.getElementById('nonStaffModalBackdrop');
      if (backdrop) backdrop.setAttribute('aria-hidden','true');
    }

    async function searchNonStaff() {
      const category = document.getElementById('nsCategory')?.value || null;
      const roleGroup = (category === 'student') ? null : (document.getElementById('nsRoleGroup')?.value || null);
      const query = document.getElementById('nsSearch')?.value || null;
      const resultsEl = document.getElementById('nsResults');
      if (!resultsEl) return;
      resultsEl.innerHTML = '<div style="color:#64748b;">Searching...</div>';
      try {
        const { data, error } = await supabaseClient.rpc('rpc_list_non_staff_people', {
          p_token: window.currentToken,
          p_category: category,
          p_role_group: roleGroup,
          p_query: query
        });
        if (error) throw error;
        if (!data || data.length === 0) {
          resultsEl.innerHTML = '<div style="color:#64748b;">No matches.</div>';
          return;
        }
        resultsEl.innerHTML = '';
        data.forEach(row => {
          const line = document.createElement('div');
          line.style.display = 'flex';
          line.style.justifyContent = 'space-between';
          line.style.alignItems = 'center';
          line.style.padding = '8px 6px';
          line.style.cursor = 'pointer';
          line.style.borderRadius = '4px';
          line.style.transition = 'background 200ms';
          
          line.addEventListener('mouseenter', () => { line.style.background = '#f1f5f9'; });
          line.addEventListener('mouseleave', () => { line.style.background = ''; });
          line.addEventListener('click', () => {
            selectedNonStaffForDelete = row;
            showDeleteSection(row);
          });
          
          const left = document.createElement('div');
          left.textContent = `${row.name} ¬∑ ${row.category}${row.role_group ? ' ¬∑ ' + row.role_group : ''}`;
          const btn = document.createElement('button');
          btn.textContent = 'Add';
          btn.style.whiteSpace = 'nowrap';
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            addExistingNonStaff(row.id, row.category);
          });
          line.appendChild(left);
          line.appendChild(btn);
          resultsEl.appendChild(line);
        });
      } catch (e) {
        resultsEl.innerHTML = `<div style="color:#dc2626;">Error: ${e?.message || e}</div>`;
      }
    }

    async function addExistingNonStaff(nonStaffPersonId, category) {
      const counts = document.getElementById('nsCounts');
      const countsVal = counts?.checked ?? (category !== 'student');
      try {
        const { data, error } = await supabaseClient.rpc('rpc_add_non_staff_to_period', {
          p_token: window.currentToken,
          p_period_id: currentPeriod,
          p_non_staff_person_id: nonStaffPersonId,
          p_counts_towards_staffing: countsVal,
          p_display_order: 9999
        });
        if (error) throw error;
        closeNonStaffModal();
        await loadPeriod(currentPeriod);
      } catch (e) {
        alert('Failed to add: ' + (e?.message || e));
      }
    }

    async function addNewNonStaff() {
      const name = document.getElementById('nsNewName')?.value?.trim();
      const category = document.getElementById('nsCategoryCreate')?.value;
      const roleGroup = category === 'student' ? null : document.getElementById('nsRoleGroupCreate')?.value;
      const counts = (category === 'student') ? false : true;
      if (!name) {
        alert('Enter a name for the new profile.');
        return;
      }
      try {
        const { data: created, error: addErr } = await supabaseClient.rpc('rpc_add_non_staff_person', {
          p_token: window.currentToken,
          p_name: name,
          p_category: category,
          p_role_group: roleGroup,
          p_notes: null
        });
        if (addErr) throw addErr;
        const newId = created?.id;
        if (!newId) throw new Error('Create returned no id');
        await addExistingNonStaff(newId, category);
      } catch (e) {
        alert('Failed to create/add: ' + (e?.message || e));
      }
    }

    function showDeleteSection(item) {
      const deleteSection = document.getElementById('nsDeleteSection');
      const deleteItemName = document.getElementById('nsDeleteItemName');
      const isMentor = window.PermissionsModule?.hasPermission?.('non_staff.edit_student_shifts');
      
      // Only show delete if admin or mentor (for students)
      const canDelete = window.currentUser?.is_admin || (isMentor && item.category === 'student');
      if (!canDelete) {
        deleteSection.style.display = 'none';
        return;
      }
      
      deleteItemName.textContent = `${item.name} (${item.category})`;
      deleteSection.style.display = 'block';
    }

    async function deleteSelectedNonStaff() {
      if (!selectedNonStaffForDelete || !selectedNonStaffForDelete.id) {
        alert('No item selected for deletion');
        return;
      }
      
      const confirmMsg = `Remove ${selectedNonStaffForDelete.name} from this period?`;
      if (!confirm(confirmMsg)) return;
      
      try {
        const { error } = await supabaseClient.rpc('rpc_remove_non_staff_from_period', {
          p_token: window.currentToken,
          p_period_non_staff_id: selectedNonStaffForDelete.id
        });
        if (error) throw error;
        selectedNonStaffForDelete = null;
        document.getElementById('nsDeleteSection').style.display = 'none';
        await loadPeriod(currentPeriod);
      } catch (e) {
        alert('Failed to remove: ' + (e?.message || e));
      }
    }

    // Tab switching for Select vs Create sections
    function switchNonStaffTab(tab) {
      const selectSection = document.getElementById('nsSelectSection');
      const createSection = document.getElementById('nsCreateSection');
      const tabSelect = document.getElementById('nsTabSelect');
      const tabCreate = document.getElementById('nsTabCreate');
      
      if (tab === 'select') {
        if (selectSection) selectSection.style.display = 'block';
        if (createSection) createSection.style.display = 'none';
        if (tabSelect) {
          tabSelect.style.color = '#0f172a';
          tabSelect.style.borderBottomColor = '#3b82f6';
        }
        if (tabCreate) {
          tabCreate.style.color = '#94a3b8';
          tabCreate.style.borderBottomColor = 'transparent';
        }
      } else {
        if (selectSection) selectSection.style.display = 'none';
        if (createSection) createSection.style.display = 'block';
        if (tabSelect) {
          tabSelect.style.color = '#94a3b8';
          tabSelect.style.borderBottomColor = 'transparent';
        }
        if (tabCreate) {
          tabCreate.style.color = '#0f172a';
          tabCreate.style.borderBottomColor = '#3b82f6';
        }
      }
    }

    // Bind modal buttons after DOM ready
    document.addEventListener('DOMContentLoaded', () => {
      const searchBtn = document.getElementById('nsSearchBtn');
      if (searchBtn) searchBtn.addEventListener('click', searchNonStaff);
      const closeBtn = document.getElementById('nsCloseBtn');
      if (closeBtn) closeBtn.addEventListener('click', closeNonStaffModal);
      const addBtn = document.getElementById('nsAddBtn');
      if (addBtn) addBtn.addEventListener('click', addNewNonStaff);
      const deleteBtn = document.getElementById('nsDeleteBtn');
      if (deleteBtn) deleteBtn.addEventListener('click', deleteSelectedNonStaff);
      const categorySel = document.getElementById('nsCategory');
      if (categorySel) categorySel.addEventListener('change', updateNonStaffModalFields);
      const categorySelCreate = document.getElementById('nsCategoryCreate');
      if (categorySelCreate) categorySelCreate.addEventListener('change', updateNonStaffModalFieldsCreate);
      const backdrop = document.getElementById('nonStaffModalBackdrop');
      if (backdrop) backdrop.addEventListener('click', (e) => { if (e.target === backdrop) closeNonStaffModal(); });
      
      // Tab switching
      const tabSelect = document.getElementById('nsTabSelect');
      if (tabSelect) tabSelect.addEventListener('click', () => switchNonStaffTab('select'));
      const tabCreate = document.getElementById('nsTabCreate');
      if (tabCreate) tabCreate.addEventListener('click', () => switchNonStaffTab('create'));
    });

    function updateNonStaffModalFields(){
      const category = document.getElementById('nsCategory')?.value;
      const roleWrap = document.getElementById('nsRoleGroupWrap');
      const countsWrap = document.getElementById('nsCountsWrap');
      const counts = document.getElementById('nsCounts');
      if (!category) return;
      if (category === 'student'){
        if (roleWrap) roleWrap.style.display = 'none';
        if (countsWrap) countsWrap.style.display = 'none';
        if (counts) { counts.checked = false; counts.disabled = true; }
      } else if (category === 'agency') {
        if (roleWrap) roleWrap.style.display = '';
        if (countsWrap) countsWrap.style.display = '';
        if (counts) { counts.checked = true; counts.disabled = true; }
      } else {
        // bank: allow toggle
        if (roleWrap) roleWrap.style.display = '';
        if (countsWrap) countsWrap.style.display = '';
        if (counts) { counts.disabled = false; }
      }
    }

    function updateNonStaffModalFieldsCreate(){
      const category = document.getElementById('nsCategoryCreate')?.value;
      const roleWrap = document.getElementById('nsRoleGroupCreateWrap');
      const countsWrap = document.getElementById('nsCountsWrap');
      const counts = document.getElementById('nsCounts');
      if (!category) return;
      if (category === 'student'){
        if (roleWrap) roleWrap.style.display = 'none';
        if (countsWrap) countsWrap.style.display = 'none';
        if (counts) { counts.checked = false; counts.disabled = true; }
      } else if (category === 'agency') {
        if (roleWrap) roleWrap.style.display = '';
        if (countsWrap) countsWrap.style.display = '';
        if (counts) { counts.checked = true; counts.disabled = true; }
      } else {
        // bank: allow toggle
        if (roleWrap) roleWrap.style.display = '';
        if (countsWrap) countsWrap.style.display = '';
        if (counts) { counts.disabled = false; }
      }
    }

    // ========== LOAD PERIOD DATA ==========
    async function loadPeriod(periodId) {
      if (!periodId) return;
      const periodIdNum = Number(periodId);
      const periodKey = Number.isFinite(periodIdNum) ? periodIdNum : periodId;
      currentPeriod = periodKey;
      // Expose to window for swap-functions/admin operations
      window.currentPeriod = { id: periodKey };

      try {
        // Load period info
        console.log("[LOAD] Loading period...");
        const { data: period, error: pErr } = await supabaseClient
          .from("rota_periods")
          .select("*")
          .eq("id", periodId)
          .single();

        if (pErr) throw new Error(`Period load failed: ${pErr.message}`);
        if (!period) throw new Error("Period not found");
        periodData = period;
        window.periodData = periodData;
        displayPeriodStatus(period);

        // Generate dates from period start_date to end_date
        const dates = generateDatesForPeriod(period.start_date, period.end_date);
        allWeeks = groupDatesIntoWeeks(dates);

        // Load users (active only) using same ordering as main app (role -> display_order -> created_at)
        console.log("[LOAD] Loading users...");
        const { data: users, error: uErr } = await supabaseClient
          .from("users")
          .select("id, name, role_id, is_admin, display_order")
          .eq("is_active", true)
          .order("role_id", { ascending: true })
          .order("display_order", { ascending: true })
          .order("created_at", { ascending: true });

        if (uErr) throw new Error(`Users load failed: ${uErr.message}`);
        allUsers = (users || []).map(u => ({ ...u, name: u.name, is_non_staff: false }));

        // Load non-staff for this period
        console.log("[LOAD] Loading period non-staff...");
        try {
          const { data: nonStaff, error: nsErr } = await supabaseClient.rpc("rpc_get_period_non_staff", {
            p_token: window.currentToken,
            p_period_id: periodId
          });

          if (nsErr) {
            console.error("Non-staff load failed:", nsErr);
          } else if (nonStaff && nonStaff.length > 0) {
            console.log("[LOAD] Loaded", nonStaff.length, "non-staff");
            
            // Merge non-staff into allUsers with special flags
            nonStaff.forEach(ns => {
              // Use period_non_staff_id as the primary identifier so assignments map aligns
              allUsers.push({
                id: ns.period_non_staff_id,
                non_staff_person_id: ns.id,
                period_non_staff_id: ns.period_non_staff_id,
                name: ns.name,
                role_id: ns.role_group === 'staff_nurse' ? 2 : 3, // Map to SN or NA for grouping
                is_admin: false,
                display_order: ns.display_order,
                is_non_staff: true,
                category: ns.category, // 'student', 'bank', 'agency'
                role_group: ns.role_group, // 'staff_nurse', 'nursing_assistant'
                counts_towards_staffing: ns.counts_towards_staffing,
                notes: ns.notes
              });
            });
          }
        } catch (e) {
          console.error("Failed to load non-staff:", e);
        }

        // Load shift catalogue
        console.log("[LOAD] Loading shifts...");
        const { data: shifts, error: sErr } = await supabaseClient
          .from("shifts")
          .select("*");

        if (sErr) throw new Error(`Shifts load failed: ${sErr.message}`);
        shiftMap.clear();
        (shifts || []).forEach(s => shiftMap.set(s.id, s));

        // Load assignments for this date range
        // Only show assignments if user has draft permission OR period is published
        console.log("[LOAD] Loading assignments...");
        const canViewDraft = window.PermissionsModule.hasPermission("rota.view_draft");
        const isPeriodPublished = period.status === "published";
        
        assignmentsMap.clear();
        overridesMap.clear();
        if (canViewDraft || isPeriodPublished) {
          const { data: assignments, error: aErr } = await supabaseClient
            .from("rota_assignments")
            .select("*")
            .gte("date", period.start_date)
            .lte("date", period.end_date);

          if (aErr) throw new Error(`Assignments load failed: ${aErr.message}`);
          
          const assignmentIds = [];
          (assignments || []).forEach(a => {
            // Handle both regular users and non-staff assignments
            const key = a.user_id ? `${a.user_id}_${a.date}` : `${a.period_non_staff_id}_${a.date}`;
            assignmentsMap.set(key, a);
            if (a.id) assignmentIds.push(a.id);
          });
          
          // Load overrides ONLY for published periods
          if (isPeriodPublished && assignmentIds.length > 0) {
            const { data: overrides, error: oErr } = await supabaseClient
              .from("rota_assignment_overrides")
              .select("*")
              .in("rota_assignment_id", assignmentIds);

            if (oErr) console.error("Error loading overrides:", oErr);
            else {
              (overrides || []).forEach(o => {
                overridesMap.set(o.rota_assignment_id, o);
              });
            }
          }
        }

        // Load requests for this date range using RPC function (respects RLS policies)
        console.log("[LOAD] Loading requests via RPC...");
        const { data: requests, error: rErr } = await supabaseClient.rpc("get_requests_for_period", {
          p_token: window.currentToken,
          p_start_date: period.start_date,
          p_end_date: period.end_date,
          p_force_view_all: false
        });

        if (rErr) throw new Error(`Requests load failed: ${rErr.message}`);
        requestsMap.clear();
        (requests || []).forEach(r => {
          requestsMap.set(`${r.user_id}_${r.date}`, r);
        });
        console.log("[LOAD] requestsMap populated with", requestsMap.size, "entries");

        // Load assignment comments (for published periods only)
        console.log("[LOAD] Loading comments...");
        commentsMap.clear();
        if (isPeriodPublished) {
          const { data: comments, error: cErr } = await supabaseClient
            .from("rota_assignment_comments")
            .select("*");

          if (cErr) throw new Error(`Comments load failed: ${cErr.message}`);
          (comments || []).forEach(c => {
            const existing = commentsMap.get(c.rota_assignment_id) || [];
            existing.push(c);
            commentsMap.set(c.rota_assignment_id, existing);
          });
          console.log('[LOAD] CommentsMap populated:', commentsMap.size, 'assignments with comments');
        }

        // Load patterns
        console.log("[LOAD] Loading patterns...");
        const { data: pats, error: patErr } = await supabaseClient
          .from("pattern_definitions")
          .select("*");

        if (patErr) throw new Error(`Patterns load failed: ${patErr.message}`);
        patterns.clear();
        (pats || []).forEach(p => patterns.set(p.id, p));

        console.log("[LOAD] Loading user patterns...");
        const { data: upats, error: upatErr } = await supabaseClient
          .from("user_patterns")
          .select("*");

        if (upatErr) throw new Error(`User patterns load failed: ${upatErr.message}`);
        userPatterns.clear();
        (upats || []).forEach(up => userPatterns.set(up.user_id, up));

        // Load all shifts for admin editing from the shifts table
        console.log("[LOAD] Loading draft shifts...");
        const { data: draftShiftsData, error: dsErr } = await supabaseClient
          .from("shifts")
          .select("*")
          .order("code", { ascending: true });

        if (dsErr) throw new Error(`Draft shifts load failed: ${dsErr.message}`);
        draftShifts = draftShiftsData || [];
        console.log("[ROTA] Loaded draftShifts:", draftShifts);
        console.log("[ROTA] Sample shift object:", draftShifts[0]);

        // Configure editing context for this period
        updateEditingControls(period);

        // Render
        if (allWeeks.length) {
          const periodText = `${fmt(allWeeks[0].weekStart)} ‚Äì ${fmt(allWeeks[allWeeks.length - 1].weekEnd)}`;
          // Don't set periodLabel here anymore since it's part of the header controls
          // Update page title with period dates
          const pageTitle = document.querySelector("title");
          if (pageTitle) {
            pageTitle.textContent = `Calpe Ward - ${periodText}`;
          }
        }

        renderRota();
        generatePatternWarnings();

      } catch (err) {
        console.error("[LOAD] Fatal error:", err);
        alert("Error loading rota: " + err.message);
      }
    }

    // ========== GENERATE DATES FOR PERIOD ==========
    function generateDatesForPeriod(startDateStr, endDateStr) {
      const start = new Date(startDateStr);
      const end = new Date(endDateStr);
      const dates = [];

      for (let d = new Date(start); d <= end; d.setDate(d.getDate() + 1)) {
        const dateStr = d.toISOString().split('T')[0];
        dates.push({ date: dateStr });
      }

      return dates;
    }

    // ========== GROUP DATES INTO WEEKS ==========
    function groupDatesIntoWeeks(dates) {
      const weekMap = new Map();
      
      dates.forEach(d => {
        const dt = new Date(d.date);
        const sun = getWeekStart(dt);
        const key = sun.toISOString().split('T')[0];
        
        if (!weekMap.has(key)) {
          weekMap.set(key, {
            weekStart: sun,
            weekEnd: new Date(sun.getTime() + 6 * 24 * 60 * 60 * 1000),
            days: []
          });
        }
        
        weekMap.get(key).days.push(d);
      });
      
      return Array.from(weekMap.values()).sort((a, b) => a.weekStart - b.weekStart);
    }

    // ========== RENDER ROTA ==========
    function renderRota() {
      const table = document.getElementById("rota");
      table.innerHTML = "";

      const thead = document.createElement("thead");
      const tbody = document.createElement("tbody");
      table.appendChild(thead);
      table.appendChild(tbody);

      // Row 1: Week labels
      const r1 = document.createElement("tr");
      const h1 = document.createElement("th");
      h1.className = "name-col";
      h1.textContent = "Name";
      r1.appendChild(h1);

      allWeeks.forEach(w => {
        const th = document.createElement("th");
        th.className = "week-head";
        th.colSpan = 7;
        th.innerHTML = `<span class="week-label">${fmt(w.weekStart)} ‚Äì ${fmt(w.weekEnd)}</span>`;
        r1.appendChild(th);

        const sep = document.createElement("th");
        sep.className = "week-sep";
        r1.appendChild(sep);
      });
      thead.appendChild(r1);

      // Row 2: Day letters
      const r2 = document.createElement("tr");
      const h2 = document.createElement("th");
      h2.className = "name-col";
      r2.appendChild(h2);

      const dayLetters = ["S", "M", "T", "W", "T", "F", "S"];
      allWeeks.forEach(w => {
        for (let i = 0; i < 7; i++) {
          const th = document.createElement("th");
          th.className = "day";
          th.textContent = dayLetters[i];
          r2.appendChild(th);
        }
        const sep = document.createElement("th");
        sep.className = "week-sep";
        r2.appendChild(sep);
      });
      thead.appendChild(r2);

      // Row 3: Dates
      const r3 = document.createElement("tr");
      const h3 = document.createElement("th");
      h3.className = "name-col";
      r3.appendChild(h3);

      allWeeks.forEach(w => {
        for (let i = 0; i < 7; i++) {
          const d = new Date(w.days[i].date);
          const isWeekend = (d.getDay() === 0 || d.getDay() === 6);
          const isBankHol = isBankHoliday(d);
          const th = document.createElement("th");
          th.className = "date" + (isWeekend ? " weekend" : "") + (isBankHol ? " bank-holiday" : "");
          th.textContent = d.getDate();
          r3.appendChild(th);
        }
        const sep = document.createElement("th");
        sep.className = "week-sep";
        r3.appendChild(sep);
      });
      thead.appendChild(r3);

      // Body: group by role
      const groups = groupUsers(allUsers);

      for (const g of groups) {
        // Section header
        const sectionTr = document.createElement("tr");
        sectionTr.className = "section-row";
        const sectionTd = document.createElement("td");
        sectionTd.className = `name-col ${g.className}`;
        sectionTd.colSpan = 1 + (allWeeks.length * 7) + allWeeks.length;
        sectionTd.innerHTML = `<span>${g.title}</span>`;
        sectionTr.appendChild(sectionTd);
        tbody.appendChild(sectionTr);

        // User rows
        for (const u of g.items) {
          const tr = document.createElement("tr");
          tr.dataset.userId = u.id;

          const nameTd = document.createElement("td");
          nameTd.className = "name-col";
          nameTd.textContent = u.name;

          // Badge for non-staff categories
          if (u.is_non_staff) {
            const badge = document.createElement("span");
            badge.className = "badge pill";
            badge.style.marginLeft = "8px";
            badge.style.fontSize = "11px";
            badge.style.padding = "2px 6px";
            badge.style.borderRadius = "999px";

            // Only show badges for non-student non-staff
            if (u.category !== "student") {
              if (u.category === "agency") {
                badge.textContent = "AGENCY";
                badge.style.background = "#fef3c7";
                badge.style.color = "#92400e";
              } else if (u.category === "bank") {
                badge.textContent = "BANK";
                badge.style.background = "#ecfccb";
                badge.style.color = "#365314";
              }
              nameTd.appendChild(badge);
            }
          }

          tr.appendChild(nameTd);

          allWeeks.forEach(w => {
            w.days.forEach(day => {
              const dateObj = day.date ? new Date(day.date) : null;
              const isWeekend = dateObj && (dateObj.getDay() === 0 || dateObj.getDay() === 6);
              const dateStr = day.date;

              const td = document.createElement("td");
              td.className = "cell" + (isWeekend ? " weekend" : "");
              td.dataset.userId = u.id;
              if (u.is_non_staff && u.category === "student") {
                td.dataset.isStudentNonStaff = "true";
              }
              td.dataset.date = dateStr;

              // Get assignment
              const key = `${u.id}_${dateStr}`;
              const assignment = assignmentsMap.get(key);
              
              if (assignment) {
                td.dataset.assignmentId = assignment.id;
                const shift = shiftMap.get(assignment.shift_id);
                const override = (periodData?.status === "published" && assignment.id) ? overridesMap.get(assignment.id) : null;
                
                if (shift) {
                  console.log('[ROTA RENDER] Cell:', shift.code, 'assignmentId:', assignment.id, 'override:', override);
                  
                  // Wrap cell content in a container for positioning badges
                  const wrapper = document.createElement("div");
                  wrapper.style.position = "relative";
                  wrapper.style.width = "100%";
                  wrapper.style.height = "100%";
                  wrapper.style.display = "flex";
                  wrapper.style.flexDirection = "column";
                  wrapper.style.alignItems = "stretch";
                  wrapper.style.justifyContent = "flex-start";
                  wrapper.style.padding = "4px 2px";
                  wrapper.style.boxSizing = "border-box";
                  wrapper.style.rowGap = "2px";

                  const shiftBlock = document.createElement("div");
                  shiftBlock.className = "shift-block";
                  const codeSpan = document.createElement("span");
                  codeSpan.textContent = shift.code;
                  shiftBlock.appendChild(codeSpan);
                  wrapper.appendChild(shiftBlock);
                  
                  // Add badges container (for published periods only)
                  if (periodData?.status === "published" && assignment.id) {
                    const badges = document.createElement("div");
                    badges.style.position = "absolute";
                    badges.style.top = "2px";
                    badges.style.right = "2px";
                    badges.style.display = "flex";
                    badges.style.gap = "2px";
                    
                    // Override indicator (red dot) - show if ANY override field is set
                    if (override) {
                      const hasOverride = override.override_start_time || override.override_end_time || override.override_hours;
                      if (hasOverride) {
                        const overrideBadge = document.createElement("span");
                        overrideBadge.style.width = "6px";
                        overrideBadge.style.height = "6px";
                        overrideBadge.style.borderRadius = "50%";
                        overrideBadge.style.backgroundColor = "#dc2626";
                        overrideBadge.title = "Actual times/hours differ from scheduled";
                        badges.appendChild(overrideBadge);
                      }
                    }
                    
                    // Comment indicator (blue dot) - show if there are any comments for this assignment
                    const assignmentComments = commentsMap.get(assignment.id);
                    console.log('[BADGE DEBUG] Assignment ID:', assignment.id, 'Comments:', assignmentComments);
                    if (assignmentComments && assignmentComments.length > 0) {
                      // Filter comments based on visibility
                      const visibleComments = assignmentComments.filter(c => {
                        const visibility = c.comment_visibility || (c.is_admin_only ? 'admin_only' : 'all_staff');
                        if (visibility === 'admin_only') return window.currentUser?.is_admin;
                        if (visibility === 'all_staff') return true;
                        if (visibility === 'user_only') return window.currentUser?.id === userId;
                        return false;
                      });
                      console.log('[BADGE DEBUG] Visible comments:', visibleComments.length);
                      
                      if (visibleComments.length > 0) {
                        const commentBadge = document.createElement("span");
                        commentBadge.style.width = "6px";
                        commentBadge.style.height = "6px";
                        commentBadge.style.borderRadius = "50%";
                        commentBadge.style.backgroundColor = "#3b82f6";
                        commentBadge.title = "Has comments";
                        badges.appendChild(commentBadge);
                      }
                    }
                    
                    if (badges.children.length > 0) {
                      wrapper.appendChild(badges);
                    }
                  }
                  
                  td.appendChild(wrapper);

                  console.log('[ROTA] Applying shift metadata for', shift.code, ':', {
                    text_bold: shift.text_bold,
                    text_italic: shift.text_italic,
                    text_color: shift.text_color,
                    fill_color: shift.fill_color
                  });

                  // Apply shift metadata styling from catalogue
                  if (shift.text_bold) {
                    shiftBlock.style.fontWeight = "700";
                  }
                  if (shift.text_italic) {
                    shiftBlock.style.fontStyle = "italic";
                  }
                  if (shift.text_color) {
                    shiftBlock.style.color = shift.text_color;
                  }
                  if (shift.fill_color) {
                    td.style.backgroundColor = shift.fill_color; // color the whole cell like before
                  }

                  // Add request hint if exists (only if showRequests is enabled)
                  if (showRequests) {
                    const request = requestsMap.get(key);
                    if (request) {
                      const hint = document.createElement("div");
                      const requestValue = (request.value || "").trim();
                      const isImportant = request.important_rank && (request.important_rank === 1 || request.important_rank === 2);

                      hint.className = "request-hint";
                      hint.classList.add(isImportant ? "important" : "normal");
                      hint.textContent = isImportant
                        ? `${requestValue}${request.important_rank === 1 ? "¬π" : "¬≤"}`
                        : requestValue;

                      // Stack under the shift inside wrapper so it always shows beneath
                      wrapper.appendChild(hint);
                    }
                  }
                }
              } else {
                // Show requests only when toggle is on
                if (showRequests) {
                  const request = requestsMap.get(key);
                  if (request) {
                    const requestValue = request.value?.trim();
                    const isImportant = request.important_rank && (request.important_rank === 1 || request.important_rank === 2);

                    if (isImportant) {
                      // Important requests (O¬π/O¬≤) show in RED (not bold)
                      const superscript = request.important_rank === 1 ? "¬π" : "¬≤";
                      td.textContent = `${requestValue}${superscript}`;
                      td.style.color = "#e57373"; // paler red to mirror lighter gray emphasis
                    } else {
                      // Other requests show in faint gray italic
                      td.textContent = requestValue || "";
                      td.style.color = "#d1d5db";
                      td.style.fontStyle = "italic";
                    }
                  }
                }
              }

              tr.appendChild(td);
              // Event delegation handled by shift-editor.js
            });

            // Week separator (pattern target)
            const sep = document.createElement("td");
            sep.className = "week-sep";
            sep.dataset.userId = u.id;
            sep.dataset.weekStart = w.weekStart.toISOString().split('T')[0];

            // Pattern-first separator display
            // 1) If the user has an assigned pattern, prefer using it.
            //    - Anchored patterns: show `weekly_targets` aligned from the user's anchor.
            //    - Non-anchored patterns: show flexible baseline for that pattern (e.g., nurses baseline 3),
            //      and highlight weeks where assigned shifts exceed baseline.
            // 2) If no pattern is assigned, leave the separator blank (no assumptions).
            const upat = userPatterns.get(u.id);
            // Count only non-time-off shifts for the weekly count
            const assignedCount = w.days.reduce((acc, d) => {
              const assignment = assignmentsMap.get(`${u.id}_${d.date}`);
              if (!assignment) return acc;
              const shift = shiftMap.get(assignment.shift_id);
              // Only count if it's not a time-off shift
              if (shift && shift.is_time_off !== true) {
                return acc + 1;
              }
              return acc;
            }, 0);

            if (upat && upat.pattern_id) {
              const pat = patterns.get(upat.pattern_id);
              if (pat && pat.requires_anchor && upat.anchor_week_start_date && Array.isArray(pat.weekly_targets) && pat.weekly_targets.length) {
                // Anchored pattern: compute target based on cycle and anchor
                const weekStart = new Date(sep.dataset.weekStart);
                const anchorDateRaw = new Date(upat.anchor_week_start_date);
                const anchorDate = getWeekStart(anchorDateRaw);
                const weeksDiff = Math.floor((weekStart - anchorDate) / (7 * 24 * 60 * 60 * 1000));
                const cycleLen = pat.weekly_targets.length;
                const weekInCycle = ((weeksDiff % cycleLen) + cycleLen) % cycleLen;
                const target = pat.weekly_targets[weekInCycle];
                sep.textContent = String(target);
                const baseline = Math.min(...pat.weekly_targets);
                
                // Green when target is met, red when exceeded
                if (assignedCount >= target && assignedCount <= target) {
                  // Exactly meeting the target - green
                  sep.style.backgroundColor = "#c1ffc1";
                  sep.style.color = "#1a5c1a";
                  sep.style.fontWeight = "700";
                } else if (assignedCount > target || target > baseline) {
                  // Exceeding target OR higher than baseline week - red
                  sep.style.color = "#dc2626";
                  sep.style.fontWeight = "700";
                }
              } else {
                // Non-anchored or undefined weekly targets: treat as flexible
                // Use pattern weekly_targets (if present) to infer baseline, else fallback for nurses
                const baselineCandidates = Array.isArray(pat?.weekly_targets) && pat.weekly_targets.length ? pat.weekly_targets : [];
                let baseline = baselineCandidates.length ? Math.min(...baselineCandidates) : null;
                if (baseline == null && (u.role_id === 1 || u.role_id === 2)) baseline = 3; // nurse baseline if pattern implies flexibility
                // Display assigned count if any, otherwise show baseline where known
                sep.textContent = String(assignedCount > 0 ? assignedCount : (baseline ?? ""));
                
                // Green when target is met or exceeded, red when exceeded
                if (baseline != null) {
                  if (assignedCount >= baseline && assignedCount <= baseline) {
                    // Exactly meeting the target - green
                    sep.style.backgroundColor = "#c1ffc1";
                    sep.style.color = "#1a5c1a";
                    sep.style.fontWeight = "700";
                  } else if (assignedCount > baseline) {
                    // Exceeding the target - red
                    sep.style.color = "#dc2626";
                    sep.style.fontWeight = "700";
                  }
                }
              }
            } else {
              // No pattern assigned: do not apply role defaults; leave blank
              sep.textContent = "";
            }
            
            tr.appendChild(sep);
          });

          tbody.appendChild(tr);
        }
      }
      
      // Render totals at the end
      renderTotals();
    }

    // ========== GET ROLE GROUP KEY (resilient mapping) ==========
    function getRoleGroupKey(user) {
      // Deterministic mapping from role_id to canonical group key
      const roleId = user.role_id;
      if (roleId === 1) return "charge_nurse";
      if (roleId === 2) return "staff_nurse";
      if (roleId === 3) return "nursing_assistant";
      return "staff_nurse"; // fallback
    }

    // ========== GROUP USERS BY ROLE ==========
    function groupUsers(users) {
      const buckets = {
        charge_nurse: [],
        staff_nurse: [],
        nursing_assistant: [],
        students: []
      };

      users.forEach(u => {
        // Students go into separate group
        if (u.is_non_staff && u.category === 'student') {
          buckets.students.push(u);
        } else {
          // Bank/agency and regular staff grouped by role
          const groupKey = getRoleGroupKey(u);
          (buckets[groupKey] || buckets.staff_nurse).push(u);
        }
      });

      // Sort within buckets: primary by display_order (nulls last), secondary by name, and push non-staff to bottom within the bucket
      const sortBucket = (arr) => {
        arr.sort((a, b) => {
          // Push non-staff to bottom of each group
          if (a.is_non_staff && !b.is_non_staff) return 1;
          if (!a.is_non_staff && b.is_non_staff) return -1;

          const aOrder = a.display_order ?? 9999;
          const bOrder = b.display_order ?? 9999;
          if (aOrder !== bOrder) return aOrder - bOrder;
          return (a.name || "").localeCompare(b.name || "");
        });
      };

      sortBucket(buckets.charge_nurse);
      sortBucket(buckets.staff_nurse);
      sortBucket(buckets.nursing_assistant);
      sortBucket(buckets.students);

      const groups = [
        { title: "Charge Nurses", className: "section-cn", items: buckets.charge_nurse },
        { title: "Staff Nurses", className: "section-sn", items: buckets.staff_nurse }
      ];

      // Add students group if there are any (between Staff Nurses and Nursing Assistants)
      if (buckets.students.length > 0) {
        groups.push({ title: "Students", className: "section-students", items: buckets.students });
      }

      groups.push({ title: "Nursing Assistants", className: "section-na", items: buckets.nursing_assistant });

      return groups.filter(g => g.items.length > 0);
    }

    // ========== PATTERN WARNINGS ==========
    function generatePatternWarnings() {
      if (!window.currentUser?.is_admin) return;

      const warnings = [];

      allUsers.forEach(u => {
        const upat = userPatterns.get(u.id);
        if (!upat || !upat.pattern_id) return; // Only validate users with an assigned pattern

        const pat = patterns.get(upat.pattern_id);
        if (!pat) return;

        // Compute total assigned shifts in the 5-week period
        const totalAssigned = allWeeks.reduce((acc, w) => {
          const wkCount = w.days.reduce((c, d) => c + (assignmentsMap.get(`${u.id}_${d.date}`) ? 1 : 0), 0);
          return acc + wkCount;
        }, 0);

        // Determine expected total based on the assigned pattern
        let expectedTotal = null;
        if (pat.requires_anchor && upat.anchor_week_start_date && Array.isArray(pat.weekly_targets) && pat.weekly_targets.length) {
          // Anchored cycle: sum targets over the 5 weeks using anchor alignment
          expectedTotal = allWeeks.reduce((sum, w) => {
            const weekStart = getWeekStart(w.weekStart);
            const anchorDate = getWeekStart(new Date(upat.anchor_week_start_date));
            const weeksDiff = Math.floor((weekStart - anchorDate) / (7 * 24 * 60 * 60 * 1000));
            const cycleLen = pat.weekly_targets.length;
            const weekInCycle = ((weeksDiff % cycleLen) + cycleLen) % cycleLen;
            const target = Number(pat.weekly_targets[weekInCycle]) || 0;
            return sum + target;
          }, 0);
        } else {
          // Non-anchored or flexible patterns: infer baseline from weekly_targets if present
          const baselineCandidates = Array.isArray(pat.weekly_targets) && pat.weekly_targets.length ? pat.weekly_targets : [];
          const baseline = baselineCandidates.length ? Math.min(...baselineCandidates) : null;
          if (baseline != null) {
            expectedTotal = baseline * allWeeks.length; // baseline across 5 weeks
          }
          // Recognize nurse flexible 16 pattern explicitly by type
          if (String(pat.pattern_type || "").includes("nurse_flexible_16")) {
            expectedTotal = 16;
          }
          // If still unknown and user is CN/SN, default to 16 as flexible guidance
          if (expectedTotal == null && (u.role_id === 1 || u.role_id === 2)) {
            expectedTotal = 16; // CN/SN flexible pattern: total 16 across 5 weeks
          }
        }

        if (expectedTotal != null) {
          if (totalAssigned < expectedTotal) {
            warnings.push({ level: "error", user: u.name, msg: `Assigned ${totalAssigned} shifts; require ${expectedTotal}` });
          } else if (totalAssigned > expectedTotal) {
            warnings.push({ level: "warning", user: u.name, msg: `Assigned ${totalAssigned} (> ${expectedTotal})` });
          }
        }
      });

      if (warnings.length === 0) {
        document.getElementById("patternWarnings").classList.remove("visible");
        return;
      }

      const list = document.getElementById("warningsList");
      list.innerHTML = "";
      warnings.forEach(w => {
        const div = document.createElement("div");
        div.className = `warning-item ${w.level === "error" ? "error" : ""}`;
        div.textContent = `${w.user}: ${w.msg}`;
        list.appendChild(div);
      });

      document.getElementById("patternWarnings").classList.add("visible");
    }

    // ========== TOTALS ==========
    function renderTotals() {
      const table = document.getElementById("rota");
      const existingTfoot = table.querySelector("tfoot");
      if (existingTfoot) existingTfoot.remove();
      
      const tfoot = document.createElement("tfoot");
      const STAFFING_DEFAULTS = getStaffingDefaults();

      // Calculate staffing count: 0 for time-off, 1 for full shifts (12+ hrs), 0.5 for part shifts
      function getStaffingCount(shiftObj) {
        if (!shiftObj) return 0;
        // Time-off doesn't count toward staffing
        if (shiftObj.is_time_off === true) return 0;
        // Full day shifts (12+ hours) count as 1 person
        const hours = Number(shiftObj.hours_value) || 0;
        if (hours >= 12) return 1;
        // Part day shifts count as 0.5 person
        return 0.5;
      }

      // Check if shift is a time-off code (should be excluded from staffing totals)
      function isTimeOff(shiftObj) {
        if (!shiftObj) return false;
        return shiftObj.is_time_off === true;
      }

      function isNightShift(shiftCode) {
        if (!shiftCode) return false;
        return shiftCode.toUpperCase().trim() === "N";
      }

      // Add separator
      const separatorTr = document.createElement("tr");
      separatorTr.className = "totals-separator";
      const separatorTd = document.createElement("td");
      separatorTd.className = "name-col";
      separatorTd.colSpan = 1 + (allWeeks.length * 7) + allWeeks.length;
      separatorTd.style.background = "#e0e0e0";
      separatorTd.style.height = "8px";
      separatorTr.appendChild(separatorTd);
      tfoot.appendChild(separatorTr);

      // Row grouping: Day Shift, Night Shift
      const sections = [
        {
          sectionLabel: "Day Shift",
          rows: [
            { label: "Staff Nurse", roleIds: [1, 2], isNight: false, reqField: "day_sn_required" },
            { label: "Nursing Assistant", roleIds: [3], isNight: false, reqField: "day_na_required" }
          ]
        },
        {
          sectionLabel: "Night Shift",
          rows: [
            { label: "Staff Nurse", roleIds: [1, 2], isNight: true, reqField: "night_sn_required" },
            { label: "Nursing Assistant", roleIds: [3], isNight: true, reqField: "night_na_required" }
          ]
        }
      ];

      sections.forEach(section => {
        // Section header
        const sectionTr = document.createElement("tr");
        sectionTr.className = "totals-section-row";
        const sectionTd = document.createElement("td");
        sectionTd.className = "name-col";
        sectionTd.colSpan = 1 + (allWeeks.length * 7) + allWeeks.length;
        sectionTd.textContent = section.sectionLabel;
        sectionTr.appendChild(sectionTd);
        tfoot.appendChild(sectionTr);

        // Each row in section
        section.rows.forEach(rowDef => {
          const tr = document.createElement("tr");
          tr.className = "totals-row";

          const labelTd = document.createElement("td");
          labelTd.className = "name-col";
          labelTd.textContent = rowDef.label;
          labelTd.style.fontWeight = "600";
          labelTd.style.paddingLeft = "16px";
          tr.appendChild(labelTd);

          allWeeks.forEach(w => {
            w.days.forEach(day => {
              const cell = document.createElement("td");
              cell.className = "totals-cell";

              // Calculate total for this role and shift type
              let total = 0;
              allUsers
                .filter(u => rowDef.roleIds.includes(u.role_id))
                .filter(u => !u.is_non_staff || u.counts_towards_staffing)
                .forEach(u => {
                  const assignment = assignmentsMap.get(`${u.id}_${day.date}`);
                  if (assignment) {
                    const shift = shiftMap.get(assignment.shift_id);
                    if (shift) {
                      const shiftNight = isNightShift(shift.code);
                      if (shiftNight === rowDef.isNight) {
                        total += getStaffingCount(shift);
                      }
                    }
                  }
                });

              // Get required (from defaults)
              const required = STAFFING_DEFAULTS[rowDef.reqField];

              // Display total (handle decimals for part-day shifts)
              const displayValue = total % 1 === 0 ? total.toString() : total.toFixed(1);
              cell.textContent = displayValue;

              // Softer orange if short
              if (total < required) {
                cell.style.backgroundColor = "#ffc599";
                cell.style.color = "#5d3e1f";
                cell.style.fontWeight = "600";
              }

              cell.style.textAlign = "center";
              tr.appendChild(cell);
            });

            // Week separator
            const sep = document.createElement("td");
            sep.className = "week-sep";
            tr.appendChild(sep);
          });

          tfoot.appendChild(tr);
        });
      });

      table.appendChild(tfoot);
    }

    // ========== DISPLAY & EVENT HANDLERS ==========

    function describeAssignment(userId, date) {
      const assignment = assignmentsMap.get(`${userId}_${date}`);
      if (!assignment) return { text: "No planned shift", shift: null };
      const shift = shiftMap.get(assignment.shift_id);
      if (!shift) return { text: "Planned shift", shift: null };
      const label = shift.label ? ` ${shift.label}` : "";
      return { text: `${shift.code}${label}`, shift };
    }

    function openPublishedDetails({ userId, date }) {
      if (!periodData || periodData.status !== "published") return;
      lastPublishedCell = { userId, date };
      // Expose as activeCell so swap-functions can operate
      window.activeCell = { userId, date };

      const modal = document.getElementById("publishedDetailsModal");
      const subtitleEl = document.getElementById("publishedDetailsSubtitle");
      const codeEl = document.getElementById("publishedShiftCode");
      const nameEl = document.getElementById("publishedShiftName");
      const scheduledTimesRow = document.getElementById("scheduledTimesRow");
      const scheduledTimes = document.getElementById("scheduledTimes");
      const actualTimesRow = document.getElementById("actualTimesRow");
      const actualTimes = document.getElementById("actualTimes");
      const hoursEl = document.getElementById("publishedShiftHours");
      const hoursRow = document.getElementById("hoursRow");
      const restDayLabel = document.getElementById("restDayLabel");
      const commentDisplay = document.getElementById("commentDisplay");
      const commentText = document.getElementById("commentText");

      const btnChange = document.getElementById("publishedChangeBtn");
      const btnComments = document.getElementById("publishedCommentsBtn");
      const btnSwap = document.getElementById("publishedSwapBtn");
      const btnHistory = document.getElementById("publishedHistoryBtn");

      const user = allUsers.find(u => u.id === userId);
      const assignmentInfo = describeAssignment(userId, date);
      const assignment = assignmentsMap.get(`${userId}_${date}`);
      const override = assignment?.id ? overridesMap.get(assignment.id) : null;

      const dateStr = new Date(date).toLocaleDateString("en-GB", { weekday: "short", day: "numeric", month: "short", year: "numeric" });
      subtitleEl.textContent = `${user?.name || "Staff"} ‚Äî ${dateStr}`;
      
      // Build shift display with metadata styling
      if (assignmentInfo.shift) {
        const s = assignmentInfo.shift;
        
        // Apply code with metadata styling
        codeEl.textContent = s.code || '';
        if (s.fill_color) {
          codeEl.style.backgroundColor = s.fill_color;
        }
        if (s.text_color) {
          codeEl.style.color = s.text_color;
        }
        
        // Show label as shift name
        nameEl.textContent = s.label ? ` ${s.label}` : '';
        
        // Build time display with override support
        if (s.start_time && s.end_time) {
          restDayLabel.style.display = 'none';
          
          if (override && override.override_start_time && override.override_end_time) {
            // Show both scheduled and actual
            scheduledTimes.textContent = `${s.start_time}‚Äì${s.end_time}`;
            scheduledTimesRow.style.display = '';
            actualTimes.textContent = `${override.override_start_time}‚Äì${override.override_end_time}`;
            actualTimesRow.style.display = '';
          } else {
            // Show only scheduled
            scheduledTimes.textContent = `${s.start_time}‚Äì${s.end_time}`;
            scheduledTimesRow.style.display = '';
            actualTimesRow.style.display = 'none';
          }
        } else {
          scheduledTimesRow.style.display = 'none';
          actualTimesRow.style.display = 'none';
          restDayLabel.style.display = '';
        }
        
        // Show hours (override takes precedence)
        const displayHours = override?.override_hours ?? s.hours_value;
        if (displayHours) {
          hoursEl.textContent = `${displayHours} hours`;
          if (override?.override_hours) {
            hoursEl.style.color = '#dc2626';
            hoursEl.style.fontWeight = '600';
          } else {
            hoursEl.style.color = '';
            hoursEl.style.fontWeight = '';
          }
          hoursRow.style.display = '';
        } else {
          hoursRow.style.display = 'none';
        }
      } else {
        codeEl.textContent = assignmentInfo.text;
        codeEl.style.backgroundColor = '';
        codeEl.style.color = '';
        nameEl.textContent = '';
        scheduledTimesRow.style.display = 'none';
        actualTimesRow.style.display = 'none';
        hoursRow.style.display = 'none';
      }
      
      // Show comment if exists AND user has permission to see it
      const isAdmin = !!window.currentUser?.is_admin;
      let canSeeComment = false;
      
      if (override?.comment) {
        const visibility = override.comment_visibility || 'admin_only';
        if (visibility === 'admin_only') {
          canSeeComment = isAdmin;
        } else if (visibility === 'all_staff') {
          canSeeComment = true;
        } else if (visibility === 'user_only') {
          canSeeComment = (window.currentUser?.id === userId);
        }
      }
      
      if (override?.comment && canSeeComment) {
        commentText.textContent = override.comment;
        commentDisplay.style.display = '';
      } else {
        commentDisplay.style.display = 'none';
      }

      const canHistory = isAdmin || window.PermissionsModule?.hasPermission("rota.view_history");
      const isOwnCell = (window.currentUser?.id === userId);

      if (btnChange) btnChange.style.display = canEditPublished ? "" : "none";
      // View comments always visible; comments filter by visibility flag internally
      if (btnComments) btnComments.style.display = "";
      // Swap shift: admin can swap any shift; staff can only swap their own
      if (btnSwap) btnSwap.style.display = (isAdmin || isOwnCell) ? "" : "none";
      if (btnHistory) btnHistory.style.display = canHistory ? "" : "none";

      modal.setAttribute("aria-hidden", "false");
    }

    function closePublishedDetails() {
      const modal = document.getElementById("publishedDetailsModal");
      if (modal) modal.setAttribute("aria-hidden", "true");
    }

    function handlePublishedChange() {
      const cell = window.lastPublishedCell || lastPublishedCell;
      if (!cell) return;
      if (!canEditPublished) {
        alert("You don't have permission to edit published rotas.");
        return;
      }
      closePublishedDetails();
      if (typeof window.openShiftPickerForPublished === "function") {
        window.openShiftPickerForPublished(cell.userId, cell.date);
      } else {
        alert("Editor not ready yet. Try again.");
      }
    }

    function handlePublishedOverride() {
      const cell = window.lastPublishedCell || lastPublishedCell;
      if (!cell) return;
      if (!canEditPublished) {
        alert("You don't have permission to edit published rotas.");
        return;
      }
      closePublishedDetails();
      openOverrideAmendmentModal(cell.userId, cell.date);
    }

    function openOverrideAmendmentModal(userId, date) {
      try {
        const backdrop = document.getElementById("overrideAmendmentModalBackdrop");
        const title = document.getElementById("overrideAmendmentTitle");
        const subtitle = document.getElementById("overrideAmendmentSubtitle");
        const startTimeInput = document.getElementById("amendmentStartTime");
        const endTimeInput = document.getElementById("amendmentEndTime");
        const hoursInput = document.getElementById("amendmentHours");
        const reasonInput = document.getElementById("amendmentReason");
        
        if (!backdrop) {
          console.error("[OVERRIDE AMENDMENT] Modal backdrop not found");
          alert("Modal not initialized");
          return;
        }
        
        const assignment = (typeof getAssignment === "function"
          ? getAssignment(userId, date)
          : window.getAssignment?.(userId, date))
          || assignmentsMap?.get(`${userId}_${date}`);
        const user = allUsers?.find(u => u.id === userId);
        const dateObj = new Date(date);
        
        console.log("[OVERRIDE AMENDMENT] Opening modal for assignment:", assignment);
        
        if (title) title.textContent = user ? `${user.name} - Override Shift Times` : "Override Shift Times";
        if (subtitle) subtitle.textContent = dateObj.toLocaleDateString("en-GB", { weekday: "short", day: "numeric", month: "short", year: "numeric" });
        
        // Load existing override if any
        if (assignment?.id) {
          const override = overridesMap?.get(assignment.id);
          console.log("[OVERRIDE AMENDMENT] Found override:", override);
          if (override) {
            if (startTimeInput) startTimeInput.value = override.override_start_time || "";
            if (endTimeInput) endTimeInput.value = override.override_end_time || "";
            if (hoursInput) hoursInput.value = override.override_hours || "";
            if (reasonInput) reasonInput.value = override.comment || "";
          } else {
            // No override yet ‚Äì prefill with scheduled shift times to make entry quicker
            const shift = assignment.shift_id ? shiftMap?.get(assignment.shift_id) : null;
            const start = shift?.start_time ? shift.start_time.slice(0,5) : "";
            const end = shift?.end_time ? shift.end_time.slice(0,5) : "";
            if (startTimeInput) startTimeInput.value = start;
            if (endTimeInput) endTimeInput.value = end;
            if (hoursInput) {
              if (shift?.hours != null) {
                hoursInput.value = shift.hours;
              } else if (start && end) {
                const [sh, sm] = start.split(":").map(Number);
                const [eh, em] = end.split(":").map(Number);
                let mins = (eh*60 + em) - (sh*60 + sm);
                if (mins < 0) mins += 24*60; // overnight safeguard
                hoursInput.value = Math.round((mins/60)*4)/4;
              } else {
                hoursInput.value = "";
              }
            }
            if (reasonInput) reasonInput.value = "";
          }
        }
        
        // Store context for save
        window.overrideAmendmentContext = { userId, date, assignmentId: assignment?.id };
        
        console.log("[OVERRIDE AMENDMENT] Opening modal, context:", window.overrideAmendmentContext);
        backdrop.setAttribute("aria-hidden", "false");
      } catch (err) {
        console.error("[OVERRIDE AMENDMENT] Error opening modal:", err);
        alert("Error opening override modal. Check console.");
      }
    }

    // Keep hours in sync if start/end change in the override amendment modal
    function attachAmendmentHourAutoCalc() {
      const startInput = document.getElementById("amendmentStartTime");
      const endInput = document.getElementById("amendmentEndTime");
      const hoursInput = document.getElementById("amendmentHours");
      if (!startInput || !endInput || !hoursInput) return;

      const recompute = () => {
        if (!startInput.value || !endInput.value) return;
        const [sh, sm] = startInput.value.split(":").map(Number);
        const [eh, em] = endInput.value.split(":").map(Number);
        let minutes = (eh * 60 + em) - (sh * 60 + sm);
        if (minutes < 0) minutes += 24 * 60; // handle overnight
        const hrs = Math.round((minutes / 60) * 4) / 4; // nearest 0.25
        hoursInput.value = hrs;
      };

      startInput.addEventListener("change", recompute);
      endInput.addEventListener("change", recompute);
    }

    function closeOverrideAmendmentModal() {
      const backdrop = document.getElementById("overrideAmendmentModalBackdrop");
      if (backdrop) backdrop.setAttribute("aria-hidden", "true");
      window.overrideAmendmentContext = null;
    }

    function saveOverrideAmendment() {
      const context = window.overrideAmendmentContext;
      if (!context) {
        alert("No amendment context.");
        return;
      }

      const startTime = document.getElementById("amendmentStartTime")?.value || "";
      const endTime = document.getElementById("amendmentEndTime")?.value || "";
      const hours = parseFloat(document.getElementById("amendmentHours")?.value || 0);
      const reason = document.getElementById("amendmentReason")?.value || "";

      if (!startTime || !endTime) {
        alert("Please enter both start and end times.");
        return;
      }

      // Call the direct save function
      console.log("[OVERRIDE AMENDMENT] Calling saveOverrideAmendmentDirect with:", {
        assignmentId: context.assignmentId,
        startTime,
        endTime,
        hours,
        reason
      });
      window.saveOverrideAmendmentDirect(context.assignmentId, startTime, endTime, hours, reason);
    }

    // Simplified implementation: direct Supabase update
    window.saveOverrideAmendmentDirect = async function(assignmentId, startTime, endTime, hours, reason) {
      console.log("[OVERRIDE AMENDMENT DIRECT] Received parameters:", {
        assignmentId,
        assignmentIdType: typeof assignmentId,
        startTime,
        endTime,
        hours,
        reason
      });
      try {
        if (!window.supabaseClient) {
          alert("Database client not initialized.");
          return;
        }

        const { data, error } = await window.supabaseClient
          .from("rota_assignment_overrides")
          .upsert({
            rota_assignment_id: assignmentId,
            override_start_time: startTime,
            override_end_time: endTime,
            override_hours: hours,
            comment: reason,
            updated_at: new Date().toISOString()
          }, {
            onConflict: 'rota_assignment_id'
          })
          .select();

        if (error) {
          console.error("[OVERRIDE AMENDMENT] Error:", error);
          alert(`Failed to save override: ${error.message}`);
          return;
        }

        console.log("[OVERRIDE AMENDMENT] Override saved successfully", data);
        
        // Update overridesMap with the new/updated override
        if (data && data[0]) {
          overridesMap.set(assignmentId, data[0]);
        }
        
        alert("Override amended successfully.");
        closeOverrideAmendmentModal();
        
        // Reload the rota to show changes
        if (typeof renderRota === "function") {
          renderRota();
        }
      } catch (err) {
        console.error("[OVERRIDE AMENDMENT] Unexpected error:", err);
        alert("Unexpected error saving override.");
      }
    };

    function handlePublishedHistory() {
      const cell = window.lastPublishedCell || lastPublishedCell;
      if (!cell) return;
      
      if (window.AssignmentHistoryModule?.loadAssignmentHistory) {
        closePublishedDetails();
        window.AssignmentHistoryModule.loadAssignmentHistory(cell.userId, cell.date);
      } else {
        alert("History module not loaded.");
      }
    }

    async function handlePublishedSwap() {
      const cell = window.lastPublishedCell || lastPublishedCell;
      if (!cell) return;
      if (!window.currentUser) return;

      const { userId, date } = cell;
      // Allow all logged-in staff; admins can still act. Permission gate removed for staff.
      const isAdmin = !!window.currentUser.is_admin;

      // Get initiator's user data and shift
      const initiatorUser = allUsers.find(u => u.id === userId);
      const initiatorAssignment = assignmentsMap.get(`${userId}_${date}`);
      const initiatorShift = shiftMap.get(initiatorAssignment?.shift_id);
      
      if (!initiatorUser || !initiatorShift) {
        alert("Could not load your shift details.");
        return;
      }

      const initiatorRoleId = initiatorUser.role_id;
      const initiatorDate = new Date(date);
      const initiatorWeekStart = new Date(initiatorDate);
      initiatorWeekStart.setDate(initiatorDate.getDate() - initiatorDate.getDay() + 1); // Monday

      // Helper: check if two dates are in the same week
      function isSameWeek(date1Str, date2Str) {
        const d1 = new Date(date1Str);
        const d2 = new Date(date2Str);
        const week1 = new Date(d1);
        week1.setDate(d1.getDate() - d1.getDay() + 1);
        const week2 = new Date(d2);
        week2.setDate(d2.getDate() - d2.getDay() + 1);
        return week1.getTime() === week2.getTime();
      }

      // Get list of other staff with shifts on other dates
      const candidates = allUsers
        .filter(u => u.id !== userId) // Remove is_active check - it's not in the users selection
        .map(u => ({
          id: u.id,
          name: u.name,
          role_id: u.role_id,
          dates: Array.from(assignmentsMap.entries())
            .filter(([key, asn]) => {
              if (!key.startsWith(u.id + "_")) return false;
              const shift = shiftMap.get(asn.shift_id);
              if (!shift || shift.code === "O") return false;

              const shiftDate = key.split("_")[1];
              
              // Nursing Assistants (role_id 3) can only swap within same week and with same role
              if (initiatorRoleId === 3 || u.role_id === 3) {
                // Must be same week
                if (!isSameWeek(date, shiftDate)) return false;
                
                // Both must be Nursing Assistants
                if (initiatorRoleId !== 3 || u.role_id !== 3) return false;
              }

              return true;
            })
            .map(([key, asn]) => {
              const d = key.split("_")[1];
              const shift = shiftMap.get(asn.shift_id);
              const code = shift?.code || "?";
              return {
                date: d,
                code: code,
                label: new Date(d).toLocaleDateString("en-GB", { weekday: "short", day: "numeric", month: "short" }) + ` (${code})`
              };
            })
        }))
        .filter(c => c.dates.length > 0);

      if (!candidates.length) {
        alert("No compatible staff with shifts to swap with.");
        return;
      }

      // Show swap picker modal
      const swapModal = document.getElementById("shiftSwapModal");
      if (!swapModal) {
        alert("Swap interface not ready.");
        return;
      }

      // Display current shift info
      const currentShift = shiftMap.get(assignmentsMap.get(`${userId}_${date}`)?.shift_id);
      const currentCode = currentShift?.code || "?";
      const dateStr = new Date(date).toLocaleDateString("en-GB", { weekday: "short", day: "numeric", month: "short" });
      document.getElementById("swapYourShift").textContent = `${currentCode} on ${dateStr}`;

      // Store context for swap submission
      window.swapInitiatorContext = { userId, date, isAdmin };
      window.swapCandidates = candidates;

      // Populate peer dropdown
      const peerSelect = document.getElementById("swapPeerSelect");
      peerSelect.innerHTML = `<option value="">Select staff member...</option>` +
        candidates.map(c => `<option value="${c.id}">${c.name}</option>`).join("");

      // Clear date dropdown
      const dateSelect = document.getElementById("swapDateSelect");
      dateSelect.innerHTML = `<option value="">Select their shift date...</option>`;
      dateSelect.disabled = true;

      // Wire peer change event
      peerSelect.onchange = () => {
        const peerId = peerSelect.value;
        if (!peerId) {
          dateSelect.innerHTML = `<option value="">Select their shift date...</option>`;
          dateSelect.disabled = true;
          return;
        }
        const peer = candidates.find(c => c.id === peerId);
        if (peer) {
          dateSelect.innerHTML = `<option value="">Select their shift date...</option>` +
            peer.dates.map(d => `<option value="${d.date}">${d.label}</option>`).join("");
          dateSelect.disabled = false;
        }
      };

      swapModal.setAttribute("aria-hidden", "false");
      closePublishedDetails();
    }

    async function handlePublishedComments() {
      if (!lastPublishedCell) return;
      
      const { userId, date } = lastPublishedCell;
      const user = allUsers.find(u => u.id === userId);
      const assignment = assignmentsMap.get(`${userId}_${date}`);
      
      console.log("[COMMENTS DEBUG] lastPublishedCell:", lastPublishedCell);
      console.log("[COMMENTS DEBUG] Looking up assignment for key:", `${userId}_${date}`);
      console.log("[COMMENTS DEBUG] Found assignment:", assignment);
      
      if (!assignment) {
        alert("No assignment for this date.");
        return;
      }
      
      // Load comments for this assignment
      console.log("[COMMENTS DEBUG] Loading comments for assignment ID:", assignment.id);
      const { data: comments, error } = await supabaseClient
        .from("rota_assignment_comments")
        .select("*")
        .eq("rota_assignment_id", assignment.id)
        .order("created_at", { ascending: false });
      
      if (error) {
        console.error("Error loading comments:", error);
        alert("Failed to load comments.");
        return;
      }
      
      console.log("[COMMENTS DEBUG] Loaded comments:", comments);
      
      // Filter comments based on visibility
      const isAdmin = window.currentUser?.is_admin;
      const visibleComments = (comments || []).filter(c => {
        const visibility = c.comment_visibility || (c.is_admin_only ? 'admin_only' : 'all_staff');
        if (visibility === 'admin_only') return isAdmin;
        if (visibility === 'all_staff') return true;
        if (visibility === 'user_only') return window.currentUser?.id === userId;
        return false;
      });
      
      // Populate modal
      const modal = document.getElementById("commentsModalBackdrop");
      const subtitle = document.getElementById("commentsModalSubtitle");
      const commentsList = document.getElementById("commentsList");
      const newCommentText = document.getElementById("newCommentText");
      const isAdminCheckbox = document.getElementById("isAdminOnlyCheckbox");
      const addBtn = document.getElementById("addCommentBtn");
      
      const dateStr = new Date(date).toLocaleDateString("en-GB", { weekday: "short", day: "numeric", month: "short", year: "numeric" });
      subtitle.textContent = `${user?.name || "Staff"} ‚Äî ${dateStr}`;
      
      // Render comments
      commentsList.innerHTML = "";
      if (visibleComments.length === 0) {
        const empty = document.createElement("p");
        empty.style.color = "#9ca3af";
        empty.style.fontSize = "13px";
        empty.textContent = "No comments yet.";
        commentsList.appendChild(empty);
      } else {
        visibleComments.forEach(comment => {
          const div = document.createElement("div");
          div.style.padding = "12px";
          div.style.borderLeft = "3px solid #3b82f6";
          div.style.backgroundColor = "#f0f9ff";
          div.style.borderRadius = "4px";
          
          // User info
          const header = document.createElement("div");
          header.style.fontSize = "12px";
          header.style.color = "#64748b";
          header.style.marginBottom = "6px";
          header.style.display = "flex";
          header.style.justifyContent = "space-between";
          header.style.alignItems = "center";
          
          const userTime = document.createElement("span");
          const createdUser = allUsers.find(u => u.id === comment.created_by);
          console.log("[COMMENTS RENDER] comment.created_by:", comment.created_by, "createdUser found:", createdUser, "allUsers:", allUsers);
          const createdAt = new Date(comment.created_at).toLocaleString("en-GB");
          userTime.textContent = `${createdUser?.name || "Unknown"} ‚Ä¢ ${createdAt}`;
          header.appendChild(userTime);
          
          // Show visibility badge
          const visibility = comment.comment_visibility || (comment.is_admin_only ? 'admin_only' : 'all_staff');
          if (visibility !== 'all_staff') {
            const badge = document.createElement("span");
            badge.style.fontSize = "11px";
            badge.style.fontWeight = "600";
            if (visibility === 'admin_only') {
              badge.style.color = "#dc2626";
              badge.textContent = "ADMIN ONLY";
            } else if (visibility === 'user_only') {
              badge.style.color = "#2563eb";
              badge.textContent = "USER ONLY";
            }
            header.appendChild(badge);
          }
          
          div.appendChild(header);
          
          // Comment text
          const text = document.createElement("div");
          text.style.fontSize = "13px";
          text.style.color = "#0f172a";
          text.style.whiteSpace = "pre-wrap";
          text.textContent = comment.comment;
          div.appendChild(text);
          
          commentsList.appendChild(div);
        });
      }
      
      // Clear form
      newCommentText.value = "";
      const visibilityDropdown = document.getElementById("commentVisibilityDropdown");
      if (visibilityDropdown) visibilityDropdown.value = 'all_staff';
      
      // Store current cell for add handler
      window._commentsModalCell = { userId, assignmentId: assignment.id, date };
      
      // Clear old listeners and attach new
      addBtn.onclick = null;
      addBtn.addEventListener("click", async () => {
        const commentText = newCommentText.value.trim();
        if (!commentText) {
          alert("Comment cannot be empty.");
          return;
        }
        
        console.log("[COMMENTS] window.currentUser:", window.currentUser);
        console.log("[COMMENTS] window.currentUser?.id:", window.currentUser?.id);
        
        const visibilityDropdown = document.getElementById("commentVisibilityDropdown");
        const commentVisibility = visibilityDropdown?.value || 'all_staff';
        
        console.log("[COMMENTS] Saving comment:", { assignmentId: assignment.id, commentText, commentVisibility, userId: window.currentUser?.id });
        
        const { error: insertErr, data: newComment } = await supabaseClient
          .from("rota_assignment_comments")
          .insert([{
            rota_assignment_id: assignment.id,
            comment: commentText,
            comment_visibility: commentVisibility,
            created_by: window.currentUser?.id,
            updated_by: window.currentUser?.id
          }])
          .select()
          .single();
        
        if (insertErr) {
          console.error("[COMMENTS] Error saving:", insertErr);
          alert("Failed to save comment.");
          return;
        }
        
        console.log("[COMMENTS] Comment saved successfully");
        
        // Update commentsMap with the new comment
        if (newComment) {
          const existing = commentsMap.get(assignment.id) || [];
          existing.push(newComment);
          commentsMap.set(assignment.id, existing);
          renderRota(); // Re-render to show blue dot
        }
        
        // Reload comments in modal
        await handlePublishedComments();
      });
      
      modal.setAttribute("aria-hidden", "false");
    }


    function displayPeriodStatus(period) {
      const status = document.getElementById("periodStatus");
      const badge = document.getElementById("statusBadge");
      const text = document.getElementById("statusText");

      // Normalize status (treat null/unknown as draft)
      const rawStatus = (period?.status || "draft").toString().toLowerCase();
      const isPublished = rawStatus === "published";

      badge.textContent = isPublished ? "Published" : "Draft";
      badge.className = `status-badge status-${isPublished ? "published" : "draft"}`;
      
      // Format dates
      const start = new Date(period.start_date).toLocaleDateString('en-GB', { day: 'numeric', month: 'short', year: 'numeric' });
      const end = new Date(period.end_date).toLocaleDateString('en-GB', { day: 'numeric', month: 'short', year: 'numeric' });
      text.textContent = `${period.label || 'Period'} (${start} - ${end})`;

      status.style.display = "flex";
      
      // Show publish/unpublish buttons based on status and permission
      const publishBtn = document.getElementById("publishBtn");
      const unpublishBtn = document.getElementById("unpublishBtn");
      const canPublish = window.PermissionsModule.hasPermission("rota.publish");
      if (canPublish) {
        publishBtn.style.display = isPublished ? "none" : "inline-block";
        unpublishBtn.style.display = isPublished ? "inline-block" : "none";
      } else {
        publishBtn.style.display = "none";
        unpublishBtn.style.display = "none";
      }
    }

    function updateEditingControls(period) {
      const toggleEditingBtn = document.getElementById("toggleEditingBtn");
      const addNsBtn = document.getElementById("addNonStaffBtn");
      const metadataDisplay = document.getElementById("metadataDisplay");
      const publishedBanner = document.getElementById("publishedEditBanner");
      const isPublished = period?.status === "published";
      const canEditCurrent = isPublished ? canEditPublished : canEditDraft;

      if (toggleEditingBtn) {
        if (isPublished) {
          // No global toggle in published mode; actions go through Change Shift
          toggleEditingBtn.style.display = "none";
        } else {
          toggleEditingBtn.style.display = canEditCurrent ? "inline-block" : "none";
          toggleEditingBtn.textContent = "üîí Locked";
          toggleEditingBtn.classList.remove("primary");
        }
      }

      // Show Add Non-Staff only in published mode (non-staff are post-publish only)
      if (addNsBtn) {
        const isMentor = window.PermissionsModule?.hasPermission?.('non_staff.edit_student_shifts');
        const canShowNonStaff = isPublished && (window.currentUser?.is_admin || isMentor);
        addNsBtn.style.display = canShowNonStaff ? "inline-block" : "none";
      }

      // Configure shift editor context (falls back silently if shift-editor not ready yet)
      if (typeof window.setShiftEditContext === "function") {
        if (isPublished) {
          window.setShiftEditContext({
            permissionKey: "rota.edit_published",
            contextLabel: "published rota",
            mode: "published",
            lockedLabelText: "üîí Published Locked",
            unlockedLabelText: "üîì Published Editing",
            shiftFilter: (shift) => shift?.allow_post_publish === true
          });
          currentEditContext = "published";
          window.currentEditContext = currentEditContext;
        } else {
          window.setShiftEditContext({
            permissionKey: "rota.edit_draft",
            contextLabel: "draft rota",
            mode: "draft",
            lockedLabelText: "üîí Locked",
            unlockedLabelText: "üîì Editing",
            shiftFilter: (shift) => shift?.allow_draft !== false
          });
          currentEditContext = "draft";
          window.currentEditContext = currentEditContext;
        }
      }

      if (typeof window.resetEditingLock === "function") {
        window.resetEditingLock();
      }

      // Banner for draft editing only
      if (metadataDisplay) metadataDisplay.style.display = "none";
    }

    async function publishPeriod() {
      if (!window.PermissionsModule.hasPermission("rota.publish")) {
        alert("You don't have permission to publish periods.");
        return;
      }
      
      if (!periodData) {
        alert("No period selected.");
        return;
      }

      if (!periodData.id) {
        alert("Period ID missing; reload and try again.");
        return;
      }
      
      const confirmed = confirm(
        `Publish ${periodData.label}?\n\n` +
        `This will make the rota visible to all staff. Draft assignments will become final.\n\n` +
        `Are you sure you want to publish?`
      );
      
      if (!confirmed) return;
      
      try {
        const nowIso = new Date().toISOString();
        const publishedBy = window.currentUser?.id || null;

        // Update period status
        const { error: updErr } = await supabaseClient
          .from("rota_periods")
          .update({
            status: "published",
            published_at: nowIso,
            published_by: publishedBy,
            published_version: (periodData.published_version || 0) + 1
          })
          .eq("id", periodData.id);

        if (updErr) throw updErr;

        // Update all rota_assignments for this period from draft to published
        const { error: assignErr } = await supabaseClient
          .from("rota_assignments")
          .update({ status: "published" })
          .gte("date", periodData.start_date)
          .lte("date", periodData.end_date)
          .eq("status", "draft");

        if (assignErr) {
          console.error("Error updating assignment status:", assignErr);
          // Don't throw - period is already published, this is just cleanup
        }

        // Create history records for all assignments at publication time
        // Note: Only create ONE history record per unique user/date combination to avoid duplicates
        try {
          console.log('[PUBLISH] Creating history records for assignments in date range:', periodData.start_date, 'to', periodData.end_date);
          
          const { data: assignments, error: assignFetchErr } = await supabaseClient
            .from("rota_assignments")
            .select("id, user_id, period_non_staff_id, date, shift_id, shifts!shift_id(code), created_at")
            .gte("date", periodData.start_date)
            .lte("date", periodData.end_date)
            .order("date, created_at", { ascending: true });

          console.log('[PUBLISH] Fetch assignments result:', { assignFetchErr, assignmentCount: assignments?.length });
          
          if (assignFetchErr) throw assignFetchErr;

          if (assignments && assignments.length > 0) {
            console.log('[PUBLISH] Sample assignment:', assignments[0]);
            
            // Remove duplicates by keeping only the most recent assignment per user/date
            const seenUserDates = new Set();
            const uniqueAssignments = [];
            
            // Process in reverse chronological order and keep only the latest per user/date
            for (let i = assignments.length - 1; i >= 0; i--) {
              const a = assignments[i];
              const key = `${a.user_id || a.period_non_staff_id}_${a.date}`;
              if (!seenUserDates.has(key)) {
                seenUserDates.add(key);
                uniqueAssignments.push(a);
              } else {
                console.log('[PUBLISH] Skipping duplicate assignment for', key);
              }
            }
            
            const historyRecords = uniqueAssignments
              .filter(a => a.shifts) // Only include if shift data exists
              .map(a => ({
                rota_assignment_id: a.id,
                user_id: a.user_id,
                period_non_staff_id: a.period_non_staff_id,
                date: a.date,
                old_shift_id: null,
                old_shift_code: null,
                new_shift_id: a.shift_id,
                new_shift_code: a.shifts.code,
                change_reason: 'Rota published',
                changed_by: publishedBy,
                changed_by_name: window.currentUser?.name || "System",
                changed_at: nowIso
              }));

            console.log('[PUBLISH] Created', historyRecords.length, 'history records from', assignments.length, 'assignments (', seenUserDates.size, 'unique user/dates)');
            
            if (historyRecords.length > 0) {
              const { error: histErr } = await supabaseClient
                .from("rota_assignment_history")
                .insert(historyRecords);

              console.log('[PUBLISH] History insert result:', { histErr, recordCount: historyRecords.length });

              if (histErr) {
                console.error("Error creating history records:", histErr);
                // Don't throw - publication was successful, just history recording failed
              } else {
                console.log('[PUBLISH] Successfully created history records');
              }
            }
          }
        } catch (e) {
          console.error("Error recording publication history:", e);
          // Don't throw - publication was successful, just history recording failed
        }

        // Re-fetch to confirm state and update UI
        const { data: refreshed, error: fetchErr } = await supabaseClient
          .from("rota_periods")
          .select("*")
          .eq("id", periodData.id)
          .maybeSingle();

        if (fetchErr) throw fetchErr;
        if (!refreshed) throw new Error("Publish succeeded but refetch returned no row (check RLS)");

        periodData = refreshed;
        displayPeriodStatus(periodData);
        updateEditingControls(periodData);
        
        // Reload the rota to show published assignments
        await loadPeriod(periodData.id);
        
        alert("Period published successfully!");
      } catch (e) {
        console.error("Error publishing period:", e);
        alert("Failed to publish period: " + e.message);
      }
    }

    async function unpublishPeriod() {
      if (!window.PermissionsModule.hasPermission("rota.publish")) {
        alert("You don't have permission to unpublish periods.");
        return;
      }
      
      if (!periodData) {
        alert("No period selected.");
        return;
      }

      if (!periodData.id) {
        alert("Period ID missing; reload and try again.");
        return;
      }
      
      // Format period display (matching what's shown in the UI)
      const start = new Date(periodData.start_date).toLocaleDateString('en-GB', { day: 'numeric', month: 'short', year: 'numeric' });
      const end = new Date(periodData.end_date).toLocaleDateString('en-GB', { day: 'numeric', month: 'short', year: 'numeric' });
      const periodLabel = `${start} - ${end}`;
      
      const confirmed = confirm(
        `‚ö†Ô∏è WARNING: Unpublish period (${periodLabel})?\n\n` +
        `This will REVERT the period back to draft status.\n\n` +
        `‚ö†Ô∏è IMPORTANT:\n` +
        `‚Ä¢ Only use this if you need to make changes BEFORE staff see the rota\n` +
        `‚Ä¢ DO NOT use this once the rota is in active use\n` +
        `‚Ä¢ For changes to published rotas, use post-publish editing instead\n\n` +
        `Are you absolutely sure you want to unpublish?`
      );
      
      if (!confirmed) return;
      
      // Second confirmation
      const doubleCheck = confirm(
        `Final confirmation:\n\n` +
        `You are about to unpublish the period (${periodLabel}).\n` +
        `This should only be used for testing or emergency corrections.\n\n` +
        `Proceed?`
      );
      
      if (!doubleCheck) return;
      
      try {
        // Update period status
        const { error: updErr } = await supabaseClient
          .from("rota_periods")
          .update({
            status: "draft",
            published_at: null,
            published_by: null
          })
          .eq("id", periodData.id);

        if (updErr) throw updErr;

        // Update all rota_assignments for this period from published back to draft
        const { error: assignErr } = await supabaseClient
          .from("rota_assignments")
          .update({ status: "draft" })
          .gte("date", periodData.start_date)
          .lte("date", periodData.end_date)
          .eq("status", "published");

        if (assignErr) {
          console.error("Error updating assignment status:", assignErr);
          // Don't throw - period is already unpublished, this is just cleanup
        }

        // Delete all history records for this period (since we're reverting to draft)
        try {
          const { error: histErr } = await supabaseClient
            .from("rota_assignment_history")
            .delete()
            .gte("date", periodData.start_date)
            .lte("date", periodData.end_date);
          
          if (histErr) {
            console.error("Error deleting history records:", histErr);
          } else {
            console.log("History records cleared for unpublished period");
          }
        } catch (e) {
          console.error("Error clearing history:", e);
        }

        // Delete all swap requests for this period (by date range)
        try {
          const { error: swapReqErr } = await supabaseClient
            .from("swap_requests")
            .delete()
            .or(`initiator_shift_date.gte.${periodData.start_date},initiator_shift_date.lte.${periodData.end_date},counterparty_shift_date.gte.${periodData.start_date},counterparty_shift_date.lte.${periodData.end_date}`);
          
          if (swapReqErr) {
            console.error("Error deleting swap requests:", swapReqErr);
          } else {
            console.log("Swap requests cleared for unpublished period");
          }
        } catch (e) {
          console.error("Error clearing swap requests:", e);
        }

        // Delete all swap executions for this period (by date range)
        try {
          const { error: swapExecErr } = await supabaseClient
            .from("swap_executions")
            .delete()
            .or(`initiator_old_shift_date.gte.${periodData.start_date},initiator_old_shift_date.lte.${periodData.end_date},initiator_new_shift_date.gte.${periodData.start_date},initiator_new_shift_date.lte.${periodData.end_date},counterparty_old_shift_date.gte.${periodData.start_date},counterparty_old_shift_date.lte.${periodData.end_date},counterparty_new_shift_date.gte.${periodData.start_date},counterparty_new_shift_date.lte.${periodData.end_date}`);
          
          if (swapExecErr) {
            console.error("Error deleting swap executions:", swapExecErr);
          } else {
            console.log("Swap executions cleared for unpublished period");
          }
        } catch (e) {
          console.error("Error clearing swap executions:", e);
        }

        // Delete all comments on assignments in this period
        try {
          // First, get all assignment IDs for this period
          const { data: assignments, error: assignListErr } = await supabaseClient
            .from("rota_assignments")
            .select("id")
            .gte("date", periodData.start_date)
            .lte("date", periodData.end_date);
          
          if (assignListErr) {
            console.error("Error fetching assignments:", assignListErr);
          } else if (assignments && assignments.length > 0) {
            const assignmentIds = assignments.map(a => a.id);
            
            // Delete comments for these assignments
            const { error: commErr } = await supabaseClient
              .from("rota_assignment_comments")
              .delete()
              .in("rota_assignment_id", assignmentIds);
            
            if (commErr) {
              console.error("Error deleting comments:", commErr);
            } else {
              console.log("Comments cleared for unpublished period");
            }
          }
        } catch (e) {
          console.error("Error clearing comments:", e);
        }

        // Delete all notifications related to swap requests in this period
        try {
          // Delete notifications of type 'swap_request' created during this period
          // These are tied to swap operations in the period
          const { error: notifErr } = await supabaseClient
            .from("notifications")
            .delete()
            .eq("type", "swap_request")
            .gte("created_at", new Date(periodData.start_date).toISOString())
            .lte("created_at", new Date(periodData.end_date).toISOString() + "T23:59:59Z");
          
          if (notifErr) {
            console.error("Error deleting swap notifications:", notifErr);
          } else {
            console.log("Swap notifications cleared for unpublished period");
          }
        } catch (e) {
          console.error("Error clearing swap notifications:", e);
        }

        // Remove all non-staff from this period (since non-staff are only for published rotas)
        try {
          const { error: nsErr } = await supabaseClient
            .from("period_non_staff")
            .update({ removed_at: new Date().toISOString(), removed_by: window.currentUser?.id })
            .eq("period_id", periodData.id)
            .is("removed_at", null);
          
          if (nsErr) {
            console.error("Error removing non-staff from period:", nsErr);
          } else {
            console.log("Non-staff removed from unpublished period");
          }
        } catch (e) {
          console.error("Error clearing non-staff:", e);
        }

        const { data: refreshed, error: fetchErr } = await supabaseClient
          .from("rota_periods")
          .select("*")
          .eq("id", periodData.id)
          .maybeSingle();

        if (fetchErr) throw fetchErr;
        if (!refreshed) throw new Error("Unpublish succeeded but refetch returned no row (check RLS)");

        periodData = refreshed;
        displayPeriodStatus(periodData);
        updateEditingControls(periodData);
        
        // Reload the rota
        await loadPeriod(periodData.id);
        
        alert("Period unpublished. Status reverted to draft.");
      } catch (e) {
        console.error("Error unpublishing period:", e);
        alert("Failed to unpublish period: " + e.message);
      }
    }

    // ========== DRAFT EDITING ==========

    function toggleRequests() {
      const canViewAll = window.PermissionsModule.hasPermission("requests.view_all");
      const canViewOwn = window.PermissionsModule.hasPermission("requests.view_own");
      
      if (!canViewAll && !canViewOwn) {
        alert("You don't have permission to view requests.");
        return;
      }
      
      showRequests = !showRequests;
      const btn = document.getElementById("toggleRequestsBtn");
      btn.textContent = showRequests ? "üëÅÔ∏è Hide Requests" : "üëÅÔ∏è Show Requests";
      btn.classList.toggle("primary", showRequests);
      
      // Debug: log what's in requestsMap
      console.log("[REQUESTS DEBUG] showRequests toggled to:", showRequests);
      console.log("[REQUESTS DEBUG] requestsMap size:", requestsMap.size);
      console.log("[REQUESTS DEBUG] requestsMap contents:", Array.from(requestsMap.entries()));
      
      // Re-render the table to apply request visibility
      renderRota();
    }

    function toggleEditing() {
      if (!window.PermissionsModule.hasPermission("rota.edit_draft")) {
        alert("You don't have permission to edit draft rotas.");
        return;
      }

      isEditingUnlocked = !isEditingUnlocked;
      const btn = document.getElementById("toggleEditingBtn");
      const metadataDisplay = document.getElementById("metadataDisplay");
      
      btn.textContent = isEditingUnlocked ? "üîì Editing" : "üîí Locked";
      btn.classList.toggle("primary", isEditingUnlocked);
      
      // Show/hide metadata display
      if (metadataDisplay) {
        metadataDisplay.style.display = isEditingUnlocked ? "block" : "none";
      }

      // Update cell editability
      document.querySelectorAll("#rota td.cell").forEach(td => {
        td.classList.toggle("editable", isEditingUnlocked);
      });
    }



    // ========== INIT ==========
    async function bootRotaPage(){
      try {
        console.log("[ROTA BOOT] Starting boot sequence.");
        
        // Safe element getter with null check logging
        const getElement = (id) => {
          const el = document.getElementById(id);
          if (!el) console.warn(`[ROTA BOOT] Element not found: ${id}`);
          return el;
        };

        // Attach period change handler
        const periodSelect = getElement("periodSelect");
        if (periodSelect) periodSelect.addEventListener("change", (e) => {
          loadPeriod(e.target.value);
        });
        
        // Attach toggle requests handler
        const toggleRequestsBtn = getElement("toggleRequestsBtn");
        if (toggleRequestsBtn) toggleRequestsBtn.addEventListener("click", toggleRequests);
        
        // Attach publish/unpublish handlers
        const publishBtn = getElement("publishBtn");
        if (publishBtn) publishBtn.addEventListener("click", publishPeriod);
        const unpublishBtn = getElement("unpublishBtn");
        if (unpublishBtn) unpublishBtn.addEventListener("click", unpublishPeriod);

        // Published details modal handlers
        const publishedDetailsClose = getElement("publishedDetailsClose");
        if (publishedDetailsClose) publishedDetailsClose.addEventListener("click", closePublishedDetails);
        const publishedDetailsModal = getElement("publishedDetailsModal");
        if (publishedDetailsModal) publishedDetailsModal.addEventListener("click", (e) => {
          if (e.target.id === "publishedDetailsModal") closePublishedDetails();
        });
        const publishedChangeBtn = getElement("publishedChangeBtn");
        if (publishedChangeBtn) publishedChangeBtn.addEventListener("click", handlePublishedChange);
        const publishedOverrideBtn = getElement("publishedOverrideBtn");
        if (publishedOverrideBtn) publishedOverrideBtn.addEventListener("click", handlePublishedOverride);
        const publishedHistoryBtn = getElement("publishedHistoryBtn");
        if (publishedHistoryBtn) publishedHistoryBtn.addEventListener("click", handlePublishedHistory);
        const publishedCommentsBtn = getElement("publishedCommentsBtn");
        if (publishedCommentsBtn) publishedCommentsBtn.addEventListener("click", handlePublishedComments);
        const publishedSwapBtn = getElement("publishedSwapBtn");
        if (publishedSwapBtn) publishedSwapBtn.addEventListener("click", handlePublishedSwap);

        // Comments modal handlers
        const commentsModalClose = getElement("commentsModalClose");
        if (commentsModalClose) commentsModalClose.addEventListener("click", () => {
          const backdrop = getElement("commentsModalBackdrop");
          if (backdrop) backdrop.setAttribute("aria-hidden", "true");
        });
        const commentsModalBackdrop = getElement("commentsModalBackdrop");
        if (commentsModalBackdrop) commentsModalBackdrop.addEventListener("click", (e) => {
          if (e.target.id === "commentsModalBackdrop") {
            commentsModalBackdrop.setAttribute("aria-hidden", "true");
          }
        });

        // Override amendment modal handlers
        const amendmentSaveBtn = getElement("amendmentSaveBtn");
        if (amendmentSaveBtn) amendmentSaveBtn.addEventListener("click", saveOverrideAmendment);
        const amendmentCancelBtn = getElement("amendmentCancelBtn");
        if (amendmentCancelBtn) amendmentCancelBtn.addEventListener("click", closeOverrideAmendmentModal);
        const overrideAmendmentModalBackdrop = getElement("overrideAmendmentModalBackdrop");
        if (overrideAmendmentModalBackdrop) overrideAmendmentModalBackdrop.addEventListener("click", (e) => {
          if (e.target.id === "overrideAmendmentModalBackdrop") {
            closeOverrideAmendmentModal();
          }
        });
        attachAmendmentHourAutoCalc();

        // Shift swap modal handlers
        const swapCancelBtn = getElement("swapCancelBtn");
        if (swapCancelBtn) swapCancelBtn.addEventListener("click", () => {
          const modal = getElement("shiftSwapModal");
          if (modal) modal.setAttribute("aria-hidden", "true");
        });
        const shiftSwapModal = getElement("shiftSwapModal");
        if (shiftSwapModal) shiftSwapModal.addEventListener("click", (e) => {
          if (e.target.id === "shiftSwapModal") {
            e.target.setAttribute("aria-hidden", "true");
          }
        });
        const swapSubmitBtn = getElement("swapSubmitBtn");
        if (swapSubmitBtn) swapSubmitBtn.addEventListener("click", async () => {
          if (!window.swapInitiatorContext) return;

          const { userId: initiatorId, date: initiatorDate, isAdmin } = window.swapInitiatorContext;
          const peerId = document.getElementById("swapPeerSelect").value;
          const peerDate = document.getElementById("swapDateSelect").value;

          if (!peerId || !peerDate) {
            alert("Please select both staff member and their shift date.");
            return;
          }

          try {
            const btn = swapSubmitBtn;
            btn.disabled = true;

            if (isAdmin) {
              // Admin direct swap - call directly from window context
              if (typeof window.adminExecuteShiftSwap === "function") {
                console.log("[SWAP] Admin swap: initiator=", initiatorId, "peer=", peerId, "initiator_date=", initiatorDate, "peer_date=", peerDate);
                const result = await window.adminExecuteShiftSwap(peerId, peerDate);
                console.log("[SWAP] Admin swap result:", result);
                closePublishedDetails();
                alert("Swap executed successfully.");
              } else {
                alert("Admin swap function not ready.");
              }
            } else {
              // Staff propose swap
              if (typeof window.staffRequestShiftSwap === "function") {
                console.log("[SWAP] Staff swap request: initiator=", initiatorId, "peer=", peerId, "initiator_date=", initiatorDate, "peer_date=", peerDate);
                const result = await window.staffRequestShiftSwap(peerId, peerDate);
                console.log("[SWAP] Staff swap result:", result);
                alert("Swap request sent. Awaiting peer and admin approval.");
              } else {
                alert("Swap function not ready.");
              }
            }

            const modal = getElement("shiftSwapModal");
            if (modal) modal.setAttribute("aria-hidden", "true");
            window.swapInitiatorContext = null;
            
            // Reload rota to show updated shifts - fetch fresh data from database
            if (typeof loadPeriod === "function" && window.currentPeriod && window.currentPeriod.id) {
              console.log("[SWAP] Reloading period:", window.currentPeriod.id);
              await loadPeriod(window.currentPeriod.id);
              console.log("[SWAP] Period reload complete");
            }
          } catch (err) {
            console.error("[SWAP] Error:", err);
            alert(`Swap failed: ${err.message}`);
          } finally {
            swapSubmitBtn.disabled = false;
          }
        });

        const user = await checkAuth();
        console.log("[ROTA BOOT] checkAuth returned:", user);
        if (!user) {
          console.error("[ROTA BOOT] No user, returning");
          return;
        }

        // Signal other deferred modules (e.g., shift-functions.js) that auth is complete
        window.dispatchEvent(new Event("calpe:user-ready"));

        console.log("[ROTA BOOT] User authenticated, loading periods...");
        // Apply permission-based UI visibility and store globally
        // For now, default to true if PermissionsModule not available (will be replaced with real permission system)
        canViewAllRequests = window.PermissionsModule?.hasPermission("requests.view_all") ?? false;
        canViewOwnRequests = window.PermissionsModule?.hasPermission("requests.view_own") ?? false;
        canEditDraft = window.PermissionsModule?.hasPermission("rota.edit_draft") ?? false;
        canEditPublished = window.PermissionsModule?.hasPermission("rota.edit_published") ?? false;
        
        console.log("[ROTA] Permission check: canViewAllRequests=", canViewAllRequests, "canViewOwnRequests=", canViewOwnRequests);
        
        // Hide buttons if user lacks permissions
        const toggleRequestsBtnPerm = document.getElementById("toggleRequestsBtn");
        const toggleEditingBtn = document.getElementById("toggleEditingBtn");
        
        // Show requests button if user can view all OR view own
        if (!canViewAllRequests && !canViewOwnRequests && toggleRequestsBtnPerm) {
          console.log("[ROTA] Hiding Show Requests button - no request view permissions");
          toggleRequestsBtnPerm.style.display = "none";
        } else {
          console.log("[ROTA] Show Requests button visible");
        }

        // Initialize modular draft editing (shift-editor.js) after auth
        const bootEditing = () => {
          if (typeof window.initDraftEditing !== "function") {
            console.error("initDraftEditing not ready yet; retrying...");
            setTimeout(bootEditing, 50);
            return;
          }
          window.initDraftEditing({
            onUnlock: () => {
              const metadataDisplay = document.getElementById("metadataDisplay");
              if (currentEditContext === "draft") {
                if (metadataDisplay) metadataDisplay.style.display = "block";
              } else {
                if (metadataDisplay) metadataDisplay.style.display = "none";
              }
            },
            onLock: () => {
              const metadataDisplay = document.getElementById("metadataDisplay");
              if (metadataDisplay) metadataDisplay.style.display = "none";
            },
            onPublishedCellClick: ({ userId, date }) => {
              openPublishedDetails({ userId, date });
            },
            onSave: async (userId, date, shiftId, overrideData) => {
              console.log("[ROTA ONSAVE] Called with:", { userId, date, shiftId, overrideData });
              
              const key = `${userId}_${date}`;
              const newShift = draftShifts.find(s => s.id === shiftId);
              const userMeta = allUsers.find(u => u.id === userId);
              const isNonStaff = userMeta?.is_non_staff;
              const historyAssignee = isNonStaff
                ? { user_id: null, period_non_staff_id: userId }
                : { user_id: userId, period_non_staff_id: null };
              
              // Optimistic update: update local map immediately
              const existing = assignmentsMap.get(key);
              let oldShiftId = null;
              let oldShiftCode = null;
              if (existing) {
                oldShiftId = existing.shift_id;
                const oldShift = shiftMap.get(oldShiftId);
                oldShiftCode = oldShift?.code || 'UNKNOWN';
                existing.shift_id = shiftId;
              } else {
                assignmentsMap.set(key, {
                  user_id: isNonStaff ? null : userId,
                  period_non_staff_id: isNonStaff ? userId : null,
                  date,
                  shift_id: shiftId,
                  status: "draft"
                });
              }
              
              // Re-render immediately
              renderRota();
              
              // Sync to database in background
              const { data: existingDb, error: getErr } = await supabaseClient
                .from("rota_assignments")
                .select("id")
                .eq(isNonStaff ? "period_non_staff_id" : "user_id", userId)
                .eq("date", date)
                .maybeSingle();
              
              let assignmentId = existingDb?.id;
              
              if (!getErr) {
                if (existingDb?.id) {
                  assignmentId = existingDb.id;
                  await supabaseClient
                    .from("rota_assignments")
                    .update({ shift_id: shiftId })
                    .eq("id", existingDb.id);
                  // Update assignmentsMap with the ID
                  const existing = assignmentsMap.get(key);
                  if (existing) existing.id = existingDb.id;
                  
                  // Record history if in published mode and shift changed or added
                  if (currentEditContext === "published") {
                    // Only record if shift actually changed (or was added to empty cell)
                    if (!oldShiftId || oldShiftId !== shiftId) {
                      console.log("[ROTA ONSAVE] Recording history for shift change:", { oldShiftId, newShiftId: shiftId, assignmentId });
                      const { error: histErr } = await supabaseClient
                        .from("rota_assignment_history")
                        .insert([{
                          rota_assignment_id: assignmentId,
                          ...historyAssignee,
                          date: date,
                          old_shift_id: oldShiftId || null,
                          old_shift_code: oldShiftCode || null,
                          new_shift_id: shiftId,
                          new_shift_code: newShift?.code || 'UNKNOWN',
                          change_reason: oldShiftId ? 'Admin changed shift' : 'Admin added shift',
                          changed_by: window.currentUser?.id,
                          changed_by_name: window.currentUser?.name,
                          changed_at: new Date().toISOString()
                        }]);
                      if (histErr) {
                        console.error("[ROTA ONSAVE] Error recording history:", histErr);
                      } else {
                        console.log("[ROTA ONSAVE] History recorded successfully");
                      }
                    }
                  }
                } else {
                  const { data: newAssignment } = await supabaseClient
                    .from("rota_assignments")
                    .insert([{
                      user_id: isNonStaff ? null : userId,
                      period_non_staff_id: isNonStaff ? userId : null,
                      date,
                      shift_id: shiftId,
                      status: currentEditContext === "published" ? "published" : "draft"
                    }])
                    .select()
                    .single();
                  assignmentId = newAssignment?.id;
                  // Update assignmentsMap with the new ID
                  const existing = assignmentsMap.get(key);
                  if (existing && assignmentId) existing.id = assignmentId;
                  
                  // Record history for new assignment (if in published mode)
                  if (currentEditContext === "published" && assignmentId) {
                    console.log("[ROTA ONSAVE] Recording history for new shift:", { shiftId, assignmentId });
                    const { error: histErr } = await supabaseClient
                      .from("rota_assignment_history")
                      .insert([{
                        rota_assignment_id: assignmentId,
                        ...historyAssignee,
                        date: date,
                        old_shift_id: null,
                        old_shift_code: null,
                        new_shift_id: shiftId,
                        new_shift_code: newShift?.code || 'UNKNOWN',
                        change_reason: 'Admin added shift',
                        changed_by: window.currentUser?.id,
                        changed_by_name: window.currentUser?.name,
                        changed_at: new Date().toISOString()
                      }]);
                    if (histErr) {
                      console.error("[ROTA ONSAVE] Error recording history:", histErr);
                    } else {
                      console.log("[ROTA ONSAVE] History recorded successfully");
                    }
                  }
                }
                
                // Save override data if provided (published mode only)
                // Only save if there's actual override data (not just empty fields)
                const hasActualOverride = overrideData && (
                  overrideData.override_start_time || 
                  overrideData.override_end_time || 
                  overrideData.override_hours
                );
                
                if (hasActualOverride && assignmentId) {
                  console.log("[ROTA ONSAVE] Saving override for assignmentId:", assignmentId, overrideData);
                  const { data: existingOverride } = await supabaseClient
                    .from("rota_assignment_overrides")
                    .select("id")
                    .eq("rota_assignment_id", assignmentId)
                    .maybeSingle();
                  
                  const overridePayload = {
                    rota_assignment_id: assignmentId,
                    override_start_time: overrideData.override_start_time,
                    override_end_time: overrideData.override_end_time,
                    override_hours: overrideData.override_hours,
                    comment: overrideData.comment,
                    comment_visibility: overrideData.comment_visibility || 'admin_only'
                  };
                  
                  console.log("[ROTA ONSAVE] Override payload:", overridePayload);
                  
                  if (existingOverride?.id) {
                    console.log("[ROTA ONSAVE] Updating existing override:", existingOverride.id);
                    const { data: updateData, error: updateErr } = await supabaseClient
                      .from("rota_assignment_overrides")
                      .update(overridePayload)
                      .eq("id", existingOverride.id);
                    if (updateErr) {
                      console.error("[ROTA ONSAVE] Error updating override:", updateErr);
                    } else {
                      console.log("[ROTA ONSAVE] Override updated successfully");
                      overridesMap.set(assignmentId, { ...existingOverride, ...overridePayload });
                      renderRota(); // Re-render to show override badge
                    }
                  } else {
                    console.log("[ROTA ONSAVE] Inserting new override");
                    const { data: newOverride, error: insertErr } = await supabaseClient
                      .from("rota_assignment_overrides")
                      .insert([overridePayload])
                      .select()
                      .single();
                    if (insertErr) {
                      console.error("[ROTA ONSAVE] Error inserting override:", insertErr);
                      console.error("[ROTA ONSAVE] Error details:", {
                        message: insertErr.message,
                        status: insertErr.status,
                        code: insertErr.code,
                        hint: insertErr.hint
                      });
                    } else if (newOverride) {
                      console.log("[ROTA ONSAVE] Override inserted successfully:", newOverride);
                      overridesMap.set(assignmentId, newOverride);
                    }
                  }
                  
                  // Re-render to show override badges
                  renderRota();
                } else {
                  console.log("[ROTA ONSAVE] No override data to save");
                  
                  // If there's an existing override but no new override data, delete it
                  if (assignmentId) {
                    const { data: existingOverride } = await supabaseClient
                      .from("rota_assignment_overrides")
                      .select("id")
                      .eq("rota_assignment_id", assignmentId)
                      .maybeSingle();
                    
                    if (existingOverride?.id) {
                      console.log("[ROTA ONSAVE] Deleting old override:", existingOverride.id);
                      const { error: deleteErr } = await supabaseClient
                        .from("rota_assignment_overrides")
                        .delete()
                        .eq("id", existingOverride.id);
                      
                      if (deleteErr) {
                        console.error("[ROTA ONSAVE] Error deleting override:", deleteErr);
                      } else {
                        console.log("[ROTA ONSAVE] Override deleted successfully");
                        overridesMap.delete(assignmentId);
                        renderRota(); // Re-render to remove override badge
                      }
                    }
                  }
                }
              }
            },
            onClear: async (userId, date) => {
              const key = `${userId}_${date}`;
              const userMeta = allUsers.find(u => u.id === userId);
              const isNonStaff = userMeta?.is_non_staff;
              const historyAssignee = isNonStaff
                ? { user_id: null, period_non_staff_id: userId }
                : { user_id: userId, period_non_staff_id: null };
              
              // Get the current shift info before deleting (for history)
              const existingAssignment = assignmentsMap.get(key);
              const oldShiftId = existingAssignment?.shift_id;
              const oldShift = oldShiftId ? shiftMap.get(oldShiftId) : null;
              const oldShiftCode = oldShift?.code;
              
              // Optimistic update: remove from local map immediately
              assignmentsMap.delete(key);
              
              // Re-render immediately
              renderRota();
              
              // Sync to database in background
              const { data: existing, error: getErr } = await supabaseClient
                .from("rota_assignments")
                .select("id")
                .eq(isNonStaff ? "period_non_staff_id" : "user_id", userId)
                .eq("date", date)
                .maybeSingle();
              
              if (!getErr && existing?.id) {
                // Record history before deleting (if in published mode)
                if (currentEditContext === "published" && oldShiftId) {
                  console.log("[ROTA ONCLEAR] Recording history for cleared shift:", { oldShiftId, assignmentId: existing.id });
                  const { error: histErr } = await supabaseClient
                    .from("rota_assignment_history")
                    .insert([{
                      rota_assignment_id: existing.id,
                      ...historyAssignee,
                      date: date,
                      old_shift_id: oldShiftId,
                      old_shift_code: oldShiftCode || 'UNKNOWN',
                      new_shift_id: null,
                      new_shift_code: null,
                      change_reason: 'Admin cleared shift',
                      changed_by: window.currentUser?.id,
                      changed_by_name: window.currentUser?.name,
                      changed_at: new Date().toISOString()
                    }]);
                  if (histErr) {
                    console.error("[ROTA ONCLEAR] Error recording history:", histErr);
                  } else {
                    console.log("[ROTA ONCLEAR] History recorded successfully");
                  }
                }
                
                // Now delete the assignment
                await supabaseClient
                  .from("rota_assignments")
                  .delete()
                  .eq("id", existing.id);
              }
            },
            getCurrentUser: () => window.currentUser,
            getCurrentPeriod: () => currentPeriod,
            getAllUsers: () => allUsers,
            getDraftShifts: () => draftShifts,
            getAssignment: (userId, date) => assignmentsMap.get(`${userId}_${date}`),
            getOverride: (assignmentId) => overridesMap.get(assignmentId),
            refreshGrid: () => {
              renderRota();
            },
          });
        };

        bootEditing();
        
        console.log("[ROTA BOOT] Loading bank holidays...");
        await loadBankHolidays();
        
        console.log("[ROTA BOOT] Calling loadPeriods...");
        try {
          const loadPeriodsPromise = loadPeriods();
          await Promise.race([
            loadPeriodsPromise,
            new Promise((_, reject) => setTimeout(() => reject(new Error("loadPeriods timeout after 10s")), 10000))
          ]);
          console.log("[ROTA BOOT] loadPeriods completed");
        } catch (err) {
          console.error("[ROTA BOOT] loadPeriods failed:", err);
          throw err;
        }
        
        // Initialize notices/notifications (from app.js)
        console.log("[ROTA BOOT] Loading notices bell...");
        try {
          await loadNoticesBell();
          console.log("[ROTA BOOT] Notices bell loaded");
        } catch (err) {
          console.error("[ROTA BOOT] Failed to load notices bell:", err);
          // Don't throw - notices are not critical to showing the rota
        }
        console.log("[ROTA BOOT] Boot complete!");
      } catch (err) {
        console.error("Rota boot failed:", err);
        alert("Failed to load rota: " + err.message);
      }
    }

    console.log("[ROTA BOOT] installing boot hooks, readyState=", document.readyState);

    // Kick off boot when ready. If DOMContentLoaded already fired, start immediately.
    async function startBoot() {
      console.log("[ROTA BOOT] startBoot invoked");
      // Session is already validated by session-validator.js (runs before this)
      // Token is stored in sessionStorage via login.html
      await bootRotaPage();
    }

    if (document.readyState === "loading") {
      window.addEventListener("DOMContentLoaded", () => {
        console.log("[ROTA BOOT] DOMContentLoaded - initializing session and boot");
        startBoot();
      }, { once: true });
    } else {
      console.log("[ROTA BOOT] DOMContentLoaded already fired - starting boot now");
      startBoot();
    }

    // ========== NOTICES/NOTIFICATIONS BELL ==========
    const noticeBell = document.getElementById("noticeBell");
    const noticeBellDot = document.getElementById("noticeBellDot");
    const noticeAllModal = document.getElementById("noticeAllModal");
    const noticeAllClose = document.getElementById("noticeAllClose");
    const noticeAllList = document.getElementById("noticeAllList");

    let noticesCache = [];
    let notificationsCache = [];
    let unreadCount = 0;
    let notificationsUnreadCount = 0;

    function escapeHtml(str){
      return String(str || "")
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll("\"","&quot;")
        .replaceAll("'","&#039;");
    }

    function getNoticeBody(n){
      return n.body_en || "";
    }

    function isNoticeAcked(n){
      if (!n.acknowledged_at) return false;
      if (
        n.ack_version != null &&
        Number(n.ack_version) !== Number(n.version)
      ) {
        return false;
      }
      return true;
    }

    async function fetchNoticesForMe(){
      if (!window.currentUser) return [];

      const { data, error } = await supabaseClient.rpc(
        "get_notices_for_user",
        {
          p_token: window.currentToken
        }
      );
      if (error) throw error;

      const map = new Map();
      for (const row of (data || [])){
        const key = String(row.id);
        const prev = map.get(key);
        if (!prev) {
          map.set(key, row);
          continue;
        }

        const prevT = prev.updated_at ? new Date(prev.updated_at).getTime() : 0;
        const rowT  = row.updated_at  ? new Date(row.updated_at).getTime()  : 0;

        if (rowT > prevT) map.set(key, row);
      }

      return [...map.values()].sort((a,b) => new Date(b.updated_at) - new Date(a.updated_at));
    }

    async function fetchNotificationsForMe(){
      if (!window.currentUser) return [];

      const roleId = Number(window.currentUser.role_id);
      const isAdmin = !!window.currentUser.is_admin;
      
      // Check if user is in Admin permission group
      let isAdminGroup = false;
      if (!isAdmin) {
        try {
          const { data: groups } = await supabaseClient
            .from("user_permission_groups")
            .select("permission_groups(name)")
            .eq("user_id", window.currentUser.id);
          if (groups && groups.some(g => g.permission_groups?.name === "Admin")) {
            isAdminGroup = true;
          }
        } catch (e) {
          console.warn("Failed to check admin group", e);
        }
      }
      
      const clauses = ["target_scope.eq.all_staff"];

      if (window.currentUser.id) {
        clauses.push(`and(target_scope.eq.user,target_user_id.eq.${window.currentUser.id})`);
      }

      if (isAdmin || isAdminGroup) {
        clauses.push(`target_scope.eq.admin`);
      }

      if (!Number.isNaN(roleId)) {
        clauses.push(`and(target_scope.eq.role,target_role_ids.cs.{${roleId}})`);
      }

      const { data, error } = await supabaseClient
        .from("notifications")
        .select(`
          id,
          type,
          payload,
          target_scope,
          target_role_ids,
          target_user_id,
          requires_action,
          status,
          created_by,
          created_at,
          updated_by,
          updated_at,
          acted_by,
          acted_at
        `)
        .or(clauses.join(","))
        .order("updated_at", { ascending: false });

      if (error) throw error;

      // Client-side filtering to ensure notifications are properly targeted
      const filtered = (data || []).filter(item => {
        // Only show pending notifications
        if ((item.status || 'pending') !== 'pending') return false;
        
        // all_staff scope matches everyone
        if (item.target_scope === 'all_staff') return true;
        
        // user scope must match current user ID
        if (item.target_scope === 'user') {
          return item.target_user_id === window.currentUser.id;
        }
        
        // role scope must include current user's role
        if (item.target_scope === 'role') {
          const roleId = Number(window.currentUser.role_id);
          const targetRoles = item.target_role_ids || [];
          return targetRoles.includes(roleId);
        }
        
        return false;
      });

      return filtered;
    }

    function computeNoticeState(list){
      noticesCache = Array.isArray(list) ? list : [];
      unreadCount = 0;

      for (const n of noticesCache){
        if (n.is_active === false) continue;

        const acked = isNoticeAcked(n);

        if (!acked){
          unreadCount++;
        }
      }
    }

    function computeNotificationState(list){
      notificationsCache = Array.isArray(list) ? list : [];
      notificationsUnreadCount = (notificationsCache || []).filter(n => (n.status || "pending") === "pending").length;
    }

    function updateNoticeBell(){
      if (!noticeBell || !noticeBellDot) return;

      if (!window.currentUser){
        noticeBell.style.display = "none";
        noticeBellDot.style.display = "none";
        return;
      }

      noticeBell.style.display = "inline-flex";
      const hasUnread = (unreadCount + notificationsUnreadCount) > 0;
      noticeBellDot.style.display = hasUnread ? "inline" : "none";
    }

    function renderAllNoticesList(){
      if (!noticeAllList) return;

      // Separate notices and notifications
      const notices = [];
      const notifications = [];

      // Build notices array
      (noticesCache || []).forEach(n => {
        const bodyText = getNoticeBody(n);
        notices.push({
          _type: "notice",
          id: String(n.id),
          title: n.title || "Notice",
          body: bodyText || '',
          when: n.updated_at ? new Date(n.updated_at).toLocaleString("en-GB") : "",
          who: n.created_by_name || "Unknown",
          acked: isNoticeAcked(n),
          data: n
        });
      });

      // Build notifications array using shared formatting functions
      (notificationsCache || []).forEach(n => {
        notifications.push({
          _type: "notification",
          id: String(n.id),
          title: getNotificationTitle(n),
          body: getNotificationBody(n),
          when: n.updated_at ? new Date(n.updated_at).toLocaleString("en-GB") : "",
          status: n.status || "pending",
          requiresAction: !!n.requires_action,
          data: n
        });
      });

      // Sort by updated_at (newest first)
      const allItems = [...notices, ...notifications];
      allItems.sort((a,b) => {
        const aTime = a.data.updated_at ? new Date(a.data.updated_at).getTime() : 0;
        const bTime = b.data.updated_at ? new Date(b.data.updated_at).getTime() : 0;
        return bTime - aTime;
      });

      // Render using shared function
      if (allItems.length === 0) {
        noticeAllList.innerHTML = `<div class="subtitle">No notices or notifications</div>`;
        return;
      }

      // Separate again for grouped display
      const noticesForDisplay = allItems.filter(i => i._type === "notice");
      const notificationsForDisplay = allItems.filter(i => i._type === "notification");

      noticeAllList.innerHTML = renderAllNoticesAndNotifications(noticesForDisplay, notificationsForDisplay);
    }

    async function refreshNotices(){
      const list = await fetchNoticesForMe();
      computeNoticeState(list);
      updateNoticeBell();
    }

    async function refreshNotifications(){
      const list = await fetchNotificationsForMe();
      computeNotificationState(list);
      updateNoticeBell();
    }

    async function refreshNoticesAndNotifications(){
      await Promise.all([refreshNotices(), refreshNotifications()]);
    }

    async function ackOneNotice(noticeId, noticeVersion){
      if (!window.currentUser) return;

      const { error } = await supabaseClient.rpc("ack_notice", {
        p_notice_id: noticeId,
        p_version: noticeVersion,
        p_user_id: window.currentUser.id
      });

      if (error) throw error;

      await refreshNotices();
    }

    async function updateNotificationStatus(notifId, status){
      if (!window.currentUser) throw new Error("Not logged in.");
      const { error } = await supabaseClient
        .from("notifications")
        .update({
          status: status,
          acted_by: window.currentUser.id,
          acted_at: new Date().toISOString(),
          updated_by: window.currentUser.id
        })
        .eq("id", notifId);

      if (error) throw error;
    }

    async function loadNoticesBell(){
      try {
        // Race against 5 second timeout - notices are non-critical
        await Promise.race([
          refreshNoticesAndNotifications(),
          new Promise((_, reject) => setTimeout(() => reject(new Error("Notices timeout")), 5000))
        ]);
      } catch (e) {
        console.warn("Failed to load notices/notifications:", e);
      }
    }

    function openAllNoticesModal(){
      if (!noticeAllModal) return;

      renderAllNoticesList();

      document.body.classList.add("modal-open");
      noticeAllModal.style.display = "flex";
      noticeAllModal.setAttribute("aria-hidden","false");
    }

    function closeAllNoticesModal(){
      if (!noticeAllModal) return;

      noticeAllModal.style.display = "none";
      noticeAllModal.setAttribute("aria-hidden","true");
      document.body.classList.remove("modal-open");
    }

    noticeBell?.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (!window.currentUser) return;
      openAllNoticesModal();
    });

    noticeAllClose?.addEventListener("click", closeAllNoticesModal);
    noticeAllModal?.addEventListener("click", (e) => {
      if (e.target === noticeAllModal) closeAllNoticesModal();
    });

    noticeAllList?.addEventListener("click", async (e) => {
      const ackBtn = e.target.closest("button[data-ack]");
      if (ackBtn) {
        const id = String(ackBtn.dataset.ack);

        const n = (noticesCache || []).find(x => String(x.id) === id);
        if (!n) {
          alert("Notice not found in cache. Reload and try again.");
          return;
        }

        try {
          ackBtn.disabled = true;

          await ackOneNotice(n.id, n.version);

          await refreshNoticesAndNotifications();
          renderAllNoticesList();
        } catch (err) {
          console.error(err);
          alert("Failed to acknowledge notice.");
        } finally {
          ackBtn.disabled = false;
        }
        return;
      }

      const acceptBtn = e.target.closest("button[data-notif-accept]");
      if (acceptBtn) {
        const id = String(acceptBtn.dataset.notifAccept);
        try {
          acceptBtn.disabled = true;
          
          // Check if this is a swap request notification
          const notification = notificationsCache.find(n => String(n.id) === id);
          console.log("[DEBUG] Accept clicked - notification:", notification);
          
          if (notification && notification.type === "swap_request") {
            let payload = notification.payload;
            if (typeof payload === 'string') {
              payload = JSON.parse(payload);
            }
            
            // Check if this is an admin approval notification (swap_accepted)
            if (payload?.notification_type === "swap_accepted" && window.currentUser?.is_admin) {
              console.log("[DEBUG] Admin approving swap request with:", {
                admin_id: window.currentUser.id,
                swap_request_id: payload?.swap_request_id
              });
              
              // Call admin_approve_swap_request for admin approval
              const { data, error } = await supabaseClient.rpc(
                "admin_approve_swap_request",
                {
                  p_token: window.currentToken,
                  p_swap_request_id: payload?.swap_request_id
                }
              );
              console.log("[DEBUG] Admin approve RPC response:", { data, error });
              if (error) throw error;
              if (data && data.length > 0 && !data[0].success) {
                throw new Error(data[0].error_message || "Unknown error");
              }
              console.log("[DEBUG] Swap request approved successfully!");
              alert("Swap approved!");
            } else {
              // Staff responding to swap request (not an admin)
              console.log("[DEBUG] Calling staff_respond_to_swap_request with:", {
                user_id: window.currentUser.id,
                swap_request_id: payload?.swap_request_id,
                response: "accepted"
              });
              
              // Call staff_respond_to_swap_request for swap acceptance
              const { data, error } = await supabaseClient.rpc(
                "staff_respond_to_swap_request",
                {
                  p_token: window.currentToken,
                  p_swap_request_id: payload?.swap_request_id,
                  p_response: "accepted"
                }
              );
              console.log("[DEBUG] RPC response:", { data, error });
              if (error) throw error;
              if (data && data.length > 0 && !data[0].success) {
                throw new Error(data[0].error_message || "Unknown error");
              }
              console.log("[DEBUG] Swap request accepted successfully!");
              alert("Swap request accepted!");
            }
          } else {
            // Standard notification acceptance
            await updateNotificationStatus(id, "accepted");
          }
          
          console.log("[DEBUG] Refreshing notices and notifications...");
          await refreshNoticesAndNotifications();
          console.log("[DEBUG] Rendering notices list...");
          renderAllNoticesList();
          console.log("[DEBUG] Done refreshing");
        } catch (err) {
          console.error(err);
          alert("Failed to accept notification.");
        } finally {
          acceptBtn.disabled = false;
        }
        return;
      }

      const declineBtn = e.target.closest("button[data-notif-decline]");
      if (declineBtn) {
        const id = String(declineBtn.dataset.notifDecline);
        try {
          declineBtn.disabled = true;
          
          // Check if this is a swap request notification
          const notification = notificationsCache.find(n => String(n.id) === id);
          console.log("[DEBUG] Decline clicked - notification:", notification);
          
          if (notification && notification.type === "swap_request") {
            let payload = notification.payload;
            if (typeof payload === 'string') {
              payload = JSON.parse(payload);
            }
            
            // Check if this is an admin approval notification (swap_accepted)
            if (payload?.notification_type === "swap_accepted" && window.currentUser?.is_admin) {
              console.log("[DEBUG] Admin declining swap request with:", {
                admin_id: window.currentUser.id,
                swap_request_id: payload?.swap_request_id
              });
              
              // Call admin_decline_swap_request for admin decline
              const { data, error } = await supabaseClient.rpc(
                "admin_decline_swap_request",
                {
                  p_token: window.currentToken,
                  p_swap_request_id: payload?.swap_request_id
                }
              );
              console.log("[DEBUG] Admin decline RPC response:", { data, error });
              if (error) throw error;
              if (data && data.length > 0 && !data[0].success) {
                throw new Error(data[0].error_message || "Unknown error");
              }
              console.log("[DEBUG] Swap request declined successfully!");
              alert("Swap declined!");
            } else {
              // Staff responding to swap request (not an admin)
              console.log("[DEBUG] Calling staff_respond_to_swap_request with:", {
                user_id: window.currentUser.id,
                swap_request_id: payload?.swap_request_id,
                response: "declined"
              });
              
              // Call staff_respond_to_swap_request for swap decline
              const { data, error } = await supabaseClient.rpc(
                "staff_respond_to_swap_request",
                {
                  p_token: window.currentToken,
                  p_swap_request_id: payload?.swap_request_id,
                  p_response: "declined"
                }
              );
              console.log("[DEBUG] RPC response:", { data, error });
              if (error) throw error;
              if (data && data.length > 0 && !data[0].success) {
                throw new Error(data[0].error_message || "Unknown error");
              }
              alert("Swap request declined!");
            }
          } else {
            // Standard notification decline
            await updateNotificationStatus(id, "declined");
          }
          
          await refreshNoticesAndNotifications();
          renderAllNoticesList();
        } catch (err) {
          console.error(err);
          alert("Failed to decline notification.");
        } finally {
          declineBtn.disabled = false;
        }
        return;
      }

      const ignoreBtn = e.target.closest("button[data-notif-ignore]");
      if (ignoreBtn) {
        const id = String(ignoreBtn.dataset.notifIgnore);
        try {
          ignoreBtn.disabled = true;
          await updateNotificationStatus(id, "ignored");
          await refreshNotifications();
          renderAllNoticesList();
        } catch (err) {
          console.error(err);
          alert("Failed to ignore notification.");
        } finally {
          ignoreBtn.disabled = false;
        }
        return;
      }

      const ackNotifBtn = e.target.closest("button[data-notif-ack]");
      if (ackNotifBtn) {
        const id = String(ackNotifBtn.dataset.notifAck);
        try {
          ackNotifBtn.disabled = true;
          await updateNotificationStatus(id, "ack");
          await refreshNotifications();
          renderAllNoticesList();
        } catch (err) {
          console.error(err);
          alert("Failed to acknowledge notification.");
        } finally {
          ackNotifBtn.disabled = false;
        }
        return;
      }

      // Admin approve swap (from swap_pending notification)
      const adminApproveBtn = e.target.closest("button[data-admin-approve-swap]");
      if (adminApproveBtn) {
        const notifId = String(adminApproveBtn.dataset.adminApproveSwap);
        try {
          adminApproveBtn.disabled = true;
          
          // Find the notification to get swap_request_id
          const notification = notificationsCache.find(n => String(n.id) === notifId);
          if (!notification || !notification.payload?.swap_request_id) {
            throw new Error("Swap request ID not found in notification");
          }
          
          const swapRequestId = notification.payload.swap_request_id;
          
          // Call admin approval RPC
          const { data, error } = await window.supabaseClient.rpc("admin_approve_swap_request", {
            p_token: window.currentToken,
            p_swap_request_id: swapRequestId
          });
          
          if (error) throw error;
          if (data && data.length > 0 && !data[0].success) {
            throw new Error(data[0].error_message || "Failed to approve swap");
          }
          
          alert("Swap approved successfully!");
          await refreshNotifications();
          renderAllNoticesList();
        } catch (err) {
          console.error(err);
          alert("Failed to approve swap: " + err.message);
        } finally {
          adminApproveBtn.disabled = false;
        }
        return;
      }

      // Admin decline swap (from swap_pending notification)
      const adminDeclineBtn = e.target.closest("button[data-admin-decline-swap]");
      if (adminDeclineBtn) {
        const notifId = String(adminDeclineBtn.dataset.adminDeclineSwap);
        try {
          adminDeclineBtn.disabled = true;
          
          // Find the notification to get swap_request_id
          const notification = notificationsCache.find(n => String(n.id) === notifId);
          if (!notification || !notification.payload?.swap_request_id) {
            throw new Error("Swap request ID not found in notification");
          }
          
          const swapRequestId = notification.payload.swap_request_id;
          
          // Call admin decline RPC
          const { data, error } = await window.supabaseClient.rpc("admin_decline_swap_request", {
            p_token: window.currentToken,
            p_swap_request_id: swapRequestId
          });
          
          if (error) throw error;
          if (data && data.length > 0 && !data[0].success) {
            throw new Error(data[0].error_message || "Failed to decline swap");
          }
          
          alert("Swap declined successfully!");
          await refreshNotifications();
          renderAllNoticesList();
        } catch (err) {
          console.error(err);
          alert("Failed to decline swap: " + err.message);
        } finally {
          adminDeclineBtn.disabled = false;
        }
        return;
      }
    });

    // Add hover effects to publish/unpublish buttons
    const publishBtn = document.getElementById("publishBtn");
    const unpublishBtn = document.getElementById("unpublishBtn");
    
    if (publishBtn) {
      publishBtn.addEventListener("mouseenter", function() {
        this.style.background = "#047857";
        this.style.boxShadow = "0 4px 8px rgba(0,0,0,0.15)";
        this.style.transform = "translateY(-2px)";
      });
      publishBtn.addEventListener("mouseleave", function() {
        this.style.background = "#059669";
        this.style.boxShadow = "0 2px 4px rgba(0,0,0,0.1)";
        this.style.transform = "translateY(0)";
      });
    }
    
    if (unpublishBtn) {
      unpublishBtn.addEventListener("mouseenter", function() {
        this.style.background = "#b91c1c";
        this.style.boxShadow = "0 4px 8px rgba(0,0,0,0.15)";
        this.style.transform = "translateY(-2px)";
      });
      unpublishBtn.addEventListener("mouseleave", function() {
        this.style.background = "#dc2626";
        this.style.boxShadow = "0 2px 4px rgba(0,0,0,0.1)";
        this.style.transform = "translateY(0)";
      });
    }

  </script>
</body>
</html>

