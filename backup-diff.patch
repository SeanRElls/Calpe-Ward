==== DIFF: index.html ====\n
diff --git "a/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\Calpe-Ward Backup\\Calpe-Ward\\index.html" "b/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\index.html"
index e453221..590d852 100644
--- "a/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\Calpe-Ward Backup\\Calpe-Ward\\index.html"	
+++ "b/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\index.html"	
@@ -471,6 +471,16 @@
     // Initialize on load
     window.addEventListener('load', () => {
       initSupabase();
+      
+      // Display debug logs if present
+      const logs = localStorage.getItem('calpeward_debug_logs');
+      if (logs) {
+        const logArray = JSON.parse(logs);
+        const debugPanel = document.createElement('div');
+        debugPanel.style.cssText = 'position: fixed; bottom: 20px; right: 20px; background: #f0f0f0; border: 1px solid #ccc; padding: 10px; max-width: 400px; max-height: 200px; overflow-y: auto; font-family: monospace; font-size: 11px; z-index: 9999;';
+        debugPanel.innerHTML = '<strong>Debug Logs:</strong><br>' + logArray.map(log => log.replace(/</g, '&lt;').replace(/>/g, '&gt;')).join('<br>');
+        document.body.appendChild(debugPanel);
+      }
 
       // If already logged in, redirect to rota
       const existingToken = sessionStorage.getItem(TOKEN_KEY);
\n
==== DIFF: js/admin.js ====\n
diff --git "a/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\Calpe-Ward Backup\\Calpe-Ward\\js\\admin.js" "b/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\js\\admin.js"
index 4c56b23..a8abfbe 100644
--- "a/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\Calpe-Ward Backup\\Calpe-Ward\\js\\admin.js"	
+++ "b/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\js\\admin.js"	
@@ -112,68 +112,21 @@
         .replaceAll("'","&#039;");
     }
 
-    function pinKey(userId){ return `calpeward.pin.${userId}`; }
-
-    const WINDOW_SESSION_PREFIX = "calpeward:";
-
-    function setWindowSession(userId, pin){
-      if (!userId || !pin) return;
-      try {
-        const payload = btoa(JSON.stringify({ userId: String(userId), pin: String(pin) }));
-        window.name = `${WINDOW_SESSION_PREFIX}${payload}`;
-      } catch (e) {
-        console.warn("Failed to store window session", e);
-      }
-    }
-
-    function getWindowSession(){
-      if (!window.name || !window.name.startsWith(WINDOW_SESSION_PREFIX)) {
-        console.log("[SESSION DEBUG] No window.name session. window.name=", window.name);
-        return null;
-      }
-      try {
-        const raw = window.name.slice(WINDOW_SESSION_PREFIX.length);
-        const session = JSON.parse(atob(raw));
-        console.log("[SESSION DEBUG] Window session found:", session);
-        return session;
-      } catch (e) {
-        console.warn("[SESSION DEBUG] Failed to parse window session", e);
-        return null;
-      }
-    }
-
-    function restoreSessionFromWindow(){
-      const data = getWindowSession();
-      console.log("[SESSION DEBUG] restoreSessionFromWindow: data=", data);
-      if (!data || !data.userId) {
-        console.log("[SESSION DEBUG] No data to restore");
-        return null;
-      }
-      console.log("[SESSION DEBUG] Restoring userId:", data.userId);
-      localStorage.setItem(STORAGE_KEY, data.userId);
-      console.log("[SESSION DEBUG] Set localStorage key:", STORAGE_KEY, "=", data.userId);
-      if (data.pin) {
-        sessionStorage.setItem(pinKey(data.userId), data.pin);
-        console.log("[SESSION DEBUG] Set sessionStorage pin for user", data.userId);
+    function getAdminToken(){
+      const token = window.currentToken || sessionStorage.getItem("calpe_ward_token");
+      if (!token) {
+        throw new Error("No session token available for admin panel.");
       }
-      return data;
+      return token;
     }
 
-    function clearWindowSession(){
-      if (window.name && window.name.startsWith(WINDOW_SESSION_PREFIX)) {
-        window.name = "";
-      }
-    }
+    function pinKey(userId){ return `calpeward.pin.${userId}`; }
 
-    function getSessionPinOrThrow(){
-      if (!currentUser) throw new Error("Not logged in.");
-      let pin = sessionStorage.getItem(pinKey(currentUser.id));
-      if (!pin) {
-        restoreSessionFromWindow();
-        pin = sessionStorage.getItem(pinKey(currentUser.id));
+    async function requireAdminPin(){
+      const ok = await promptAdminPinChallenge();
+      if (!ok) {
+        throw new Error("PIN verification failed.");
       }
-      if (!pin) throw new Error("Missing session PIN. Log in again.");
-      return pin;
     }
 
     // SECURITY PATCH: PIN Challenge for sensitive admin operations
@@ -231,10 +184,8 @@
         
         modal.querySelector("#adminPinConfirm").addEventListener("click", () => {
           const enteredPin = input.value;
-          const correctPin = getSessionPinOrThrow();
-          const isCorrect = enteredPin === correctPin;
           cleanup();
-          resolve(isCorrect);
+          resolve(enteredPin);
         });
         
         input.addEventListener("keypress", (e) => {
@@ -242,31 +193,61 @@
             modal.querySelector("#adminPinConfirm").click();
           }
         });
+      }).then(async (enteredPin) => {
+        if (!enteredPin || !/^\d{4}$/.test(String(enteredPin))) {
+          alert("PIN must be 4 digits.");
+          return false;
+        }
+
+        try {
+          const { data, error } = await supabaseClient.rpc("admin_verify_pin_challenge", {
+            p_token: currentToken,
+            p_pin: String(enteredPin)
+          });
+
+          if (error) throw error;
+
+          const result = Array.isArray(data) ? data[0] : data;
+          if (!result?.valid) {
+            alert("Invalid PIN.");
+            return false;
+          }
+
+          return true;
+        } catch (err) {
+          console.error("PIN verification failed:", err);
+          alert("PIN verification failed.");
+          return false;
+        }
       });
     }
 
     async function loadCurrentUser(){
       console.log("[SESSION DEBUG] loadCurrentUser: starting");
-      restoreSessionFromWindow();
       const savedId = localStorage.getItem(STORAGE_KEY);
       console.log("[SESSION DEBUG] loadCurrentUser: savedId from localStorage=", savedId);
-      if (!savedId){
+      let token = null;
+      try {
+        token = getAdminToken();
+      } catch (e) {
+        token = null;
+      }
+      if (!savedId || !token){
         console.log("[SESSION DEBUG] No savedId, showing auth notice");
         adminUserAuthNotice.style.display = "block";
         updateUserStatus(null);
         return null;
       }
-      const { data, error } = await supabaseClient
-        .from("users")
-        .select("id, name, role_id, is_admin, is_active")
-        .eq("id", savedId)
-        .single();
-      if (error || !data){
+      const { data, error } = await supabaseClient.rpc("rpc_get_current_user", {
+        p_token: token
+      });
+      const user = Array.isArray(data) ? data[0] : data;
+      if (error || !user){
         adminUserAuthNotice.style.display = "block";
         updateUserStatus(null);
         return null;
       }
-      currentUser = data;
+      currentUser = user;
       window.currentUser = currentUser; // Expose to window for other scripts
       await loadUserPermissions();
       if (!hasPermission("system.admin_panel")){
@@ -285,33 +266,16 @@
       try {
         const cachedRaw = localStorage.getItem("calpeward.users_cache");
         const cachedUsers = cachedRaw ? JSON.parse(cachedRaw) : [];
-        const { data: users, error } = await supabaseClient
-          .from("users")
-          .select("id, name, is_active")
-          .order("name", { ascending: true });
+        const { data: users, error } = await supabaseClient.rpc("admin_get_users", {
+          p_token: getAdminToken(),
+          p_include_inactive: true
+        });
         if (error) throw error;
         const sourceUsers = (users && users.length) ? users : cachedUsers;
 
-        const { data: permRows, error: permErr } = await supabaseClient
-          .from("permission_group_permissions")
-          .select("group_id")
-          .eq("permission_key", "system.admin_panel");
-        if (permErr) throw permErr;
-        const adminGroupIds = (permRows || []).map(r => r.group_id).filter(Boolean);
-
-        let adminUserIds = new Set();
-        if (adminGroupIds.length) {
-          const { data: groupUsers, error: guErr } = await supabaseClient
-            .from("user_permission_groups")
-            .select("user_id")
-            .in("group_id", adminGroupIds);
-          if (guErr) throw guErr;
-          adminUserIds = new Set((groupUsers || []).map(r => String(r.user_id)));
-        }
-
         let options = (sourceUsers || [])
           .filter(u => u.is_active !== false)
-          .filter(u => u.is_admin || adminUserIds.has(String(u.id)))
+          .filter(u => u.is_admin)
           .map(u => `<option value="${escapeHtml(u.id)}">${escapeHtml(u.name)}</option>`)
           .join("");
 
@@ -367,15 +331,14 @@
           if (adminLoginMsg) adminLoginMsg.textContent = "Invalid PIN.";
           return;
         }
-        const { data: user, error } = await supabaseClient
-          .from("users")
-          .select("id, name, role_id, is_admin, is_active")
-          .eq("id", userId)
-          .single();
+        const { data: userRows, error } = await supabaseClient.rpc("admin_get_user_by_id", {
+          p_token: currentToken,
+          p_user_id: userId
+        });
+        const user = Array.isArray(userRows) ? userRows[0] : userRows;
         if (error || !user) throw error || new Error("User not found");
         localStorage.setItem(STORAGE_KEY, user.id);
-        sessionStorage.setItem(pinKey(user.id), pin);
-        setWindowSession(user.id, pin);
+        sessionStorage.removeItem(pinKey(user.id));
         currentUser = user;
         window.currentUser = currentUser; // Expose to window for other scripts
         await loadUserPermissions();
@@ -402,19 +365,12 @@
       if (!currentUser) return;
       if (currentUser.is_admin) return;
       try {
-        const { data: groups, error: gErr } = await supabaseClient
-          .from("user_permission_groups")
-          .select("group_id")
-          .eq("user_id", currentUser.id);
-        if (gErr) throw gErr;
-        const groupIds = (groups || []).map(g => g.group_id).filter(Boolean);
-        if (!groupIds.length) return;
         const { data: perms, error: pErr } = await supabaseClient
-          .from("permission_group_permissions")
-          .select("permission_key")
-          .in("group_id", groupIds);
+          .rpc("rpc_get_user_permissions", { p_token: currentToken });
         if (pErr) throw pErr;
-        (perms || []).forEach(p => userPermissions.add(p.permission_key));
+        (perms || []).forEach(p => {
+          if (p.permission_key) userPermissions.add(p.permission_key);
+        });
       } catch (e) {
         console.warn("Failed to load user permissions", e);
       }
@@ -507,33 +463,25 @@
       }
       adminUsersList.textContent = "Loading users...";
 
-      const primarySelect = "id, name, role_id, is_admin, is_active, display_order, roles(name), pref_shift_clustering, pref_night_appetite, pref_weekend_appetite, pref_leave_adjacency, can_be_in_charge_day, can_be_in_charge_night, cannot_be_second_rn_day, cannot_be_second_rn_night, can_work_nights";
-      const fallbackSelect = "id, name, role_id, is_admin, is_active, display_order, roles(name)";
-
       let rows = null;
       try {
-        const { data, error } = await supabaseClient
-          .from("users")
-          .select(primarySelect)
-          .order("role_id", { ascending: true })
-          .order("display_order", { ascending: true })
-          .order("created_at", { ascending: true });
+        const { data, error } = await supabaseClient.rpc("admin_get_users", {
+          p_token: currentToken,
+          p_include_inactive: true
+        });
         if (error) throw error;
-        rows = data;
+        rows = (data || []).slice().sort((a, b) => {
+          const roleDiff = (a.role_id || 0) - (b.role_id || 0);
+          if (roleDiff !== 0) return roleDiff;
+          const aOrder = a.display_order ?? 9999;
+          const bOrder = b.display_order ?? 9999;
+          if (aOrder !== bOrder) return aOrder - bOrder;
+          return (a.name || "").localeCompare(b.name || "");
+        });
       } catch (err){
-        console.warn("loadAdminUsers: primary select failed, retrying fallback", err?.message || err);
-        const { data: fallbackData, error: fallbackErr } = await supabaseClient
-          .from("users")
-          .select(fallbackSelect)
-          .order("role_id", { ascending: true })
-          .order("display_order", { ascending: true })
-          .order("created_at", { ascending: true });
-        if (fallbackErr){
-          console.error(fallbackErr);
-          adminUsersList.textContent = "Failed to load users.";
-          return;
-        }
-        rows = fallbackData;
+        console.error(err);
+        adminUsersList.textContent = "Failed to load users.";
+        return;
       }
 
       adminUsersCache = rows || [];
@@ -925,11 +873,11 @@
         const rows = Array.from(adminUsersList.querySelectorAll(`.user-row[data-role-id="${roleId}"]`));
         for (let i = 0; i < rows.length; i++) {
           const userId = rows[i].dataset.userId;
-          const { error } = await supabaseClient
-            .from('users')
-            .update({ display_order: i + 1 })
-            .eq('id', userId)
-            .select();
+          const { error } = await supabaseClient.rpc("admin_reorder_users", {
+            p_token: currentToken,
+            p_user_id: userId,
+            p_display_order: i + 1
+          });
           if (error) throw error;
         }
         await loadAdminUsers();
@@ -1357,11 +1305,9 @@
       }
       try {
         // Load permissions from database
-        const { data: permissions, error } = await supabaseClient
-          .from("permissions")
-          .select("key, label, description, category")
-          .order("category", { ascending: true })
-          .order("key", { ascending: true });
+        const { data: permissions, error } = await supabaseClient.rpc("admin_get_permissions", {
+          p_token: currentToken
+        });
         
         if (error) throw error;
         
@@ -1390,10 +1336,9 @@
         });
         
         // Load permission groups
-        const { data: groups, error: groupsError } = await supabaseClient
-          .from("permission_groups")
-          .select("name")
-          .order("name", { ascending: true });
+        const { data: groups, error: groupsError } = await supabaseClient.rpc("admin_get_permission_groups", {
+          p_token: currentToken
+        });
         
         if (groupsError) throw groupsError;
         
@@ -1423,10 +1368,9 @@
     
     async function loadPatterns(){
       try {
-        const { data: patterns, error } = await supabaseClient
-          .from("pattern_definitions")
-          .select("id, name, cycle_weeks, weekly_targets, pattern_type, requires_anchor, notes")
-          .order("id", { ascending: true });
+        const { data: patterns, error } = await supabaseClient.rpc("rpc_get_pattern_definitions", {
+          p_token: currentToken
+        });
         if (error) throw error;
         
         const list = document.getElementById("patternsList");
@@ -1459,13 +1403,13 @@
 
     async function loadPatternDefinitions(){
       try {
-        const { data: patterns, error } = await supabaseClient
-          .from("pattern_definitions")
-          .select("id, name, requires_anchor")
-          .order("name", { ascending: true });
+        const { data: patterns, error } = await supabaseClient.rpc("rpc_get_pattern_definitions", {
+          p_token: currentToken
+        });
         if (error) throw error;
+        const sorted = (patterns || []).slice().sort((a, b) => (a.name || "").localeCompare(b.name || ""));
         
-        console.log("[PATTERNS] Loaded pattern definitions:", patterns);
+        console.log("[PATTERNS] Loaded pattern definitions:", sorted);
         
         const select = document.getElementById("adminUserPattern");
         if (!select) {
@@ -1474,8 +1418,8 @@
         }
         
         select.innerHTML = `<option value="">No fixed pattern</option>`;
-        if (patterns && patterns.length > 0){
-          patterns.forEach(p => {
+        if (sorted && sorted.length > 0){
+          sorted.forEach(p => {
             const opt = document.createElement("option");
             opt.value = String(p.id);
             opt.textContent = p.name || "Unknown";
@@ -1514,33 +1458,30 @@
       try {
         if (patternId){
           // Get pattern to check if anchor is required
-          const { data: pattern, error: patternErr } = await supabaseClient
-            .from("pattern_definitions")
-            .select("requires_anchor")
-            .eq("id", patternId)
-            .single();
+          const { data: patterns, error: patternErr } = await supabaseClient.rpc("rpc_get_pattern_definitions", {
+            p_token: currentToken
+          });
           if (patternErr) throw patternErr;
+          const pattern = (patterns || []).find(p => String(p.id) === String(patternId));
+          if (!pattern) throw new Error("Pattern not found.");
           
           console.log("[PATTERNS] Pattern found:", pattern);
           
           // Upsert user pattern
-          const { data: result, error: upsertErr } = await supabaseClient
-            .from("user_patterns")
-            .upsert({
-              user_id: userId,
-              pattern_id: patternId,
-              anchor_week_start_date: pattern.requires_anchor ? anchorDate : null,
-              assigned_by: currentUser.id,
-              assigned_at: new Date().toISOString()
-            }, { onConflict: "user_id" });
+          const { error: upsertErr } = await supabaseClient.rpc("admin_upsert_user_pattern", {
+            p_token: currentToken,
+            p_user_id: userId,
+            p_pattern_id: patternId,
+            p_anchor_week_start_date: pattern.requires_anchor ? anchorDate : null
+          });
           if (upsertErr) throw upsertErr;
-          console.log("[PATTERNS] Pattern saved successfully:", result);
+          console.log("[PATTERNS] Pattern saved successfully");
         } else {
           // Delete user pattern if no pattern selected
-          const { error: deleteErr } = await supabaseClient
-            .from("user_patterns")
-            .delete()
-            .eq("user_id", userId);
+          const { error: deleteErr } = await supabaseClient.rpc("admin_delete_user_pattern", {
+            p_token: currentToken,
+            p_user_id: userId
+          });
           if (deleteErr) throw deleteErr;
           console.log("[PATTERNS] Pattern cleared.");
         }
@@ -1560,16 +1501,14 @@
       if (!patternSelect || !anchorDateInput) return;
       
       try {
-        const { data: userPattern, error } = await supabaseClient
-          .from("user_patterns")
-          .select("pattern_id, anchor_week_start_date")
-          .eq("user_id", userId)
-          .single();
+        const { data: patterns, error } = await supabaseClient.rpc("rpc_get_user_patterns", {
+          p_token: currentToken
+        });
         
-        if (error && error.code !== "PGRST116"){
+        if (error){
           throw error;
         }
-        
+        const userPattern = (patterns || []).find(p => String(p.user_id) === String(userId));
         if (userPattern){
           patternSelect.value = String(userPattern.pattern_id || "");
           anchorDateInput.value = userPattern.anchor_week_start_date || "";
@@ -1599,10 +1538,9 @@
 
     async function loadPermissionGroups(){
       try {
-        const { data, error } = await supabaseClient
-          .from("permission_groups")
-          .select("id, name, is_system, is_protected")
-          .order("name", { ascending: true });
+        const { data, error } = await supabaseClient.rpc("admin_get_permission_groups", {
+          p_token: currentToken
+        });
         if (error) throw error;
         permissionGroups = data || [];
       } catch (e) {
@@ -1641,10 +1579,10 @@
       groupPermissions = new Set();
       if (!groupId) return;
       try {
-        const { data, error } = await supabaseClient
-          .from("permission_group_permissions")
-          .select("permission_key")
-          .eq("group_id", groupId);
+        const { data, error } = await supabaseClient.rpc("admin_get_permission_group_permissions", {
+          p_token: currentToken,
+          p_group_id: groupId
+        });
         if (error) throw error;
         (data || []).forEach(r => groupPermissions.add(r.permission_key));
       } catch (e) {
@@ -1709,12 +1647,12 @@
       const checkboxes = Array.from(permissionsMatrix.querySelectorAll("input[data-perm-key]"));
       const keys = checkboxes.filter(c => c.checked).map(c => c.dataset.permKey);
       try {
-        await supabaseClient.from("permission_group_permissions").delete().eq("group_id", groupId);
-        if (keys.length){
-          const rows = keys.map(k => ({ group_id: groupId, permission_key: k }));
-          const { error } = await supabaseClient.from("permission_group_permissions").insert(rows);
-          if (error) throw error;
-        }
+        const { error } = await supabaseClient.rpc("admin_set_permission_group_permissions", {
+          p_token: currentToken,
+          p_group_id: groupId,
+          p_permission_keys: keys
+        });
+        if (error) throw error;
       } catch (e) {
         console.error(e);
         alert("Failed to save permissions. Check console.");
@@ -1726,15 +1664,14 @@
       const name = (permissionGroupName?.value || "").trim();
       if (!name) return alert("Group name required.");
       try {
-        const { data, error } = await supabaseClient
-          .from("permission_groups")
-          .insert({ name })
-          .select()
-          .single();
+        const { data, error } = await supabaseClient.rpc("admin_create_permission_group", {
+          p_token: currentToken,
+          p_name: name
+        });
         if (error) throw error;
         permissionGroupName.value = "";
         await loadPermissionGroups();
-        permissionGroupSelect.value = String(data.id);
+        permissionGroupSelect.value = String(data);
         groupPermissions = new Set();
         renderPermissionsMatrix();
       } catch (e) {
@@ -1786,12 +1723,13 @@
         return;
       }
       try {
-        const { data, error } = await supabaseClient
-          .from("user_permission_groups")
-          .select("group_id, permission_groups(name)")
-          .eq("user_id", userId);
+        const { data, error } = await supabaseClient.rpc("admin_get_user_permission_groups", {
+          p_token: currentToken,
+          p_user_id: userId
+        });
         if (error) throw error;
-        const names = new Set((data || []).map(r => r.permission_groups?.name).filter(Boolean));
+        const ids = new Set((data || []).map(r => String(r.group_id)));
+        const names = new Set(permissionGroups.filter(g => ids.has(String(g.id))).map(g => g.name));
         checks.forEach(c => {
           c.checked = names.has(c.dataset.permGroup);
           c.disabled = false;
@@ -1816,12 +1754,12 @@
         .map(g => g.id);
 
       try {
-        await supabaseClient.from("user_permission_groups").delete().eq("user_id", userId);
-        if (groupIds.length){
-          const rows = groupIds.map(id => ({ user_id: userId, group_id: id }));
-          const { error } = await supabaseClient.from("user_permission_groups").insert(rows);
-          if (error) throw error;
-        }
+        const { error } = await supabaseClient.rpc("admin_set_user_permission_groups", {
+          p_token: currentToken,
+          p_user_id: userId,
+          p_group_ids: groupIds
+        });
+        if (error) throw error;
       } catch (e) {
         console.error(e);
         alert("Failed to save user groups. Check console.");
@@ -1837,24 +1775,11 @@
       try {
         let styleFieldsAvailable = true;
         let shifts;
-        // Try to include styling columns; if they don't exist, fallback without them
-        try {
-          const { data, error } = await supabaseClient
-            .from("shifts")
-            .select("id, code, label, hours_value, start_time, end_time, day_or_night, allowed_staff_groups, allow_requests, allow_draft, allow_post_publish, fill_color, text_color, text_bold, text_italic, is_time_off")
-            .order("code", { ascending: true });
-          if (error) throw error;
-          shifts = data;
-        } catch (e) {
-          console.warn("[SHIFTS] Styling or is_time_off columns not found; falling back without them", e?.message);
-          styleFieldsAvailable = false;
-          const { data, error } = await supabaseClient
-            .from("shifts")
-            .select("id, code, label, hours_value, start_time, end_time, day_or_night, allowed_staff_groups, allow_requests, allow_draft, allow_post_publish")
-            .order("code", { ascending: true });
-          if (error) throw error;
-          shifts = data;
-        }
+        const { data, error } = await supabaseClient.rpc("admin_get_shifts", {
+          p_token: currentToken
+        });
+        if (error) throw error;
+        shifts = data;
 
         allShifts = shifts || [];
 
@@ -2025,11 +1950,25 @@
         console.log("[SAVE SHIFT] Update data:", updateData);
         console.log("[SAVE SHIFT] Shift ID:", currentEditingShiftId);
 
-        const { data: result, error: updateErr } = await supabaseClient
-          .from("shifts")
-          .update(updateData)
-          .eq("id", currentEditingShiftId)
-          .select();
+        const { data: result, error: updateErr } = await supabaseClient.rpc("admin_upsert_shift", {
+          p_token: currentToken,
+          p_shift_id: currentEditingShiftId,
+          p_code: document.getElementById("editShiftCode").value,
+          p_label: updateData.label,
+          p_hours_value: updateData.hours_value,
+          p_start_time: updateData.start_time,
+          p_end_time: updateData.end_time,
+          p_day_or_night: updateData.day_or_night,
+          p_allowed_staff_groups: updateData.allowed_staff_groups,
+          p_allow_requests: updateData.allow_requests,
+          p_allow_draft: updateData.allow_draft,
+          p_allow_post_publish: updateData.allow_post_publish,
+          p_fill_color: updateData.fill_color,
+          p_text_color: updateData.text_color,
+          p_text_bold: updateData.text_bold,
+          p_text_italic: updateData.text_italic,
+          p_is_time_off: updateData.is_time_off
+        });
 
         console.log("[SAVE SHIFT] Update response - data:", result, "error:", updateErr);
 
@@ -2051,10 +1990,10 @@
       }
 
       try {
-        const { error: deleteErr } = await supabaseClient
-          .from("shifts")
-          .delete()
-          .eq("id", shiftId);
+        const { error: deleteErr } = await supabaseClient.rpc("admin_delete_shift", {
+          p_token: currentToken,
+          p_shift_id: shiftId
+        });
         
         if (deleteErr) throw deleteErr;
 
@@ -2082,28 +2021,27 @@
         if (document.getElementById("newShiftSN").checked) staffGroups.push("Nurse");
         if (document.getElementById("newShiftCN").checked) staffGroups.push("CN");
 
-        const { data: newShift, error: insertErr } = await supabaseClient
-          .from("shifts")
-          .insert({
-            code: code,
-            label: label,
-            start_time: document.getElementById("newShiftStart").value || null,
-            end_time: document.getElementById("newShiftEnd").value || null,
-            hours_value: parseFloat(document.getElementById("newShiftHours").value) || 0,
-            allowed_staff_groups: staffGroups.join(","),
-            allow_requests: document.getElementById("newShiftRequests").checked,
-            allow_draft: document.getElementById("newShiftRotaDraft").checked,
-            allow_post_publish: document.getElementById("newShiftRotaPost").checked,
-            is_time_off: document.getElementById("newShiftIsTimeOff").checked,
-            fill_color: document.getElementById("newShiftFill").value || null,
-            text_color: document.getElementById("newShiftText").value || null,
-            text_bold: document.getElementById("newShiftBold").checked,
-            text_italic: document.getElementById("newShiftItalic").checked,
-            day_or_night: "day"
-          })
-          .select();
+        const { data: newShiftId, error: insertErr } = await supabaseClient.rpc("admin_upsert_shift", {
+          p_token: currentToken,
+          p_shift_id: null,
+          p_code: code,
+          p_label: label,
+          p_hours_value: parseFloat(document.getElementById("newShiftHours").value) || 0,
+          p_start_time: document.getElementById("newShiftStart").value || null,
+          p_end_time: document.getElementById("newShiftEnd").value || null,
+          p_day_or_night: "day",
+          p_allowed_staff_groups: staffGroups.join(","),
+          p_allow_requests: document.getElementById("newShiftRequests").checked,
+          p_allow_draft: document.getElementById("newShiftRotaDraft").checked,
+          p_allow_post_publish: document.getElementById("newShiftRotaPost").checked,
+          p_fill_color: document.getElementById("newShiftFill").value || null,
+          p_text_color: document.getElementById("newShiftText").value || null,
+          p_text_bold: document.getElementById("newShiftBold").checked,
+          p_text_italic: document.getElementById("newShiftItalic").checked,
+          p_is_time_off: document.getElementById("newShiftIsTimeOff").checked
+        });
         if (insertErr) throw insertErr;
-        if (!newShift || newShift.length === 0) throw new Error("Failed to create shift");
+        if (!newShiftId) throw new Error("Failed to create shift");
 
         alert("Shift created successfully!");
         document.getElementById("createShiftModal").style.display = "none";
@@ -2606,22 +2544,9 @@
     async function loadAdminNotices(){
       if (!currentUser?.is_admin && !hasPermission("notices.view_admin")) return;
 
-      const { data, error } = await supabaseClient
-        .from("notices")
-        .select(`
-          id,
-          title,
-          body_en,
-          body_es,
-          version,
-          is_active,
-          updated_at,
-          created_by,
-          target_all,
-          target_roles,
-          users:created_by ( name )
-        `)
-        .order("updated_at", { ascending: false });
+      const { data, error } = await supabaseClient.rpc("admin_get_all_notices", {
+        p_token: currentToken
+      });
 
       if (error){
         console.error(error);
@@ -2629,7 +2554,22 @@
         return;
       }
 
-      adminNoticesCache = data || [];
+      const notices = data || [];
+      let usersMap = new Map();
+      try {
+        const { data: users } = await supabaseClient.rpc("admin_get_users", {
+          p_token: currentToken,
+          p_include_inactive: true
+        });
+        usersMap = new Map((users || []).map(u => [String(u.id), u.name]));
+      } catch (e) {
+        usersMap = new Map();
+      }
+
+      adminNoticesCache = notices.map(n => ({
+        ...n,
+        users: { name: usersMap.get(String(n.created_by)) || "Unknown" }
+      }));
 
       // Fetch ack counts
       try {
@@ -2664,7 +2604,7 @@
     }
 
     async function adminUpsertNotice(payload){
-      const pin = getSessionPinOrThrow();
+      await requireAdminPin();
 
       const targetRoles = Array.isArray(payload.target_roles) ? payload.target_roles : [];
       const targetAll = !!payload.target_all && targetRoles.length === 0;
@@ -2684,7 +2624,7 @@
     }
 
     async function toggleAdminNoticeActive(notice){
-      const pin = getSessionPinOrThrow();
+      await requireAdminPin();
 
       const next = (notice.is_active === false) ? true : false;
       const ok = confirm(`${next ? "Unhide" : "Hide"} "${notice.title}"?`);
@@ -2702,7 +2642,7 @@
     }
 
     async function deleteAdminNotice(notice){
-      const pin = getSessionPinOrThrow();
+      await requireAdminPin();
 
       const ok = confirm(`Delete "${notice.title}"?\n\nThis cannot be undone.`);
       if (!ok) return;
@@ -2984,7 +2924,6 @@
             approveBtn.disabled = false;
             return;
           }
-          const pin = getSessionPinOrThrow();
           const { data, error } = await supabaseClient.rpc("admin_approve_swap_request", {
             p_token: currentToken,
             p_swap_request_id: swapId
@@ -3019,7 +2958,6 @@
             declineBtn.disabled = false;
             return;
           }
-          const pin = getSessionPinOrThrow();
           const { data, error } = await supabaseClient.rpc("admin_decline_swap_request", {
             p_token: currentToken,
             p_swap_request_id: swapId
@@ -3142,4 +3080,3 @@
         }
       });
     }
-
\n
==== DIFF: js/admin-periods.js ====\n
diff --git "a/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\Calpe-Ward Backup\\Calpe-Ward\\js\\admin-periods.js" "b/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\js\\admin-periods.js"
index 5ac8592..7631899 100644
--- "a/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\Calpe-Ward Backup\\Calpe-Ward\\js\\admin-periods.js"	
+++ "b/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\js\\admin-periods.js"	
@@ -87,13 +87,14 @@ periodsPageTabs.forEach(tab => {
 
 // Fetch all periods
 async function fetchRotaPeriods() {
-  const { data, error } = await supabaseClient
-    .from('rota_periods')
-    .select('*')
-    .order('start_date', { ascending: false });
+  const { data, error } = await supabaseClient.rpc("rpc_get_rota_periods", {
+    p_token: window.currentToken
+  });
   
   if (error) throw error;
-  return data || [];
+  const periods = data || [];
+  periods.sort((a, b) => new Date(b.start_date) - new Date(a.start_date));
+  return periods;
 }
 
 // Load periods into dropdown
@@ -168,11 +169,10 @@ function renderAdminCloseTime(periodId) {
 async function loadAdminWeeks(periodId) {
   adminWeeksList.textContent = 'Loading weeksÔÇª';
 
-  const { data, error } = await supabaseClient
-    .from('rota_dates')
-    .select('date, week_id, period_id, rota_weeks(id, open, open_after_close)')
-    .eq('period_id', periodId)
-    .order('date');
+  const { data, error } = await supabaseClient.rpc("rpc_get_rota_weeks", {
+    p_token: window.currentToken,
+    p_period_id: periodId
+  });
 
   if (error) {
     console.error(error);
@@ -180,34 +180,15 @@ async function loadAdminWeeks(periodId) {
     return;
   }
 
-  // Build unique weeks list
-  const weekMap = new Map();
-
-  for (const row of (data || [])) {
-    const w = row.rota_weeks;
-    if (!w?.id) continue;
-
-    const ws = startOfWeekSunday(new Date(row.date));
-    const we = addDays(ws, 6);
-
-    if (!weekMap.has(w.id)) {
-      weekMap.set(w.id, {
-        weekId: w.id,
-        open: !!w.open,
-        openAfterClose: !!w.open_after_close,
-        weekStart: ws,
-        weekEnd: we
-      });
-    } else {
-      const existing = weekMap.get(w.id);
-      existing.open = existing.open && !!w.open;
-      existing.openAfterClose = existing.openAfterClose && !!w.open_after_close;
-      if (ws < existing.weekStart) existing.weekStart = ws;
-      if (we > existing.weekEnd) existing.weekEnd = we;
-    }
-  }
-
-  const weeks = [...weekMap.values()].sort((a, b) => a.weekStart - b.weekStart);
+  const weeks = (data || [])
+    .map(w => ({
+      weekId: w.id,
+      open: !!w.open,
+      openAfterClose: !!w.open_after_close,
+      weekStart: new Date(w.week_start),
+      weekEnd: new Date(w.week_end)
+    }))
+    .sort((a, b) => a.weekStart - b.weekStart);
 
   if (!weeks.length) {
     adminWeeksList.textContent = 'No weeks found for this period.';
@@ -410,20 +391,11 @@ if (adminClosesAtClearBtn) {
 }
 
 async function resetWeeksAfterClose(periodId) {
-  const { data: wkRows, error: wkErr } = await supabaseClient
-    .from('rota_dates')
-    .select('week_id')
-    .eq('period_id', periodId);
-
-  if (wkErr) throw wkErr;
-
-  const weekIds = [...new Set((wkRows || []).map(r => r.week_id).filter(Boolean))];
-  if (!weekIds.length) return;
-
-  const { error: resetErr } = await supabaseClient
-    .from('rota_weeks')
-    .update({ open_after_close: false })
-    .in('id', weekIds);
+  const { error: resetErr } = await supabaseClient.rpc("admin_set_weeks_open_after_close", {
+    p_token: window.currentToken,
+    p_period_id: periodId,
+    p_open_after_close: false
+  });
 
   if (resetErr) throw resetErr;
 }
\n
==== DIFF: js/admin-status-dashboard.js ====\n
diff --git "a/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\Calpe-Ward Backup\\Calpe-Ward\\js\\admin-status-dashboard.js" "b/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\js\\admin-status-dashboard.js"
index 4bfe356..60a6cb6 100644
--- "a/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\Calpe-Ward Backup\\Calpe-Ward\\js\\admin-status-dashboard.js"	
+++ "b/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\js\\admin-status-dashboard.js"	
@@ -16,6 +16,25 @@ let statusDashboardData = {
   prevStaffCount: 0
 };
 
+function getDashboardToken() {
+  const token = window.currentToken || sessionStorage.getItem("calpe_ward_token");
+  if (!token) {
+    throw new Error("No session token available for admin dashboard.");
+  }
+  return token;
+}
+
+async function fetchRotaPeriods() {
+  const token = getDashboardToken();
+  const { data, error } = await window.supabaseClient.rpc("rpc_get_rota_periods", {
+    p_token: token
+  });
+  if (error) throw error;
+  const periods = Array.isArray(data) ? data.slice() : [];
+  periods.sort((a, b) => new Date(a.start_date) - new Date(b.start_date));
+  return periods;
+}
+
 /**
  * Initialize the status dashboard
  */
@@ -83,16 +102,9 @@ async function loadStatusDashboardData() {
  */
 async function loadPeriodInfo() {
   try {
-    const { data: period, error } = await window.supabaseClient
-      .from("rota_periods")
-      .select("id, name, start_date, end_date, published_at, status")
-      .order("start_date", { ascending: false })
-      .limit(1)
-      .single();
-    
-    if (error && error.code !== "PGRST116") throw error;
-    
-    statusDashboardData.period = period;
+    const periods = await fetchRotaPeriods();
+    statusDashboardData.period = periods.length ? periods[periods.length - 1] : null;
+    statusDashboardData._periodsCache = periods;
   } catch (error) {
     console.error("[STATUS-DASHBOARD] Error loading period:", error);
   }
@@ -103,30 +115,27 @@ async function loadPeriodInfo() {
  */
 async function loadPreviousPeriodInfo() {
   try {
-    const { data: periods, error } = await window.supabaseClient
-      .from("rota_periods")
-      .select("id, name, start_date, end_date, published_at, status")
-      .order("start_date", { ascending: false })
-      .limit(2);
-    
-    if (error) throw error;
-    
-    // Second result is the previous period
-    statusDashboardData.prevPeriod = periods?.length > 1 ? periods[1] : null;
+    const periods = statusDashboardData._periodsCache || await fetchRotaPeriods();
+    statusDashboardData.prevPeriod = periods.length > 1 ? periods[periods.length - 2] : null;
     
     // Load staffing data for previous period
     if (statusDashboardData.prevPeriod?.id) {
-      const { data: staff, count: staffCount } = await window.supabaseClient
-        .from("users")
-        .select("id", { count: "exact" })
-        .eq("is_active", true);
-      
-      statusDashboardData.prevStaffCount = staffCount || 0;
-      
-      // Get all assignments for previous period (don't filter by period_id since it doesn't exist)
-      const { data: assignments, count: assignCount } = await window.supabaseClient
-        .from("rota_assignments")
-        .select("id", { count: "exact" });
+      const token = getDashboardToken();
+      const { data: staff, error: staffError } = await window.supabaseClient.rpc("admin_get_users", {
+        p_token: token,
+        p_include_inactive: true
+      });
+      if (staffError) throw staffError;
+      const activeStaff = Array.isArray(staff) ? staff.filter(u => u.is_active) : [];
+      statusDashboardData.prevStaffCount = activeStaff.length;
+
+      const { data: assignments, error: assignError } = await window.supabaseClient.rpc("rpc_get_rota_assignments", {
+        p_token: token,
+        p_period_id: statusDashboardData.prevPeriod.id,
+        p_include_draft: true
+      });
+      if (assignError) throw assignError;
+      const assignCount = Array.isArray(assignments) ? assignments.length : 0;
       
       if (statusDashboardData.prevStaffCount > 0) {
         const expectedAssignments = statusDashboardData.prevStaffCount * 30;
@@ -141,24 +150,6 @@ async function loadPreviousPeriodInfo() {
   }
 }
 
-/**
-async function loadPeriodInfo() {
-  try {
-    const { data: period, error } = await window.supabaseClient
-      .from("rota_periods")
-      .select("id, name, start_date, end_date, published_at, status")
-      .order("start_date", { ascending: false })
-      .limit(1)
-      .single();
-    
-    if (error && error.code !== "PGRST116") throw error;
-    
-    statusDashboardData.period = period;
-  } catch (error) {
-    console.error("[STATUS-DASHBOARD] Error loading period:", error);
-  }
-}
-
 /**
  * Load request counts
  */
@@ -166,29 +157,20 @@ async function loadRequestCounts() {
   try {
     if (!statusDashboardData.period?.id) return;
     
-    // Swap requests
-    const { data: swaps, error: swapError, count: swapCount } = await window.supabaseClient
-      .from("swap_requests")
-      .select("id", { count: "exact" })
-      .eq("period_id", statusDashboardData.period.id)
-      .eq("status", "pending");
-    
-    if (!swapError) {
-      statusDashboardData.swapRequests = swapCount || 0;
-    }
-    
-    // Time-off requests - assuming there's a time_off_requests or similar table
-    // Adjust table name if needed
-    const { data: timeoff, error: timeoffError, count: timeoffCount } = await window.supabaseClient
-      .from("swap_requests")
-      .select("id", { count: "exact" })
-      .eq("period_id", statusDashboardData.period.id)
-      .eq("status", "pending")
-      .like("initiator_shift_code", "O%");
-    
-    if (!timeoffError) {
-      statusDashboardData.timeoffRequests = timeoffCount || 0;
-    }
+    const token = getDashboardToken();
+    const { data: swaps, error: swapError } = await window.supabaseClient.rpc("admin_get_swap_requests", {
+      p_token: token
+    });
+    if (swapError) throw swapError;
+
+    const swapRows = Array.isArray(swaps) ? swaps : [];
+    const pendingSwaps = swapRows.filter(
+      s => s.period_id === statusDashboardData.period.id && s.status === "pending"
+    );
+    statusDashboardData.swapRequests = pendingSwaps.length;
+
+    const pendingTimeoff = pendingSwaps.filter(s => (s.initiator_shift_code || "").startsWith("O"));
+    statusDashboardData.timeoffRequests = pendingTimeoff.length;
     
   } catch (error) {
     console.error("[STATUS-DASHBOARD] Error loading request counts:", error);
@@ -203,22 +185,26 @@ async function loadStaffingInfo() {
     if (!statusDashboardData.period?.id) return;
     
     // Total active staff
-    const { data: staff, error: staffError, count: staffCount } = await window.supabaseClient
-      .from("users")
-      .select("id", { count: "exact" })
-      .eq("is_active", true);
-    
-    if (!staffError) {
-      statusDashboardData.staffCount = staffCount || 0;
-    }
+    const token = getDashboardToken();
+    const { data: staff, error: staffError } = await window.supabaseClient.rpc("admin_get_users", {
+      p_token: token,
+      p_include_inactive: true
+    });
+    if (staffError) throw staffError;
+    const activeStaff = Array.isArray(staff) ? staff.filter(u => u.is_active) : [];
+    statusDashboardData.staffCount = activeStaff.length;
     
     // Calculate coverage percentage - query published shifts instead
     // Since rota_assignments doesn't have period_id directly
-    const { data: assignments, error: assignError, count: assignCount } = await window.supabaseClient
-      .from("rota_assignments")
-      .select("id", { count: "exact" });
-    
-    if (!assignError && statusDashboardData.staffCount > 0) {
+    const { data: assignments, error: assignError } = await window.supabaseClient.rpc("rpc_get_rota_assignments", {
+      p_token: token,
+      p_period_id: statusDashboardData.period.id,
+      p_include_draft: true
+    });
+    if (assignError) throw assignError;
+
+    const assignCount = Array.isArray(assignments) ? assignments.length : 0;
+    if (statusDashboardData.staffCount > 0) {
       const expectedAssignments = statusDashboardData.staffCount * 30; // rough estimate for 30-day period
       statusDashboardData.coverage = Math.min(
         100,
@@ -248,11 +234,11 @@ async function checkUnderstaffedDays() {
     }
     
     // Get staffing requirements for this period
-    const { data: requirements, error: reqError } = await window.supabaseClient
-      .from("staffing_requirements")
-      .select("date, day_sn_required, day_na_required, night_sn_required, night_na_required")
-      .eq("period_id", statusDashboardData.period.id)
-      .order("date", { ascending: true });
+    const token = getDashboardToken();
+    const { data: requirements, error: reqError } = await window.supabaseClient.rpc("admin_get_staffing_requirements", {
+      p_token: token,
+      p_period_id: statusDashboardData.period.id
+    });
     
     if (reqError || !requirements || requirements.length === 0) {
       console.log("[STATUS-DASHBOARD] No staffing requirements found");
@@ -263,9 +249,11 @@ async function checkUnderstaffedDays() {
     console.log("[STATUS-DASHBOARD] Found " + requirements.length + " days with requirements");
     
     // Get actual assignments for this period
-    const { data: assignments, error: assignError } = await window.supabaseClient
-      .from("rota_assignments")
-      .select("date, shift_id");
+    const { data: assignments, error: assignError } = await window.supabaseClient.rpc("rpc_get_rota_assignments", {
+      p_token: token,
+      p_period_id: statusDashboardData.period.id,
+      p_include_draft: false
+    });
     
     if (assignError || !assignments) {
       console.warn("[STATUS-DASHBOARD] Error fetching assignments:", assignError);
\n
==== DIFF: js/audit-trail.js ====\n
diff --git "a/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\Calpe-Ward Backup\\Calpe-Ward\\js\\audit-trail.js" "b/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\js\\audit-trail.js"
index 2177c25..74e87d0 100644
--- "a/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\Calpe-Ward Backup\\Calpe-Ward\\js\\audit-trail.js"	
+++ "b/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\js\\audit-trail.js"	
@@ -21,6 +21,7 @@ async function loadAuditLogs() {
     // Use unified audit trail RPC that combines audit_logs and rota_assignment_history
     const { data: logs, error } = await window.supabaseClient
       .rpc("get_unified_audit_trail", {
+        p_token: window.currentToken,
         p_days_back: daysBack,
         p_action_filter: filterAction,
         p_user_filter: filterUser
@@ -156,27 +157,25 @@ async function exportAuditLogsCSV() {
     startDate.setDate(startDate.getDate() - daysBack);
 
     const { data: logs, error } = await window.supabaseClient
-      .from("audit_logs")
-      .select("*")
-      .gte("created_at", startDate.toISOString())
-      .lte("created_at", endDate.toISOString())
-      .order("created_at", { ascending: false })
-      .limit(5000);
+      .rpc("get_unified_audit_trail", {
+        p_token: window.currentToken,
+        p_days_back: daysBack,
+        p_action_filter: null,
+        p_user_filter: null
+      });
 
     if (error) throw error;
 
     // Build CSV
-    const headers = ["Timestamp", "Action", "User ID", "Impersonator ID", "Target User ID", "Resource Type", "Resource ID", "Status", "Error Message"];
+    const headers = ["Timestamp", "Action", "User ID", "Target User ID", "Resource Type", "Status", "Details"];
     const rows = logs.map((log) => [
       new Date(log.created_at).toLocaleString("en-GB"),
       log.action || "",
       log.user_id || "",
-      log.impersonator_user_id || "",
       log.target_user_id || "",
       log.resource_type || "",
-      log.resource_id || "",
       log.status || "",
-      (log.error_message || "").replace(/"/g, '""') // Escape quotes
+      JSON.stringify(log.metadata || {}).replace(/"/g, '""')
     ]);
 
     let csv = headers.join(",") + "\n";
\n
==== DIFF: js/audit-trail-enhanced.js ====\n
diff --git "a/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\Calpe-Ward Backup\\Calpe-Ward\\js\\audit-trail-enhanced.js" "b/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\js\\audit-trail-enhanced.js"
index 91b437a..4cb1580 100644
--- "a/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\Calpe-Ward Backup\\Calpe-Ward\\js\\audit-trail-enhanced.js"	
+++ "b/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\js\\audit-trail-enhanced.js"	
@@ -34,9 +34,14 @@ function initAuditTrail() {
  */
 async function loadUsers() {
   try {
-    const { data: users, error } = await window.supabaseClient
-      .from("users")
-      .select("id, name, is_admin, role_id");
+    const token = window.currentToken || sessionStorage.getItem("calpe_ward_token");
+    if (!token) {
+      throw new Error("No session token available for audit user list.");
+    }
+    const { data: users, error } = await window.supabaseClient.rpc("admin_get_users", {
+      p_token: token,
+      p_include_inactive: true
+    });
     
     if (error) throw error;
     
@@ -117,6 +122,7 @@ async function loadAuditLogs() {
     // Use unified audit trail RPC
     const { data: logs, error } = await window.supabaseClient
       .rpc("get_unified_audit_trail", {
+        p_token: window.currentToken,
         p_days_back: Math.max(daysBack, 365), // Cap at 365 days
         p_action_filter: filterAction,
         p_user_filter: filterActorUser,
@@ -327,28 +333,28 @@ async function exportAuditLogsCSV() {
       return;
     }
 
+    const daysBack = Math.ceil((new Date() - new Date(startDate + "T00:00:00")) / (1000 * 60 * 60 * 24));
     const { data: logs, error } = await window.supabaseClient
-      .from("audit_logs")
-      .select("*")
-      .gte("created_at", startDate + "T00:00:00")
-      .lte("created_at", endDate + "T23:59:59")
-      .order("created_at", { ascending: false })
-      .limit(10000);
+      .rpc("get_unified_audit_trail", {
+        p_token: window.currentToken,
+        p_days_back: Math.max(daysBack, 365),
+        p_action_filter: null,
+        p_user_filter: null,
+        p_target_user_filter: null
+      });
 
     if (error) throw error;
 
     // Build CSV with name resolution
-    const headers = ["Timestamp", "Action", "User", "Impersonator", "Target User", "Resource Type", "Resource ID", "Status", "Error Message"];
+    const headers = ["Timestamp", "Action", "User", "Target User", "Resource Type", "Status", "Details"];
     const rows = logs.map((log) => [
       new Date(log.created_at).toLocaleString("en-GB"),
       log.action || "",
       getUserName(log.user_id),
-      log.impersonator_user_id ? getUserName(log.impersonator_user_id) : "",
       log.target_user_id ? getUserName(log.target_user_id) : "",
       log.resource_type || "",
-      log.resource_id || "",
       log.status || "",
-      log.error_message || ""
+      JSON.stringify(log.metadata || {})
     ]);
 
     const csv = [headers, ...rows].map(row => row.map(escapeCSV).join(",")).join("\n");
\n
==== DIFF: js/permissions.js ====\n
diff --git "a/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\Calpe-Ward Backup\\Calpe-Ward\\js\\permissions.js" "b/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\js\\permissions.js"
index c1f614a..102b46c 100644
--- "a/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\Calpe-Ward Backup\\Calpe-Ward\\js\\permissions.js"	
+++ "b/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\js\\permissions.js"	
@@ -3,6 +3,14 @@
  * Handles permission checking for all pages based on user's permission groups
  */
 
+// Debug logging utility - persists through page reloads
+window.DEBUG_LOGS = window.DEBUG_LOGS || [];
+function debugLog(msg) {
+  console.log(msg);
+  window.DEBUG_LOGS.push(msg);
+  localStorage.setItem('calpeward_debug_logs', JSON.stringify(window.DEBUG_LOGS.slice(-50))); // Keep last 50
+}
+
 // Module-scoped variables (not polluting global scope)
 (function() {
   let currentUser = null;
@@ -13,93 +21,71 @@
  * @returns {Promise<Object|null>} User object or null
  */
 async function loadCurrentUserPermissions() {
-  const STORAGE_KEY = "calpeward.loggedInUserId";
   const IMPERSONATION_TOKEN_KEY = "calpeward.impersonationToken";
   const VIEW_AS_STORAGE_KEY = "calpeward.viewAs";
   
   // Check if we're in impersonation mode
   const impersonationToken = sessionStorage.getItem(IMPERSONATION_TOKEN_KEY);
   const viewAsUser = sessionStorage.getItem(VIEW_AS_STORAGE_KEY);
-  
-  let savedId;
-  
-  if (impersonationToken && viewAsUser) {
-    // We're viewing as someone - use the impersonated user
-    try {
-      const parsedUser = JSON.parse(viewAsUser);
-      savedId = parsedUser.id;
-      console.log("[PERMISSIONS] Loading impersonated user:", parsedUser.name);
-    } catch (e) {
-      console.error("[PERMISSIONS] Failed to parse viewAsUser:", e);
-      savedId = localStorage.getItem(STORAGE_KEY);
-    }
-  } else {
-    // Normal mode - use admin's ID
-    savedId = localStorage.getItem(STORAGE_KEY);
-  }
-  
-  if (!savedId) {
-    console.warn("[PERMISSIONS] No user ID in localStorage");
+  const token = impersonationToken || window.currentToken || sessionStorage.getItem("calpe_ward_token");
+
+  debugLog("[PERMISSIONS] Starting loadCurrentUserPermissions, token: " + (token ? "present" : "MISSING"));
+
+  if (!token) {
+    debugLog("[PERMISSIONS] No session token available");
     return null;
   }
 
   try {
-    // Load user profile
-    const { data: profile, error: profileError } = await window.supabaseClient
-      .from("users")
-      .select("id, name, role_id, is_admin, is_active")
-      .eq("id", savedId)
-      .single();
+    // Load user profile via token-only RPC
+    debugLog("[PERMISSIONS] Calling rpc_get_current_user...");
+    const { data: profileRows, error: profileError } = await window.supabaseClient
+      .rpc("rpc_get_current_user", { p_token: token });
+
+    debugLog("[PERMISSIONS] rpc_get_current_user response: profileRows=" + JSON.stringify(profileRows) + " error=" + JSON.stringify(profileError));
+
+    const profile = Array.isArray(profileRows) ? profileRows[0] : profileRows;
 
     if (profileError || !profile) {
-      console.error("[PERMISSIONS] Failed to load user profile:", profileError);
+      debugLog("[PERMISSIONS] Failed to load user profile - error: " + JSON.stringify(profileError) + " profile: " + JSON.stringify(profile));
       return null;
     }
 
     currentUser = profile;
-    console.log("[PERMISSIONS] Loaded user:", profile.name);
+    debugLog("[PERMISSIONS] Loaded user: " + profile.name + " id: " + profile.id + " is_admin: " + profile.is_admin);
 
     // If admin, skip permission loading (admins have all permissions)
     if (profile.is_admin) {
-      console.log("[PERMISSIONS] User is admin - has all permissions");
+      debugLog("[PERMISSIONS] User is admin - has all permissions");
+      localStorage.setItem("calpeward.loggedInUserId", profile.id);
       return profile;
     }
 
-    // Load user's permission groups
-    const { data: groups, error: groupsError } = await window.supabaseClient
-      .from("user_permission_groups")
-      .select("group_id")
-      .eq("user_id", profile.id);
-
-    if (groupsError) {
-      console.warn("[PERMISSIONS] Failed to load permission groups:", groupsError);
-      return profile;
+    // Load permissions via token-only RPC
+    debugLog("[PERMISSIONS] Calling rpc_get_user_permissions...");
+    const { data: perms, error: permsError } = await window.supabaseClient
+      .rpc("rpc_get_user_permissions", { p_token: token });
+
+    debugLog("[PERMISSIONS] rpc_get_user_permissions response: perms=" + JSON.stringify(perms) + " error=" + JSON.stringify(permsError));
+
+    if (permsError) {
+      debugLog("[PERMISSIONS] Failed to load permissions: " + JSON.stringify(permsError));
+    } else {
+      userPermissions.clear();
+      (perms || []).forEach(p => {
+        if (p.permission_key) {
+          userPermissions.add(p.permission_key);
+        }
+      });
+      debugLog("[PERMISSIONS] Loaded permissions: " + JSON.stringify(Array.from(userPermissions)));
     }
 
-    // Load permissions for those groups
-    if (groups && groups.length > 0) {
-      const groupIds = groups.map(g => g.group_id);
-      const { data: perms, error: permsError } = await window.supabaseClient
-        .from("permission_group_permissions")
-        .select("permission_key")
-        .in("group_id", groupIds);
-
-      if (permsError) {
-        console.warn("[PERMISSIONS] Failed to load permissions:", permsError);
-      } else {
-        userPermissions.clear();
-        (perms || []).forEach(p => {
-          if (p.permission_key) {
-            userPermissions.add(p.permission_key);
-          }
-        });
-        console.log("[PERMISSIONS] Loaded permissions:", Array.from(userPermissions));
-      }
-    }
+    localStorage.setItem("calpeward.loggedInUserId", profile.id);
+    debugLog("[PERMISSIONS] Successfully loaded user and permissions");
 
     return profile;
   } catch (e) {
-    console.error("[PERMISSIONS] Error loading user permissions:", e);
+    debugLog("[PERMISSIONS] Error loading user permissions: " + e.message + " stack: " + e.stack);
     return null;
   }
 }
\n
==== DIFF: js/session-validator.js ====\n
diff --git "a/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\Calpe-Ward Backup\\Calpe-Ward\\js\\session-validator.js" "b/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\js\\session-validator.js"
index 63caf8d..ee79225 100644
--- "a/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\Calpe-Ward Backup\\Calpe-Ward\\js\\session-validator.js"	
+++ "b/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\js\\session-validator.js"	
@@ -5,6 +5,14 @@
 // Redirects to login if invalid or expired
 // ============================================================================
 
+// Debug logging utility - persists through page reloads
+window.DEBUG_LOGS = window.DEBUG_LOGS || [];
+function debugLog(msg) {
+  console.log(msg);
+  window.DEBUG_LOGS.push(msg);
+  localStorage.setItem('calpeward_debug_logs', JSON.stringify(window.DEBUG_LOGS.slice(-50))); // Keep last 50
+}
+
 const TOKEN_KEY = "calpe_ward_token";
 const SESSION_KEY = "calpe_ward_session";
 const IMPERSONATION_TOKEN_KEY = "calpeward.impersonationToken";
@@ -31,9 +39,11 @@ function getActiveSessionToken() {
 async function validateSessionOnLoad() {
   // Get token from sessionStorage (prioritize impersonation token)
   const token = getActiveSessionToken();
+  debugLog("[SESSION-VALIDATOR] Starting validation, token: " + (token ? "present" : "MISSING"));
 
   if (!token) {
     // No token - redirect to login
+    debugLog("[SESSION-VALIDATOR] No token found, redirecting to login");
     redirectToLogin("Session expired. Please log in again.");
     return false;
   }
@@ -41,6 +51,7 @@ async function validateSessionOnLoad() {
   // Store token in memory for RPC calls
   currentToken = token;
   window.currentToken = token;  // Expose globally for RPC calls
+  debugLog("[SESSION-VALIDATOR] Token stored globally, validating with server...");
 
   // Validate token with server
   try {
\n
==== DIFF: js/shift-functions.js ====\n
diff --git "a/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\Calpe-Ward Backup\\Calpe-Ward\\js\\shift-functions.js" "b/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\js\\shift-functions.js"
index 4331b43..ffddd41 100644
--- "a/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\Calpe-Ward Backup\\Calpe-Ward\\js\\shift-functions.js"	
+++ "b/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\js\\shift-functions.js"	
@@ -12,20 +12,12 @@ async function loadUserPermissions(){
   if (currentUser.is_admin) return;
 
   try {
-    const { data: groups, error: gErr } = await supabaseClient
-      .from("user_permission_groups")
-      .select("group_id")
-      .eq("user_id", currentUser.id);
-    if (gErr) throw gErr;
-    const groupIds = (groups || []).map(g => g.group_id).filter(Boolean);
-    if (!groupIds.length) return;
-
     const { data: perms, error: pErr } = await supabaseClient
-      .from("permission_group_permissions")
-      .select("permission_key")
-      .in("group_id", groupIds);
+      .rpc("rpc_get_user_permissions", { p_token: window.currentToken });
     if (pErr) throw pErr;
-    (perms || []).forEach(p => userPermissions.add(p.permission_key));
+    (perms || []).forEach(p => {
+      if (p.permission_key) userPermissions.add(p.permission_key);
+    });
   } catch (e) {
     console.warn("Failed to load permissions", e);
   }
@@ -79,12 +71,14 @@ async function populateShiftGrid(){
   
   try {
     // Get shifts with scope flags and allowed_staff_groups
-    const { data: shifts, error: shiftsErr } = await window.supabaseClient
-      .from("shifts")
-      .select("id, code, label, hours_value, allowed_staff_groups, start_time, end_time")
-      .eq("allow_requests", true)
-      .order("code", { ascending: true })
-      .order("hours_value", { ascending: true });
+    const token = window.currentToken || sessionStorage.getItem("calpe_ward_token");
+    if (!token) {
+      throw new Error("No session token available for shift picker.");
+    }
+    const { data: shifts, error: shiftsErr } = await window.supabaseClient.rpc("rpc_get_shifts", {
+      p_token: token,
+      p_allow_requests: true
+    });
     
     if (shiftsErr) throw shiftsErr;
     
\n
==== DIFF: js/staffing-requirements.js ====\n
diff --git "a/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\Calpe-Ward Backup\\Calpe-Ward\\js\\staffing-requirements.js" "b/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\js\\staffing-requirements.js"
index aa280d1..3b799c1 100644
--- "a/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\Calpe-Ward Backup\\Calpe-Ward\\js\\staffing-requirements.js"	
+++ "b/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\js\\staffing-requirements.js"	
@@ -27,13 +27,21 @@ function initStaffingRequirements() {
   let currentStaffingPeriod = null;
   let staffingRequirementsData = new Map(); // date -> requirements
 
+  function getStaffingToken() {
+    const token = window.currentToken || sessionStorage.getItem("calpe_ward_token");
+    if (!token) {
+      throw new Error("No session token available for staffing requirements.");
+    }
+    return token;
+  }
+
   async function loadStaffingPeriods() {
     try {
       console.log("[STAFFING] Loading periods...");
-      const { data: periods, error } = await window.supabaseClient
-        .from("rota_periods")
-        .select("id, name, start_date, end_date")
-        .order("start_date", { ascending: false });
+      const token = getStaffingToken();
+      const { data: periods, error } = await window.supabaseClient.rpc("rpc_get_rota_periods", {
+        p_token: token
+      });
 
       if (error) throw error;
 
@@ -71,15 +79,16 @@ function initStaffingRequirements() {
   async function loadStaffingRequirements(periodId) {
     try {
       console.log("[STAFFING] Loading requirements for period", periodId);
+      const token = getStaffingToken();
       
       // Get period details
-      const { data: period, error: pErr } = await window.supabaseClient
-        .from("rota_periods")
-        .select("start_date, end_date")
-        .eq("id", periodId)
-        .single();
+      const { data: periods, error: pErr } = await window.supabaseClient.rpc("rpc_get_rota_periods", {
+        p_token: token
+      });
 
       if (pErr) throw pErr;
+      const period = (periods || []).find(p => p.id === periodId);
+      if (!period) throw new Error("Selected period not found.");
 
       // Get all dates in period
       const dates = [];
@@ -90,10 +99,10 @@ function initStaffingRequirements() {
       }
 
       // Load requirements
-      const { data: reqs, error: rErr } = await window.supabaseClient
-        .from("staffing_requirements")
-        .select("*")
-        .eq("period_id", periodId);
+      const { data: reqs, error: rErr } = await window.supabaseClient.rpc("admin_get_staffing_requirements", {
+        p_token: token,
+        p_period_id: periodId
+      });
 
       if (rErr) console.warn("[STAFFING] Load warning:", rErr);
       
@@ -156,21 +165,17 @@ function initStaffingRequirements() {
         const nightNa = parseFloat(staffingRequirementsContainer.querySelector(`input[data-date="${date}"][data-field="night_na_required"]`).value) || 2;
 
         try {
-          const req = staffingRequirementsData.get(date);
-          if (req && req.id) {
-            // Update
-            const { error } = await window.supabaseClient
-              .from("staffing_requirements")
-              .update({ day_sn_required: daySn, day_na_required: dayNa, night_sn_required: nightSn, night_na_required: nightNa })
-              .eq("id", req.id);
-            if (error) throw error;
-          } else {
-            // Insert
-            const { error } = await window.supabaseClient
-              .from("staffing_requirements")
-              .insert([{ period_id: periodId, date, day_sn_required: daySn, day_na_required: dayNa, night_sn_required: nightSn, night_na_required: nightNa }]);
-            if (error) throw error;
-          }
+          const token = getStaffingToken();
+          const { error } = await window.supabaseClient.rpc("admin_upsert_staffing_requirement", {
+            p_token: token,
+            p_period_id: periodId,
+            p_date: date,
+            p_day_sn_required: daySn,
+            p_day_na_required: dayNa,
+            p_night_sn_required: nightSn,
+            p_night_na_required: nightNa
+          });
+          if (error) throw error;
           alert("Staffing requirements saved!");
           await loadStaffingRequirements(periodId);
         } catch (err) {
\n
==== DIFF: js/user-modal.js ====\n
diff --git "a/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\Calpe-Ward Backup\\Calpe-Ward\\js\\user-modal.js" "b/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\js\\user-modal.js"
index 48fb521..a4b212e 100644
--- "a/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\Calpe-Ward Backup\\Calpe-Ward\\js\\user-modal.js"	
+++ "b/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\js\\user-modal.js"	
@@ -256,13 +256,12 @@
     const supabase = typeof getSupabase === 'function' ? getSupabase() : window.supabaseClient;
     if (!supabase || !window.currentUser?.id) return;
     try {
+      const token = window.currentToken || sessionStorage.getItem("calpe_ward_token");
       const { data, error } = await supabase
-        .from("users")
-        .select("pref_shift_clustering, pref_night_appetite, pref_weekend_appetite, pref_leave_adjacency")
-        .eq("id", window.currentUser.id)
-        .single();
+        .rpc("rpc_get_current_user", { p_token: token });
       if (error) throw error;
-      const prefs = data || {};
+      const row = Array.isArray(data) ? data[0] : data;
+      const prefs = row || {};
       const fields = [
         "pref_shift_clustering",
         "pref_night_appetite",
\n
==== DIFF: js/view-as.js ====\n
diff --git "a/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\Calpe-Ward Backup\\Calpe-Ward\\js\\view-as.js" "b/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\js\\view-as.js"
index c75ce7e..66e5b75 100644
--- "a/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\Calpe-Ward Backup\\Calpe-Ward\\js\\view-as.js"	
+++ "b/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\js\\view-as.js"	
@@ -18,6 +18,13 @@ function getActiveToken() {
   return sessionStorage.getItem(getTokenStorageKey());
 }
 
+function roleNameFromId(roleId) {
+  if (roleId === 1) return "Charge Nurses";
+  if (roleId === 2) return "Staff Nurses";
+  if (roleId === 3) return "Nursing Assistants";
+  return "Unknown";
+}
+
 function getRealUser() {
   const stored = sessionStorage.getItem(REAL_USER_STORAGE_KEY);
   if (stored) {
@@ -266,10 +273,10 @@ async function startViewingAs(targetUserId) {
   }
 
   // Get target user details
-  const { data: users, error: userError } = await supaClient
-    .from("users")
-    .select("id, name, role_id, is_active, is_admin")
-    .eq("id", targetUserId);
+  const { data: users, error: userError } = await supaClient.rpc("admin_get_user_by_id", {
+    p_token: adminToken,
+    p_user_id: targetUserId
+  });
 
   if (userError || !users || users.length === 0) {
     alert("Failed to find target user");
@@ -411,10 +418,10 @@ async function initViewAs(supabaseClient, currentUser) {
       
       // Load all users for selector
       console.log("[VIEW-AS] Loading users...");
-      const { data: allUsers, error } = await supabaseClient
-        .from("users")
-        .select("id, name, role_id, is_active, roles(name)")
-        .order("name");
+      const { data: allUsers, error } = await supabaseClient.rpc("admin_get_users", {
+        p_token: getActiveToken(),
+        p_include_inactive: true
+      });
 
       if (error) {
         console.error("[VIEW-AS] Failed to load users:", error);
@@ -425,7 +432,7 @@ async function initViewAs(supabaseClient, currentUser) {
 
       const usersWithRoles = allUsers.map(u => ({
         ...u,
-        role_name: u.roles?.name || "Unknown"
+        role_name: roleNameFromId(u.role_id)
       }));
 
       await buildOptions(usersWithRoles, supabaseClient);
\n
==== DIFF: preview.html ====\n
diff --git "a/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\Calpe-Ward Backup\\Calpe-Ward\\preview.html" "b/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\preview.html"
index 372ec56..f65ac20 100644
--- "a/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\Calpe-Ward Backup\\Calpe-Ward\\preview.html"	
+++ "b/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\preview.html"	
@@ -749,6 +749,7 @@ Step C: Log decision
   <script src="js/session-validator.js"></script>
   <script src="js/permissions.js"></script>
   <script src="js/nav-bar.js"></script>
+  <script src="js/periods-shared.js" defer></script>
   <script>
     let currentPeriodData = null;
     let generatedPreview = null;
@@ -775,40 +776,6 @@ Step C: Log decision
       event.target.classList.add('active');
     }
 
-    // Load periods on page load
-    async function loadPeriods() {
-      try {
-        const { data, error } = await window.supabaseClient
-          .from('rota_periods')
-          .select('id, name, start_date, end_date')
-          .order('start_date', { ascending: false })
-          .limit(12);
-        
-        if (error) throw error;
-        
-        const select = document.getElementById('periodSelect');
-        data.forEach(period => {
-          const option = document.createElement('option');
-          option.value = period.id;
-          // Format dates nicely
-          const startDate = new Date(period.start_date).toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
-          const endDate = new Date(period.end_date).toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
-          const safeName = normalizeText(period.name);
-          option.textContent = `${safeName} (${startDate} - ${endDate})`;
-          select.appendChild(option);
-          periodMap.set(period.id, {
-            id: period.id,
-            name: period.name,
-            start_date: period.start_date,
-            end_date: period.end_date
-          });
-        });
-      } catch (e) {
-        console.error('Error loading periods:', e);
-        showStatus('Error loading periods: ' + e.message, 'error');
-      }
-    }
-
     // Generate preview
     async function generatePreview() {
       const periodId = document.getElementById('periodSelect').value;
@@ -820,7 +787,7 @@ Step C: Log decision
       showStatus('Generating preview...', 'loading');
       
       // Get token from window or sessionStorage
-      const token = window.currentToken || sessionStorage.getItem('session_token');
+      const token = window.currentToken || sessionStorage.getItem('calpe_ward_token');
       if (!token) {
         showStatus('Error: Session token not available. Please log in.', 'error');
         return;
@@ -1053,13 +1020,14 @@ Step C: Log decision
       }
 
       try {
-        const { data: users, error: uErr } = await window.supabaseClient
-          .from('users')
-          .select('id, name, role_id, is_admin, display_order')
-          .eq('is_active', true)
-          .order('role_id', { ascending: true })
-          .order('display_order', { ascending: true })
-          .order('created_at', { ascending: true });
+        const token = window.currentToken || sessionStorage.getItem('calpe_ward_token');
+        if (!token) {
+          throw new Error('Session token not available.');
+        }
+        const { data: users, error: uErr } = await window.supabaseClient.rpc('rpc_get_users_basic', {
+          p_token: token,
+          p_include_inactive: false
+        });
 
         if (uErr) throw uErr;
         (users || []).forEach(u => roster.push({ ...u, is_non_staff: false }));
\n
==== DIFF: requests.html ====\n
diff --git "a/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\Calpe-Ward Backup\\Calpe-Ward\\requests.html" "b/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\requests.html"
index 70fb8c8..c59d72a 100644
--- "a/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\Calpe-Ward Backup\\Calpe-Ward\\requests.html"	
+++ "b/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\requests.html"	
@@ -3164,10 +3164,9 @@ async function upsertWeekComment(weekId, userId, comment){
   const token = getTokenOrThrow();
 
   const { data, error } = await supaClient.rpc("upsert_week_comment", {
-    p_week_id: weekId,
-    p_user_id: userId,
+    p_comment: comment ?? "",
     p_token: token,
-    p_comment: comment ?? ""
+    p_week_id: weekId
   });
 
   if (error) throw error;
@@ -3181,20 +3180,12 @@ async function upsertWeekComment(weekId, userId, comment){
 async function resetWeeksFullyOpen(periodId){
   if (!currentUser?.is_admin) { alert("Admin only."); return; }
 
-  const { data: wkRows, error: wkErr } = await supaClient
-    .from("rota_dates")
-    .select("week_id")
-    .eq("period_id", periodId);
-
-  if (wkErr) throw wkErr;
-
-  const weekIds = [...new Set((wkRows || []).map(r => r.week_id).filter(Boolean))];
-  if (!weekIds.length) return;
-
   const { error: resetErr } = await supaClient
-    .from("rota_weeks")
-    .update({ open: true, open_after_close: true })
-    .in("id", weekIds);
+    .rpc("admin_set_weeks_open_for_period", {
+      p_token: window.currentToken,
+      p_period_id: periodId,
+      p_open: true
+    });
 
   if (resetErr) throw resetErr;
 }
@@ -3202,39 +3193,29 @@ async function resetWeeksFullyOpen(periodId){
 async function resetWeeksFullyClosed(periodId){
   if (!currentUser?.is_admin) { alert("Admin only."); return; }
 
-  const { data: wkRows, error: wkErr } = await supaClient
-    .from("rota_dates")
-    .select("week_id")
-    .eq("period_id", periodId);
-
-  if (wkErr) throw wkErr;
-
-  const weekIds = [...new Set((wkRows || []).map(r => r.week_id).filter(Boolean))];
-  if (!weekIds.length) return;
-
   const { error: resetErr } = await supaClient
-    .from("rota_weeks")
-    .update({ open: false, open_after_close: false })
-    .in("id", weekIds);
+    .rpc("admin_set_weeks_open_for_period", {
+      p_token: window.currentToken,
+      p_period_id: periodId,
+      p_open: false
+    });
 
   if (resetErr) throw resetErr;
 }
 
     
-  async function fetchRotaPeriods(){
-  let q = supaClient
-    .from("rota_periods")
-    .select("id, name, start_date, end_date, is_hidden, is_active, closes_at")
-    .order("start_date", { ascending: true });
+async function fetchRotaPeriods(){
+  const { data, error } = await supaClient
+    .rpc("rpc_get_rota_periods", {
+      p_token: window.currentToken
+    });
 
-  // Staff: show active + non-hidden. Admin: show all.
+  if (error) throw error;
+  const rows = data || [];
   if (!currentUser?.is_admin) {
-    q = q.or("is_hidden.eq.false,is_active.eq.true");
+    return rows.filter(r => r.is_hidden === false || r.is_active === true);
   }
-
-  const { data, error } = await q;
-  if (error) throw error;
-  return data || [];
+  return rows;
 }
 
 function roleLabel(u){
@@ -3303,20 +3284,12 @@ async function loadUserPermissions(){
   if (currentUser.is_admin) return;
 
   try {
-    const { data: groups, error: gErr } = await supaClient
-      .from("user_permission_groups")
-      .select("group_id")
-      .eq("user_id", currentUser.id);
-    if (gErr) throw gErr;
-    const groupIds = (groups || []).map(g => g.group_id).filter(Boolean);
-    if (!groupIds.length) return;
-
     const { data: perms, error: pErr } = await supaClient
-      .from("permission_group_permissions")
-      .select("permission_key")
-      .in("group_id", groupIds);
+      .rpc("rpc_get_user_permissions", { p_token: window.currentToken });
     if (pErr) throw pErr;
-    (perms || []).forEach(p => userPermissions.add(p.permission_key));
+    (perms || []).forEach(p => {
+      if (p.permission_key) userPermissions.add(p.permission_key);
+    });
   } catch (e) {
     console.warn("Failed to load permissions", e);
   }
@@ -4211,63 +4184,8 @@ async function fetchNotificationsForMe(){
 
   const roleId = Number(currentUser.role_id);
   const isAdmin = !!currentUser.is_admin;
-  
-  // Check if user is in Admin permission group
-  let isAdminGroup = false;
-  if (!isAdmin) {
-    try {
-      const { data: groups } = await supaClient
-        .from("user_permission_groups")
-        .select("permission_groups(name)")
-        .eq("user_id", currentUser.id);
-      if (groups && groups.some(g => g.permission_groups?.name === "Admin")) {
-        isAdminGroup = true;
-      }
-    } catch (e) {
-      console.warn("Failed to check admin group", e);
-    }
-  }
-  
-  const clauses = [];
-
-  // Match all_staff scope
-  clauses.push("target_scope.eq.all_staff");
-
-  // Match user-specific scope - use and() to ensure BOTH conditions match
-  if (currentUser.id) {
-    clauses.push(`and(target_scope.eq.user,target_user_id.eq.${currentUser.id})`);
-  }
-
-  // Match admin scope - for notifications sent to all admins
-  if (isAdmin || isAdminGroup) {
-    clauses.push("target_scope.eq.admin");
-  }
-
-  // Match role-specific scope
-  if (!Number.isNaN(roleId)) {
-    clauses.push(`and(target_scope.eq.role,target_role_ids.cs.{${roleId}})`);
-  }
-
   const { data, error } = await supaClient
-    .from("notifications")
-    .select(`
-      id,
-      type,
-      payload,
-      target_scope,
-      target_role_ids,
-      target_user_id,
-      requires_action,
-      status,
-      created_by,
-      created_at,
-      updated_by,
-      updated_at,
-      acted_by,
-      acted_at
-    `)
-    .or(clauses.join(","))
-    .order("updated_at", { ascending: false });
+    .rpc("rpc_get_notifications", { p_token: window.currentToken });
 
   if (error) throw error;
   
@@ -4276,8 +4194,8 @@ async function fetchNotificationsForMe(){
     // Only show pending notifications
     if ((item.status || 'pending') !== 'pending') return false;
     
-    // all_staff scope matches everyone
-    if (item.target_scope === 'all_staff') return true;
+    // all/all_staff scope matches everyone
+    if (item.target_scope === 'all' || item.target_scope === 'all_staff') return true;
     
     // user scope must match current user ID
     if (item.target_scope === 'user') {
@@ -4929,14 +4847,11 @@ noticeAllList?.addEventListener("click", async (e) => {
 async function updateNotificationStatus(notifId, status) {
   if (!currentUser) throw new Error("Not logged in.");
   const { error } = await supaClient
-    .from("notifications")
-    .update({
-      status: status,
-      acted_by: currentUser.id,
-      acted_at: new Date().toISOString(),
-      updated_by: currentUser.id
-    })
-    .eq("id", notifId);
+    .rpc("rpc_update_notification_status", {
+      p_token: window.currentToken,
+      p_notification_id: notifId,
+      p_status: status
+    });
 
   if (error) throw error;
 }
@@ -4987,21 +4902,7 @@ async function loadAdminNotices(){
   if (!currentUser?.is_admin) return;
 
 const { data, error } = await supaClient
-  .from("notices")
-  .select(`
-    id,
-    title,
-    body_en,
-    body_es,
-    version,
-    is_active,
-    updated_at,
-    created_by,
-    target_all,
-    target_roles,
-    users:created_by ( name )
-  `)
-  .order("updated_at", { ascending: false });
+  .rpc("admin_get_all_notices", { p_token: window.currentToken });
 
 
   if (error){
@@ -5010,7 +4911,18 @@ const { data, error } = await supaClient
     return;
   }
 
-  adminNoticesCache = data || [];
+  adminNoticesCache = (data || []).map(row => ({
+    id: row.notice_id,
+    title: row.title,
+    body_en: row.body_en,
+    body_es: row.body_es,
+    version: row.version,
+    is_active: row.is_active,
+    updated_at: row.updated_at,
+    created_by_name: row.created_by_name,
+    target_all: row.target_all,
+    target_roles: row.target_roles || []
+  }));
 
   // Fetch ack counts (batched RPC) and merge into cache
   try {
@@ -5262,11 +5174,7 @@ async function loadAdminUsers(){
   adminUsersList.textContent = "Loading usersÔÇª";
 
   const { data, error } = await supaClient
-    .from("users")
-    .select("id, name, role_id, is_admin, is_active, display_order, roles(name)")
-    .order("role_id", { ascending: true })
-    .order("display_order", { ascending: true })
-    .order("created_at", { ascending: true })
+    .rpc("admin_get_users", { p_token: window.currentToken, p_include_inactive: true });
 
   if (error) {
     console.error(error);
@@ -5463,18 +5371,18 @@ async function updateUserDisplayOrder(roleId) {
       const userId = rows[i].dataset.userId;
       console.log(`Updating user ${userId} to display_order ${i + 1}`);
       
-      const { data, error } = await supaClient
-        .from('users')
-        .update({ display_order: i + 1 })
-        .eq('id', userId)
-        .select();
+      const { error } = await supaClient.rpc("admin_reorder_users", {
+        p_token: window.currentToken,
+        p_user_id: userId,
+        p_display_order: i + 1
+      });
       
       if (error) {
         console.error('Failed to update display_order:', error);
         alert(`Failed to save new order: ${error.message}`);
         return;
       }
-      console.log('Update result:', data);
+      console.log('Order update ok for user:', userId);
     }
     
     console.log('All updates successful, reloading...');
@@ -5806,10 +5714,10 @@ async function loadAdminWeeks(periodId){
 
   // Pull all dates for the period, but we only need them to discover the weeks + open state
   const { data, error } = await supaClient
-    .from("rota_dates")
-.select("date, week_id, period_id, rota_weeks(id, open, open_after_close)")
-    .eq("period_id", periodId)
-    .order("date");
+    .rpc("rpc_get_rota_weeks", {
+      p_token: window.currentToken,
+      p_period_id: periodId
+    });
 
   if (error) {
     console.error(error);
@@ -5817,39 +5725,13 @@ async function loadAdminWeeks(periodId){
     return;
   }
 
-  // Build unique weeks list from rota_dates (because rota_weeks doesn't have period_id)
-const weekMap = new Map();
-
-for (const row of (data || [])) {
-  const w = row.rota_weeks;
-  if (!w?.id) continue;
-
-  // Compute week start/end from the date in rota_dates
-  const ws = startOfWeekSunday(new Date(row.date));
-  const we = addDays(ws, 6);
-
-  if (!weekMap.has(w.id)) {
-    weekMap.set(w.id, {
-      weekId: w.id,
-      open: !!w.open,
-      openAfterClose: !!w.open_after_close,
-      weekStart: ws,
-      weekEnd: we
-    });
-  } else {
-    const existing = weekMap.get(w.id);
-
-    // Keep flags consistent (safety: if any row says closed, treat as closed)
-    existing.open = existing.open && !!w.open;
-    existing.openAfterClose = existing.openAfterClose && !!w.open_after_close;
-
-    // Expand bounds in case of weird data ordering
-    if (ws < existing.weekStart) existing.weekStart = ws;
-    if (we > existing.weekEnd) existing.weekEnd = we;
-  }
-}
-
-const weeks = [...weekMap.values()].sort((a,b) => a.weekStart - b.weekStart);
+  const weeks = (data || []).map(w => ({
+    weekId: w.id,
+    open: !!w.open,
+    openAfterClose: !!w.open_after_close,
+    weekStart: new Date(w.week_start),
+    weekEnd: new Date(w.week_end)
+  })).sort((a,b) => a.weekStart - b.weekStart);
 
 
   if (!weeks.length){
@@ -6104,62 +5986,45 @@ async function setPeriodCloseTime(periodId, closesAtIsoOrNull){
 
 async function resetWeeksAfterClose(periodId){
   if (!currentUser?.is_admin) { alert("Admin only."); return; }
-  const { data: wkRows, error: wkErr } = await supaClient
-    .from("rota_dates")
-    .select("week_id")
-    .eq("period_id", periodId);
-
-  if (wkErr) throw wkErr;
-
-  const weekIds = [...new Set((wkRows || []).map(r => r.week_id).filter(Boolean))];
-  if (!weekIds.length) return;
-
-  const { error: resetErr } = await supaClient
-    .from("rota_weeks")
-    .update({ open_after_close: false })
-    .in("id", weekIds);
+  const token = getTokenOrThrow();
+  const { error: resetErr } = await supaClient.rpc("admin_set_weeks_open_after_close", {
+    p_token: token,
+    p_period_id: periodId,
+    p_open_after_close: false
+  });
 
   if (resetErr) throw resetErr;
 }
     async function resetWeeksOpen(periodId){
   if (!currentUser?.is_admin) { alert("Admin only."); return; }
-
-  const { data: wkRows, error: wkErr } = await supaClient
-    .from("rota_dates")
-    .select("week_id")
-    .eq("period_id", periodId);
-
-  if (wkErr) throw wkErr;
-
-  const weekIds = [...new Set((wkRows || []).map(r => r.week_id).filter(Boolean))];
-  if (!weekIds.length) return;
-
-  const { error: resetErr } = await supaClient
-    .from("rota_weeks")
-    .update({ open: true })
-    .in("id", weekIds);
+  const token = getTokenOrThrow();
+  const { error: resetErr } = await supaClient.rpc("admin_set_weeks_open_for_period", {
+    p_token: token,
+    p_period_id: periodId,
+    p_open: true
+  });
 
   if (resetErr) throw resetErr;
 }
 
 async function resetWeeksDefaultForPeriod(periodId){
   if (!currentUser?.is_admin) { alert("Admin only."); return; }
-  const { data: wkRows, error: wkErr } = await supaClient
-    .from("rota_dates")
-    .select("week_id")
-    .eq("period_id", periodId);
-
-  if (wkErr) throw wkErr;
+  const token = getTokenOrThrow();
+  const { error: openErr } = await supaClient.rpc("admin_set_weeks_open_for_period", {
+    p_token: token,
+    p_period_id: periodId,
+    p_open: true
+  });
 
-  const weekIds = [...new Set((wkRows || []).map(r => r.week_id).filter(Boolean))];
-  if (!weekIds.length) return;
+  if (openErr) throw openErr;
 
-  const { error: resetErr } = await supaClient
-    .from("rota_weeks")
-    .update({ open: true, open_after_close: false })
-    .in("id", weekIds);
+  const { error: closeErr } = await supaClient.rpc("admin_set_weeks_open_after_close", {
+    p_token: token,
+    p_period_id: periodId,
+    p_open_after_close: false
+  });
 
-  if (resetErr) throw resetErr;
+  if (closeErr) throw closeErr;
 }
 
 if (adminClosesAtSaveBtn) {
@@ -6331,11 +6196,11 @@ document.addEventListener("keydown", (e) => {
 async function populateShiftGrid(){
   console.warn("[INDEX.HTML] Old populateShiftGrid called - should be overridden by shift-functions.js");
   try {
-    const { data: shifts, error: shiftsErr} = await supaClient
-      .from("shifts")
-      .select("id, code, label, hours_value, allowed_staff_groups")
-      .eq("allow_requests", true)
-      .order("code", { ascending: true });
+    const token = getTokenOrThrow();
+    const { data: shifts, error: shiftsErr} = await supaClient.rpc("rpc_get_shifts", {
+      p_token: token,
+      p_allow_requests: true
+    });
     
     if (shiftsErr) throw shiftsErr;
     
@@ -6689,10 +6554,10 @@ async function loadRota() {
   // 7A) Load users
   // -----------------------------
   const { data: users, error: userError } = await supaClient
-.from("users")
-.select("id, name, role_id, is_admin, is_active, preferred_lang, display_order, roles(name)")
-    .order("role_id", { ascending: true })
-    .order("display_order", { ascending: true })
+    .rpc("rpc_get_users_basic", {
+      p_token: window.currentToken,
+      p_include_inactive: true
+    });
 
   if (userError) {
     console.error("Users load error:", userError);
@@ -6700,13 +6565,22 @@ async function loadRota() {
     return;
   }
 
+  const sortedUsers = (users || []).slice().sort((a, b) => {
+    const roleDiff = (a.role_id || 0) - (b.role_id || 0);
+    if (roleDiff !== 0) return roleDiff;
+    const aOrder = a.display_order ?? 9999;
+    const bOrder = b.display_order ?? 9999;
+    if (aOrder !== bOrder) return aOrder - bOrder;
+    return (a.name || "").localeCompare(b.name || "");
+  });
+
   // Build helper map + store all users for print/export
-  allUsers = users || [];
-  usersById = new Map((users || []).map(u => [u.id, u.name]));
+  allUsers = sortedUsers;
+  usersById = new Map(sortedUsers.map(u => [u.id, u.name]));
 
   // Update currentUser with full user data if already set from session validation
   if (currentUser && currentUser.id) {
-    const fullUser = (users || []).find(u => String(u.id) === String(currentUser.id));
+  const fullUser = (sortedUsers || []).find(u => String(u.id) === String(currentUser.id));
     if (fullUser) {
       // Merge with existing data to get roles and other details
       currentUser = { ...fullUser };
@@ -6758,16 +6632,33 @@ updateCloseLabel(selected);
 // 7D) Load rota dates FOR SELECTED PERIOD
 // -----------------------------
 const { data: dates, error: dateError } = await supaClient
-  .from("rota_dates")
- .select("date, week_id, period_id, rota_weeks(id, open, open_after_close)")
-  .eq("period_id", activePeriodId)
-  .order("date");
+  .rpc("rpc_get_rota_dates", {
+    p_token: window.currentToken,
+    p_period_id: activePeriodId
+  });
+
+const { data: weeksData, error: weeksError } = await supaClient
+  .rpc("rpc_get_rota_weeks", {
+    p_token: window.currentToken,
+    p_period_id: activePeriodId
+  });
 
 if (dateError) {
   console.error("Dates load error:", dateError);
   alert("Failed to load dates for this period.");
   return;
 }
+if (weeksError) {
+  console.error("Weeks load error:", weeksError);
+  alert("Failed to load weeks for this period.");
+  return;
+}
+
+const weeksById = new Map((weeksData || []).map(w => [String(w.id), w]));
+const datesWithWeeks = (dates || []).map(d => ({
+  ...d,
+  rota_weeks: d.week_id ? weeksById.get(String(d.week_id)) || null : null
+}));
 
 // -----------------------------
 // 7D.5) Load requests for this period (so saved cells show up)
@@ -6805,11 +6696,11 @@ if (start && end) {
 locksCache.clear();
 
 if (start && end) {
-  const { data: locks, error: lockErr } = await supaClient
-    .from("request_cell_locks")
-    .select("user_id, date, reason_en, reason_es, locked_by, locked_at")
-    .gte("date", start)
-    .lte("date", end);
+  const { data: locks, error: lockErr } = await supaClient.rpc("rpc_get_request_cell_locks", {
+    p_token: window.currentToken,
+    p_start_date: start,
+    p_end_date: end
+  });
 
   if (lockErr) {
     console.error("Locks load error:", lockErr);
@@ -6824,7 +6715,7 @@ if (start && end) {
 // -----------------------------
 // 7E) Render table (weeks + users)
 // -----------------------------
-const weeks = groupDatesIntoWeeks(dates);
+const weeks = groupDatesIntoWeeks(datesWithWeeks);
 
 // Store for export/report features
 allWeeks = weeks;
@@ -6833,7 +6724,7 @@ weekWindowStart = 0;
 
 // Hide inactive users from the rota table (for everyone)
 // (Admins can still view/manage them in Admin ÔåÆ Users with "Show inactive")
-const visibleUsers = users.filter(u => u.is_active !== false);
+const visibleUsers = sortedUsers.filter(u => u.is_active !== false);
 
 render(visibleUsers, weeks);
 
@@ -7063,14 +6954,14 @@ if (pe.shift === "O") {
 async function populatePatternTargets() {
   try {
     // Get all user patterns
-    const { data: userPatterns, error: upErr } = await supaClient
-      .from("user_patterns")
-      .select("user_id, pattern_id, anchor_week_start_date");
+    const { data: userPatterns, error: upErr } = await supaClient.rpc("rpc_get_user_patterns", {
+      p_token: window.currentToken
+    });
     if (upErr) throw upErr;
 
-    const { data: patterns, error: pErr } = await supaClient
-      .from("pattern_definitions")
-      .select("id, weekly_targets, requires_anchor");
+    const { data: patterns, error: pErr } = await supaClient.rpc("rpc_get_pattern_definitions", {
+      p_token: window.currentToken
+    });
     if (pErr) throw pErr;
 
     const patternMap = {};
@@ -7922,20 +7813,15 @@ window.addEventListener('load',function(){requestAnimationFrame(function(){reque
               );
               console.log("Week IDs from DOM:", weekIds);
 
-              // Resolve week_start values for these IDs (safe table)
-              const { data: weeksData, error: weekErr } = await supaClient
-                .from('rota_weeks')
-                .select('id, week_start')
-                .in('id', weekIds)
-                .order('week_start', { ascending: true });
-
-              if (weekErr) {
-                console.error('Week fetch error:', weekErr);
-                throw weekErr;
-              }
-
-              weeks = weeksData; // Assign to outer scope variable
-              console.log('Weeks fetched (by DOM ids):', weeks?.length || 0, weeks);
+              // Resolve week_start values from in-memory weeks
+              const allWeekRows = (allWeeks || []).map(w => ({
+                id: String(w.weekId),
+                week_start: w.weekStart
+              }));
+              weeks = allWeekRows
+                .filter(w => weekIds.includes(String(w.id)))
+                .sort((a, b) => new Date(a.week_start) - new Date(b.week_start));
+              console.log('Weeks resolved (by DOM ids):', weeks?.length || 0, weeks);
 
               if (weeks && weeks.length > 0) {
                 // EXACT same path as the modal: fetchWeekComments per week
@@ -8169,11 +8055,10 @@ window.addEventListener('load',function(){requestAnimationFrame(function(){reque
                 return
             }
             const{data:comments,error}=await supaClient
-                .from("week_comments")
-                .select("*, users(name)")
-                .eq("period_id",activePeriodId)
-                .order("week_start",{ascending:true})
-                .order("created_at",{ascending:true});
+                .rpc("admin_get_week_comments_for_period", {
+                    p_token: window.currentToken,
+                    p_period_id: activePeriodId
+                });
             if(error)throw error;
             if(!comments||comments.length===0){
                 alert("No comments found for this period.");
@@ -8182,7 +8067,7 @@ window.addEventListener('load',function(){requestAnimationFrame(function(){reque
             let csv="Week Start,User,Comment,Posted\n";
             comments.forEach(c=>{
                 const weekDate=new Date(c.week_start).toLocaleDateString("en-GB");
-                const userName=c.users?.name||"Unknown";
+                const userName=usersById.get(String(c.user_id))||"Unknown";
                 const comment=(c.comment||"").replace(/"/g,'""');
                 const posted=new Date(c.created_at).toLocaleString("en-GB");
                 csv+=`"${weekDate}","${userName}","${comment}","${posted}"\n`
@@ -8258,13 +8143,12 @@ window.addEventListener('load',function(){requestAnimationFrame(function(){reque
         // Get user_id from validation
         const userId = result.user_id;
         
-        // Fetch full user details from database
-        const { data: userData, error: userError } = await supaClient
-          .from('users')
-          .select('id, name, role_id, is_admin, is_active, preferred_lang')
-          .eq('id', userId)
-          .single();
-          
+        // Fetch full user details via token-only RPC
+        const { data: userRows, error: userError } = await supaClient
+          .rpc('rpc_get_current_user', { p_token: token });
+
+        const userData = Array.isArray(userRows) ? userRows[0] : userRows;
+
         if (userError || !userData) {
           console.error('Failed to fetch user data:', userError);
           window.location.href = 'index.html';
\n
==== DIFF: rota.html ====\n
diff --git "a/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\Calpe-Ward Backup\\Calpe-Ward\\rota.html" "b/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\rota.html"
index b182610..771b589 100644
--- "a/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\Calpe-Ward Backup\\Calpe-Ward\\rota.html"	
+++ "b/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\rota.html"	
@@ -20,6 +20,8 @@
   <script src="js/notifications-shared.js" defer></script>
   <script src="js/shift-functions.js" defer></script>
   <script src="js/shift-editor.js" defer></script>
+  <script src="js/periods-shared.js" defer></script>
+  <script src="js/non-staff-modal-shared.js" defer></script>
 </head>
 
 <body>
@@ -635,6 +637,7 @@
     let currentPeriod = null;
     let allUsers = [];
     let allWeeks = [];
+    let shifts = []; // shift_catalogue rows
     let shiftMap = new Map(); // id -> shift_catalogue row
     let assignmentsMap = new Map(); // user_id_date -> rota_assignment
     let overridesMap = new Map(); // rota_assignment_id -> rota_assignment_override
@@ -651,7 +654,6 @@
     let canEditDraft = false;
     let canEditPublished = false;
     let currentEditContext = "draft";
-    let lastPublishedCell = null;
 
     // Expose context for helper modules (context menu, history)
     window.currentEditContext = currentEditContext;
@@ -664,36 +666,277 @@
       return defaults;
     }
     
+    // ========== PERIOD LOADING ==========
+    /**
+     * Load all data for a specific rota period (dates, shifts, assignments, etc.)
+     */
+    async function loadPeriod(periodId) {
+      if (!periodId) return;
+      
+      console.log("[ROTA] loadPeriod starting for period:", periodId);
+      
+      try {
+        const token = window.currentToken || sessionStorage.getItem('calpe_ward_token');
+        if (!token) throw new Error('No session token');
+        
+        // Load all periods via RPC to get metadata for selected period
+        const { data: allPeriods, error: pErr } = await supabaseClient.rpc("rpc_get_rota_periods", {
+          p_token: token
+        });
+
+        if (pErr) throw new Error(`Periods load failed: ${pErr.message}`);
+        const period = (allPeriods || []).find(p => p.id === periodId);
+        if (!period) throw new Error("Period not found");
+        
+        currentPeriod = period;
+        periodData = period;
+        window.currentPeriod = currentPeriod;
+        window.periodData = periodData;
+        
+        console.log("[ROTA] Generating dates for period...");
+        
+        // Helper functions for date generation
+        function generateDatesForPeriod(startDate, endDate) {
+          const dates = [];
+          const d = new Date(startDate);
+          while (d <= new Date(endDate)) {
+            dates.push(new Date(d).toISOString().split('T')[0]);
+            d.setDate(d.getDate() + 1);
+          }
+          return dates;
+        }
+        
+        function groupDatesIntoWeeks(dates) {
+          const weeks = [];
+          const grouped = {};
+          dates.forEach(dateStr => {
+            const d = new Date(dateStr + 'T00:00:00Z');
+            const dayOfWeek = d.getUTCDay();
+            const weekStart = new Date(d);
+            weekStart.setUTCDate(d.getUTCDate() - dayOfWeek);
+            const weekStartStr = weekStart.toISOString().split('T')[0];
+            if (!grouped[weekStartStr]) grouped[weekStartStr] = [];
+            grouped[weekStartStr].push(dateStr);
+          });
+          Object.entries(grouped).forEach(([weekStartStr, dates]) => {
+            const weekStartDate = new Date(weekStartStr + 'T00:00:00Z');
+            weeks.push({ 
+              weekStart: weekStartDate,
+              days: dates.map(d => ({ date: d }))
+            });
+          });
+          return weeks;
+        }
+        
+        const dates = generateDatesForPeriod(period.start_date, period.end_date);
+        allWeeks = groupDatesIntoWeeks(dates);
 
+        // Load users via RPC (active only)
+        console.log("[ROTA] Loading users via RPC...");
+        const { data: users, error: uErr } = await supabaseClient.rpc("rpc_get_users_basic", {
+          p_token: token,
+          p_include_inactive: false
+        });
 
-    // ========== AUTH ==========
-    async function checkAuth() {
-      console.log("[ROTA DEBUG] checkAuth starting...");
+        if (uErr) throw new Error(`Users load failed: ${uErr.message}`);
+        allUsers = (users || []).map(u => ({ ...u, is_non_staff: false }));
+
+        // Load non-staff for this period
+        console.log("[ROTA] Loading period non-staff...");
+        try {
+          const { data: nonStaff, error: nsErr } = await supabaseClient.rpc("rpc_get_period_non_staff", {
+            p_token: token,
+            p_period_id: periodId
+          });
+
+          if (nsErr) {
+            console.warn("[ROTA] Non-staff load failed:", nsErr);
+          } else if (nonStaff && nonStaff.length > 0) {
+            console.log("[ROTA] Loaded", nonStaff.length, "non-staff");
+            nonStaff.forEach(ns => {
+              allUsers.push({
+                id: ns.period_non_staff_id,
+                period_non_staff_id: ns.period_non_staff_id,
+                name: ns.name,
+                role_id: ns.role_group === 'staff_nurse' ? 2 : 3,
+                category: ns.category,
+                is_admin: false,
+                is_non_staff: true,
+                counts_towards_staffing: ns.counts_towards_staffing,
+                display_order: ns.display_order
+              });
+            });
+          }
+        } catch (e) {
+          console.warn("[ROTA] Failed to load non-staff:", e.message);
+        }
+
+        // Load shift catalogue via RPC
+        console.log("[ROTA] Loading shifts via RPC...");
+        const { data: shiftsData, error: sErr } = await supabaseClient.rpc("rpc_get_shifts", {
+          p_token: token
+        });
+
+        if (sErr) throw new Error(`Shifts load failed: ${sErr.message}`);
+        shifts = shiftsData || [];
+        shiftMap.clear();
+        (shifts || []).forEach(s => shiftMap.set(s.id, s));
+        console.log("[ROTA] Loaded", shiftMap.size, "shifts");
+
+        // Load assignments via RPC
+        console.log("[ROTA] Loading assignments via RPC...");
+        const canViewDraft = window.PermissionsModule?.hasPermission("rota.view_draft");
+        const isPeriodPublished = period.status === "published";
+
+        assignmentsMap.clear();
+        overridesMap.clear();
+        commentsMap.clear();
+        
+        if (canViewDraft || isPeriodPublished) {
+          const { data: assignments, error: aErr } = await supabaseClient.rpc("rpc_get_rota_assignments", {
+            p_token: token,
+            p_period_id: periodId,
+            p_include_draft: canViewDraft || !isPeriodPublished
+          });
+
+          if (aErr) throw new Error(`Assignments load failed: ${aErr.message}`);
+
+          const assignmentIds = [];
+          (assignments || []).forEach(a => {
+            const userId = a.user_id || a.period_non_staff_id;
+            const key = `${userId}_${a.date}`;
+            assignmentsMap.set(key, a);
+            if (a.id) assignmentIds.push(a.id);
+          });
+          
+          console.log("[ROTA] Loaded", assignmentsMap.size, "assignments");
+
+          // Load overrides for published periods via RPC
+          if (isPeriodPublished && assignmentIds.length > 0) {
+            const { data: overrides, error: oErr } = await supabaseClient.rpc("rpc_get_rota_assignment_overrides", {
+              p_token: token,
+              p_assignment_ids: assignmentIds
+            });
+
+            if (oErr) console.warn("[ROTA] Error loading overrides:", oErr.message);
+            else {
+              (overrides || []).forEach(o => {
+                overridesMap.set(o.rota_assignment_id, o);
+              });
+              console.log("[ROTA] Loaded", overridesMap.size, "overrides");
+            }
+          }
+
+          // Load comments via RPC
+          if (assignmentIds.length > 0) {
+            const { data: comments, error: cErr } = await supabaseClient.rpc("rpc_get_rota_assignment_comments", {
+              p_token: token,
+              p_assignment_ids: assignmentIds
+            });
+
+            if (cErr) {
+              console.warn("[ROTA] Error loading comments:", cErr.message);
+            } else {
+              (comments || []).forEach(c => {
+                if (!commentsMap.has(c.rota_assignment_id)) {
+                  commentsMap.set(c.rota_assignment_id, []);
+                }
+                commentsMap.get(c.rota_assignment_id).push(c);
+              });
+              console.log("[ROTA] Loaded comments for", commentsMap.size, "assignments");
+            }
+          }
+        }
+
+        // Load requests for this period via RPC
+        console.log("[ROTA] Loading requests via RPC...");
+        try {
+          const { data: requests, error: rErr } = await supabaseClient.rpc("get_requests_for_period", {
+            p_token: token,
+            p_start_date: period.start_date,
+            p_end_date: period.end_date,
+            p_force_view_all: canViewAllRequests
+          });
+
+          if (rErr) {
+            console.warn("[ROTA] Failed to load requests:", rErr.message);
+          } else {
+            requestsMap.clear();
+            (requests || []).forEach(r => {
+              const key = `${r.user_id}_${r.date}`;
+              requestsMap.set(key, r);
+            });
+            console.log("[ROTA] Loaded", requestsMap.size, "requests");
+          }
+        } catch (err) {
+          console.warn("[ROTA] Failed to load requests:", err.message);
+        }
+
+        // Load user patterns via RPC
+        console.log("[ROTA] Loading user patterns via RPC...");
+        try {
+          const { data: patternsData, error: patErr } = await supabaseClient.rpc("rpc_get_user_patterns", {
+            p_token: token
+          });
+
+          if (patErr) {
+            console.warn("[ROTA] Failed to load user patterns:", patErr.message);
+          } else {
+            userPatterns.clear();
+            (patternsData || []).forEach(p => {
+              userPatterns.set(p.user_id, p);
+            });
+            console.log("[ROTA] Loaded", userPatterns.size, "user patterns");
+          }
+        } catch (err) {
+          console.warn("[ROTA] Failed to load user patterns:", err.message);
+        }
 
-      console.log("[ROTA DEBUG] STORAGE_KEY getter returns", getStorageKey());
-      console.log("[ROTA DEBUG] localStorage userId", localStorage.getItem(getStorageKey()));
-      console.log("[ROTA DEBUG] supabaseClient available?", !!getSupabase());
+        console.log("[ROTA] Period data loaded successfully");
+        
+        // Display period status and configure editing controls
+        displayPeriodStatus(period);
+        updateEditingControls(period);
+        
+        // Render the rota with loaded data
+        if (typeof renderRota === 'function') {
+          renderRota();
+          console.log("[ROTA] Rota rendered");
+        } else {
+          console.warn("[ROTA] renderRota function not available");
+        }
+        
+      } catch (err) {
+        console.error("[ROTA] loadPeriod error:", err);
+        throw err;
+      }
+    }
 
+    // ========== AUTH ==========
+    async function checkAuth() {
+      console.log("[ROTA] checkAuth starting...");
+      
       if (!window.PermissionsModule || typeof window.PermissionsModule.loadCurrentUserPermissions !== "function") {
-        console.error("[ROTA DEBUG] PermissionsModule not available");
+        console.error("[ROTA] PermissionsModule not available");
         window.location.href = "index.html";
         return null;
       }
 
-      console.log("[ROTA DEBUG] Calling PermissionsModule.loadCurrentUserPermissions...");
+      console.log("[ROTA] Calling PermissionsModule.loadCurrentUserPermissions...");
       await window.PermissionsModule.loadCurrentUserPermissions();
       const currentUser = window.PermissionsModule.getCurrentUser();
-      console.log("[ROTA DEBUG] PermissionsModule currentUser:", currentUser);
+      console.log("[ROTA] After permissions load, currentUser:", currentUser);
 
       if (!currentUser) {
-        console.warn("[ROTA DEBUG] No current user after permissions load; redirecting");
+        console.warn("[ROTA] No current user - redirecting to login");
         window.location.href = "index.html";
         return null;
       }
 
+      console.log("[ROTA] User authenticated:", currentUser.name);
+
       // Store globally for rota.html and other scripts
       window.currentUser = currentUser;
-      console.log("[ROTA DEBUG] User loaded:", currentUser.name);
       
       // Update loginBadge with user name
       const loginBadge = document.getElementById("loginBadge");
@@ -721,8 +964,10 @@
       // Show Add Non-Staff if admin or mentor
       const addNsBtn = document.getElementById("addNonStaffBtn");
       const isMentor = window.PermissionsModule?.hasPermission?.('non_staff.edit_student_shifts');
-      if (addNsBtn) addNsBtn.style.display = (currentUser.is_admin || isMentor) ? "inline-block" : "none";
-      if (addNsBtn) addNsBtn.onclick = openNonStaffModal;
+      if (addNsBtn) {
+        addNsBtn.style.display = (currentUser.is_admin || isMentor) ? "inline-block" : "none";
+        addNsBtn.onclick = openNonStaffModal;
+      }
 
       // Show Print button only for admins
       const rotaPrintBtn = document.getElementById("rotaPrintBtn");
@@ -743,1065 +988,892 @@
     // User modal is now handled by js/user-modal.js
 
     // ========== HELPERS ==========
-    let selectedNonStaffForDelete = null; // Track which person is selected for deletion
+    // selectedNonStaffForDelete is declared in non-staff-modal-shared.js
     let bankHolidaysByDate = {}; // Cache bank holidays by date string (YYYY-MM-DD)
     
-    // Load bank holidays for the current and next few years
-    async function loadBankHolidays() {
-      try {
-        const currentYear = new Date().getFullYear();
-        const { data, error } = await supabaseClient.rpc('rpc_get_all_bank_holidays', {
-          p_start_year: currentYear,
-          p_end_year: currentYear + 3
-        });
-        if (error) throw error;
-        if (data) {
-          data.forEach(holiday => {
-            const dateStr = holiday.holiday_date; // YYYY-MM-DD format from DB
-            bankHolidaysByDate[dateStr] = holiday.name;
-          });
-        }
-      } catch (e) {
-        console.warn('Failed to load bank holidays:', e);
-      }
-    }
-    
-    function isBankHoliday(date) {
-      if (!date) return false;
-      const dateStr = date.toISOString().split('T')[0]; // Convert to YYYY-MM-DD
-      return bankHolidaysByDate.hasOwnProperty(dateStr);
-    }
-    
-    function getBankHolidayName(date) {
-      if (!date) return null;
-      const dateStr = date.toISOString().split('T')[0];
-      return bankHolidaysByDate[dateStr] || null;
-    }
-    
-    function getWeekStart(date) {
-      const d = new Date(date);
-      const day = d.getDay(); // 0 = Sunday
-      d.setDate(d.getDate() - day);
-      d.setHours(0, 0, 0, 0);
-      return d;
-    }
-
-    function fmt(date) {
-      const d = new Date(date);
-      return d.toLocaleDateString("en-GB", { day: "numeric", month: "short" });
+    function closePublishedDetails() {
+      const modal = document.getElementById("publishedDetailsModal");
+      if (modal) modal.setAttribute("aria-hidden", "true");
     }
 
-    // ========== LOAD PERIODS ==========
-    async function loadPeriods() {
-      const { data, error } = await supabaseClient
-        .from("rota_periods")
-        .select("*")
-        .order("start_date", { ascending: false });
-
-      if (error) {
-        console.error("Error loading periods:", error);
-        alert("Failed to load rota periods: " + error.message);
-        return;
+    window.openPublishedDetails = function openPublishedDetails(context) {
+      console.log("[OPEN PUBLISHED DETAILS] Called with context:", context);
+      window.currentPublishedContext = context;
+      window.lastPublishedCell = context;
+      const { userId, date } = context;
+      
+      const user = allUsers?.find(u => u.id === userId);
+      const assignment = assignmentsMap?.get(`${userId}_${date}`);
+      const shift = assignment ? shiftMap?.get(assignment.shift_id) : null;
+      
+      // Populate modal header
+      const titleEl = document.getElementById("publishedDetailsTitle");
+      const subtitleEl = document.getElementById("publishedDetailsSubtitle");
+      if (titleEl) titleEl.textContent = user?.name || "Shift Details";
+      const dateObj = new Date(date);
+      if (subtitleEl) subtitleEl.textContent = dateObj.toLocaleDateString("en-GB", { weekday: "short", day: "numeric", month: "short", year: "numeric" });
+      
+      // Populate shift details
+      const codeEl = document.getElementById("publishedShiftCode");
+      const nameEl = document.getElementById("publishedShiftName");
+      const restDayLabel = document.getElementById("restDayLabel");
+      
+      if (shift?.code === "O") {
+        // Rest day
+        if (codeEl) codeEl.textContent = "OFF";
+        if (nameEl) nameEl.textContent = "Rest day";
+        if (restDayLabel) restDayLabel.style.display = "";
+      } else if (shift) {
+        if (codeEl) codeEl.textContent = shift.code || "";
+        if (nameEl) nameEl.textContent = shift.shift_name || shift.code || "";
+        if (restDayLabel) restDayLabel.style.display = "none";
+      } else {
+        if (codeEl) codeEl.textContent = "ÔÇö";
+        if (nameEl) nameEl.textContent = "No shift assigned";
+        if (restDayLabel) restDayLabel.style.display = "none";
       }
-
-      const select = document.getElementById("periodSelect");
-      select.innerHTML = '<option value="">Select period...</option>';
       
-      if (!data || data.length === 0) {
-        select.innerHTML = '<option value="">No periods available</option>';
-        console.warn("No rota periods found in database");
-        return;
+      // Populate times and hours
+      const override = assignment ? overridesMap?.get(assignment.id) : null;
+      
+      const scheduledTimesRow = document.getElementById("scheduledTimesRow");
+      const scheduledTimes = document.getElementById("scheduledTimes");
+      const actualTimesRow = document.getElementById("actualTimesRow");
+      const actualTimes = document.getElementById("actualTimes");
+      const hoursRow = document.getElementById("hoursRow");
+      const hoursEl = document.getElementById("publishedShiftHours");
+      
+      if (shift && shift.code !== "O") {
+        // Show scheduled times
+        const startTime = shift.start_time ? shift.start_time.slice(0, 5) : "ÔÇö";
+        const endTime = shift.end_time ? shift.end_time.slice(0, 5) : "ÔÇö";
+        if (scheduledTimes) scheduledTimes.textContent = `${startTime} ÔÇô ${endTime}`;
+        if (scheduledTimesRow) scheduledTimesRow.style.display = "";
+        if (hoursEl) hoursEl.textContent = shift.hours_value || "ÔÇö";
+        if (hoursRow) hoursRow.style.display = "";
+      } else {
+        if (scheduledTimesRow) scheduledTimesRow.style.display = "none";
+        if (hoursRow) hoursRow.style.display = "none";
+      }
+      
+      // Show override if present
+      if (override && (override.override_start_time || override.override_end_time)) {
+        const overrideStart = override.override_start_time || "ÔÇö";
+        const overrideEnd = override.override_end_time || "ÔÇö";
+        if (actualTimes) actualTimes.textContent = `${overrideStart} ÔÇô ${overrideEnd}`;
+        if (actualTimesRow) actualTimesRow.style.display = "";
+        if (hoursEl && override.override_hours) hoursEl.textContent = override.override_hours;
+      } else {
+        if (actualTimesRow) actualTimesRow.style.display = "none";
       }
       
-      data.forEach(p => {
-        const opt = document.createElement("option");
-        opt.value = p.id;
-        opt.textContent = `${fmt(new Date(p.start_date))} ÔÇô ${fmt(new Date(p.end_date))}`;
-        select.appendChild(opt);
+      // Populate comments if visible
+      const commentDisplay = document.getElementById("commentDisplay");
+      const commentText = document.getElementById("commentText");
+      const comments = assignment ? commentsMap?.get(assignment.id) : null;
+      const isAdmin = window.currentUser?.is_admin;
+      const visibleComments = (comments || []).filter(c => {
+        const vis = c.comment_visibility || (c.is_admin_only ? 'admin_only' : 'all_staff');
+        if (vis === 'admin_only') return isAdmin;
+        if (vis === 'user_only') return window.currentUser?.id === userId;
+        return true;
       });
-
-      if (data.length > 0) {
-        // Find period containing today's date, or fall back to most recent
-        const today = new Date();
-        today.setHours(0, 0, 0, 0);
-        const todayStr = today.toISOString().split('T')[0]; // YYYY-MM-DD in local timezone
-        const currentPeriod = data.find(p => {
-          // Compare date strings directly to avoid timezone issues
-          return todayStr >= p.start_date && todayStr <= p.end_date;
-        });
-        const periodToLoad = currentPeriod || data[0];
-        select.value = periodToLoad.id;
-        await loadPeriod(periodToLoad.id);
+      
+      if (visibleComments.length > 0) {
+        const firstComment = visibleComments[0];
+        if (commentText) commentText.textContent = firstComment.comment || "";
+        if (commentDisplay) commentDisplay.style.display = "";
+      } else {
+        if (commentDisplay) commentDisplay.style.display = "none";
       }
+      
+      // Open modal
+      const modal = document.getElementById("publishedDetailsModal");
+      if (modal) modal.setAttribute("aria-hidden", "false");
     }
 
-    // ========== NON-STAFF MODAL LOGIC ==========
-    function openNonStaffModal() {
-      const backdrop = document.getElementById('nonStaffModalBackdrop');
-      if (!backdrop) return;
-      const isMentor = window.PermissionsModule?.hasPermission?.('non_staff.edit_student_shifts');
-      // Mentors default to students and lock categories
-      const categorySel = document.getElementById('nsCategory');
-      const categorySelCreate = document.getElementById('nsCategoryCreate');
-      if (categorySel) {
-        categorySel.value = 'student';
-        categorySel.disabled = !window.currentUser?.is_admin && isMentor;
+    function handlePublishedChange() {
+      const cell = window.lastPublishedCell || lastPublishedCell;
+      if (!cell) return;
+      if (!canEditPublished) {
+        alert("You don't have permission to edit published rotas.");
+        return;
       }
-      if (categorySelCreate) {
-        categorySelCreate.value = 'student';
-        categorySelCreate.disabled = !window.currentUser?.is_admin && isMentor;
+      closePublishedDetails();
+      
+      // Try to open shift picker
+      if (typeof window.openShiftPickerForPublished === "function") {
+        console.log("[ROTA] openShiftPickerForPublished is available, calling it");
+        window.openShiftPickerForPublished(cell.userId, cell.date);
+      } else {
+        console.error("[ROTA] openShiftPickerForPublished not available. Checking shift-editor status...");
+        console.log("[ROTA] window.initDraftEditing available?", typeof window.initDraftEditing === "function");
+        alert("Shift editor not ready. Please try again or refresh the page.");
       }
-      // Initialize role group + counts UI for default (student)
-      updateNonStaffModalFields();
-      updateNonStaffModalFieldsCreate();
-      document.getElementById('nsSearch')?.setAttribute('value','');
-      document.getElementById('nsResults').innerHTML = '';
-      document.getElementById('nsNewName').value = '';
-      // Switch to Select tab by default
-      switchNonStaffTab('select');
-      backdrop.setAttribute('aria-hidden','false');
     }
 
-    function closeNonStaffModal() {
-      const backdrop = document.getElementById('nonStaffModalBackdrop');
-      if (backdrop) backdrop.setAttribute('aria-hidden','true');
+    function handlePublishedOverride() {
+      const cell = window.lastPublishedCell || lastPublishedCell;
+      if (!cell) return;
+      if (!canEditPublished) {
+        alert("You don't have permission to edit published rotas.");
+        return;
+      }
+      closePublishedDetails();
+      openOverrideAmendmentModal(cell.userId, cell.date);
     }
 
-    async function searchNonStaff() {
-      const category = document.getElementById('nsCategory')?.value || null;
-      const roleGroup = (category === 'student') ? null : (document.getElementById('nsRoleGroup')?.value || null);
-      const query = document.getElementById('nsSearch')?.value || null;
-      const resultsEl = document.getElementById('nsResults');
-      if (!resultsEl) return;
-      resultsEl.innerHTML = '<div style="color:#64748b;">Searching...</div>';
+    function openOverrideAmendmentModal(userId, date) {
       try {
-        const { data, error } = await supabaseClient.rpc('rpc_list_non_staff_people', {
-          p_token: window.currentToken,
-          p_category: category,
-          p_role_group: roleGroup,
-          p_query: query
-        });
-        if (error) throw error;
-        if (!data || data.length === 0) {
-          resultsEl.innerHTML = '<div style="color:#64748b;">No matches.</div>';
+        const backdrop = document.getElementById("overrideAmendmentModalBackdrop");
+        const title = document.getElementById("overrideAmendmentTitle");
+        const subtitle = document.getElementById("overrideAmendmentSubtitle");
+        const startTimeInput = document.getElementById("amendmentStartTime");
+        const endTimeInput = document.getElementById("amendmentEndTime");
+        const hoursInput = document.getElementById("amendmentHours");
+        const reasonInput = document.getElementById("amendmentReason");
+
+        if (!backdrop) {
+          console.error("[OVERRIDE AMENDMENT] Modal backdrop not found");
+          alert("Modal not initialized");
           return;
         }
-        resultsEl.innerHTML = '';
-        data.forEach(row => {
-          const line = document.createElement('div');
-          line.style.display = 'flex';
-          line.style.justifyContent = 'space-between';
-          line.style.alignItems = 'center';
-          line.style.padding = '8px 6px';
-          line.style.cursor = 'pointer';
-          line.style.borderRadius = '4px';
-          line.style.transition = 'background 200ms';
-          
-          line.addEventListener('mouseenter', () => { line.style.background = '#f1f5f9'; });
-          line.addEventListener('mouseleave', () => { line.style.background = ''; });
-          line.addEventListener('click', () => {
-            selectedNonStaffForDelete = row;
-            showDeleteSection(row);
-          });
-          
-          const left = document.createElement('div');
-          left.textContent = `${row.name} -À ${row.category}${row.role_group ? ' -À ' + row.role_group : ''}`;
-          const btn = document.createElement('button');
-          btn.textContent = 'Add';
-          btn.style.whiteSpace = 'nowrap';
-          btn.addEventListener('click', (e) => {
-            e.stopPropagation();
-            addExistingNonStaff(row.id, row.category);
-          });
-          line.appendChild(left);
-          line.appendChild(btn);
-          resultsEl.appendChild(line);
-        });
-      } catch (e) {
-        resultsEl.innerHTML = `<div style="color:#dc2626;">Error: ${e?.message || e}</div>`;
-      }
-    }
 
-    async function addExistingNonStaff(nonStaffPersonId, category) {
-      const counts = document.getElementById('nsCounts');
-      const countsVal = counts?.checked ?? (category !== 'student');
-      try {
-        const { data, error } = await supabaseClient.rpc('rpc_add_non_staff_to_period', {
-          p_token: window.currentToken,
-          p_period_id: currentPeriod,
-          p_non_staff_person_id: nonStaffPersonId,
-          p_counts_towards_staffing: countsVal,
-          p_display_order: 9999
-        });
-        if (error) throw error;
-        closeNonStaffModal();
-        await loadPeriod(currentPeriod);
-      } catch (e) {
-        alert('Failed to add: ' + (e?.message || e));
-      }
-    }
+        const assignment = (typeof getAssignment === "function"
+          ? getAssignment(userId, date)
+          : window.getAssignment?.(userId, date))
+          || assignmentsMap?.get(`${userId}_${date}`);
+        const user = allUsers?.find(u => u.id === userId);
+        const dateObj = new Date(date);
 
-    async function addNewNonStaff() {
-      const name = document.getElementById('nsNewName')?.value?.trim();
-      const category = document.getElementById('nsCategoryCreate')?.value;
-      const roleGroup = category === 'student' ? null : document.getElementById('nsRoleGroupCreate')?.value;
-      const counts = (category === 'student') ? false : true;
-      if (!name) {
-        alert('Enter a name for the new profile.');
-        return;
-      }
-      try {
-        const { data: created, error: addErr } = await supabaseClient.rpc('rpc_add_non_staff_person', {
-          p_token: window.currentToken,
-          p_name: name,
-          p_category: category,
-          p_role_group: roleGroup,
-          p_notes: null
-        });
-        if (addErr) throw addErr;
-        const newId = created?.id;
-        if (!newId) throw new Error('Create returned no id');
-        await addExistingNonStaff(newId, category);
-      } catch (e) {
-        alert('Failed to create/add: ' + (e?.message || e));
+        console.log("[OVERRIDE AMENDMENT] Opening modal for assignment:", assignment);
+
+        if (title) title.textContent = user ? `${user.name} - Override Shift Times` : "Override Shift Times";
+        if (subtitle) subtitle.textContent = dateObj.toLocaleDateString("en-GB", { weekday: "short", day: "numeric", month: "short", year: "numeric" });
+
+        // Load existing override if any
+        if (assignment?.id) {
+          const override = overridesMap?.get(assignment.id);
+          console.log("[OVERRIDE AMENDMENT] Found override:", override);
+          if (override) {
+            if (startTimeInput) startTimeInput.value = override.override_start_time || "";
+            if (endTimeInput) endTimeInput.value = override.override_end_time || "";
+            if (hoursInput) hoursInput.value = override.override_hours || "";
+            if (reasonInput) reasonInput.value = override.comment || "";
+          } else {
+            // No override yet ÔÇô prefill with scheduled shift times to make entry quicker
+            const shift = assignment.shift_id ? shiftMap?.get(assignment.shift_id) : null;
+            const start = shift?.start_time ? shift.start_time.slice(0,5) : "";
+            const end = shift?.end_time ? shift.end_time.slice(0,5) : "";
+            if (startTimeInput) startTimeInput.value = start;
+            if (endTimeInput) endTimeInput.value = end;
+            if (hoursInput) {
+              if (shift?.hours != null) {
+                hoursInput.value = shift.hours;
+              } else if (start && end) {
+                const [sh, sm] = start.split(":").map(Number);
+                const [eh, em] = end.split(":").map(Number);
+                let mins = (eh*60 + em) - (sh*60 + sm);
+                if (mins < 0) mins += 24*60; // overnight safeguard
+                hoursInput.value = Math.round((mins/60)*4)/4;
+              } else {
+                hoursInput.value = "";
+              }
+            }
+            if (reasonInput) reasonInput.value = "";
+          }
+        }
+
+        // Store context for save
+        window.overrideAmendmentContext = { userId, date, assignmentId: assignment?.id };
+
+        console.log("[OVERRIDE AMENDMENT] Opening modal, context:", window.overrideAmendmentContext);
+        backdrop.setAttribute("aria-hidden", "false");
+      } catch (err) {
+        console.error("[OVERRIDE AMENDMENT] Error opening modal:", err);
+        alert("Error opening override modal. Check console.");
       }
     }
 
-    function showDeleteSection(item) {
-      const deleteSection = document.getElementById('nsDeleteSection');
-      const deleteItemName = document.getElementById('nsDeleteItemName');
-      const isMentor = window.PermissionsModule?.hasPermission?.('non_staff.edit_student_shifts');
-      
-      // Only show delete if admin or mentor (for students)
-      const canDelete = window.currentUser?.is_admin || (isMentor && item.category === 'student');
-      if (!canDelete) {
-        deleteSection.style.display = 'none';
-        return;
+    function handlePublishedHistory() {
+      const cell = window.lastPublishedCell || lastPublishedCell;
+      if (!cell) return;
+
+      if (window.AssignmentHistoryModule?.loadAssignmentHistory) {
+        closePublishedDetails();
+        window.AssignmentHistoryModule.loadAssignmentHistory(cell.userId, cell.date);
+      } else {
+        alert("History module not loaded.");
       }
-      
-      deleteItemName.textContent = `${item.name} (${item.category})`;
-      deleteSection.style.display = 'block';
     }
 
-    async function deleteSelectedNonStaff() {
-      if (!selectedNonStaffForDelete || !selectedNonStaffForDelete.id) {
-        alert('No item selected for deletion');
+    async function handlePublishedComments() {
+      console.log("[COMMENTS DEBUG] handlePublishedComments called");
+      console.log("[COMMENTS DEBUG] window.lastPublishedCell:", window.lastPublishedCell);
+      if (!window.lastPublishedCell) {
+        console.log("[COMMENTS DEBUG] ERROR: window.lastPublishedCell not set!");
+        alert("Please select a shift first.");
         return;
       }
-      
-      const confirmMsg = `Remove ${selectedNonStaffForDelete.name} from this period?`;
-      if (!confirm(confirmMsg)) return;
-      
-      try {
-        const { error } = await supabaseClient.rpc('rpc_remove_non_staff_from_period', {
-          p_token: window.currentToken,
-          p_period_non_staff_id: selectedNonStaffForDelete.id
-        });
-        if (error) throw error;
-        selectedNonStaffForDelete = null;
-        document.getElementById('nsDeleteSection').style.display = 'none';
-        await loadPeriod(currentPeriod);
-      } catch (e) {
-        alert('Failed to remove: ' + (e?.message || e));
-      }
-    }
 
-    // Tab switching for Select vs Create sections
-    function switchNonStaffTab(tab) {
-      const selectSection = document.getElementById('nsSelectSection');
-      const createSection = document.getElementById('nsCreateSection');
-      const tabSelect = document.getElementById('nsTabSelect');
-      const tabCreate = document.getElementById('nsTabCreate');
-      
-      if (tab === 'select') {
-        if (selectSection) selectSection.style.display = 'block';
-        if (createSection) createSection.style.display = 'none';
-        if (tabSelect) {
-          tabSelect.style.color = '#0f172a';
-          tabSelect.style.borderBottomColor = '#3b82f6';
-        }
-        if (tabCreate) {
-          tabCreate.style.color = '#94a3b8';
-          tabCreate.style.borderBottomColor = 'transparent';
-        }
-      } else {
-        if (selectSection) selectSection.style.display = 'none';
-        if (createSection) createSection.style.display = 'block';
-        if (tabSelect) {
-          tabSelect.style.color = '#94a3b8';
-          tabSelect.style.borderBottomColor = 'transparent';
-        }
-        if (tabCreate) {
-          tabCreate.style.color = '#0f172a';
-          tabCreate.style.borderBottomColor = '#3b82f6';
-        }
+      const { userId, date } = window.lastPublishedCell;
+      const user = allUsers.find(u => u.id === userId);
+      const assignment = assignmentsMap.get(`${userId}_${date}`);
+
+      console.log("[COMMENTS DEBUG] Looking up assignment for key:", `${userId}_${date}`);
+      console.log("[COMMENTS DEBUG] Found assignment:", assignment);
+
+      if (!assignment) {
+        console.log("[COMMENTS DEBUG] ERROR: No assignment found!");
+        alert("No assignment for this date.");
+        return;
       }
-    }
 
-    // Bind modal buttons after DOM ready
-    document.addEventListener('DOMContentLoaded', () => {
-      const searchBtn = document.getElementById('nsSearchBtn');
-      if (searchBtn) searchBtn.addEventListener('click', searchNonStaff);
-      const closeBtn = document.getElementById('nsCloseBtn');
-      if (closeBtn) closeBtn.addEventListener('click', closeNonStaffModal);
-      const addBtn = document.getElementById('nsAddBtn');
-      if (addBtn) addBtn.addEventListener('click', addNewNonStaff);
-      const deleteBtn = document.getElementById('nsDeleteBtn');
-      if (deleteBtn) deleteBtn.addEventListener('click', deleteSelectedNonStaff);
-      const categorySel = document.getElementById('nsCategory');
-      if (categorySel) categorySel.addEventListener('change', updateNonStaffModalFields);
-      const categorySelCreate = document.getElementById('nsCategoryCreate');
-      if (categorySelCreate) categorySelCreate.addEventListener('change', updateNonStaffModalFieldsCreate);
-      const backdrop = document.getElementById('nonStaffModalBackdrop');
-      if (backdrop) backdrop.addEventListener('click', (e) => { if (e.target === backdrop) closeNonStaffModal(); });
-      
-      // Tab switching
-      const tabSelect = document.getElementById('nsTabSelect');
-      if (tabSelect) tabSelect.addEventListener('click', () => switchNonStaffTab('select'));
-      const tabCreate = document.getElementById('nsTabCreate');
-      if (tabCreate) tabCreate.addEventListener('click', () => switchNonStaffTab('create'));
-    });
+      // Load comments via RPC instead of direct query
+      console.log("[COMMENTS DEBUG] Loading comments for assignment ID:", assignment.id);
+      const token = sessionStorage.getItem('calpe_ward_token');
+      const { data: comments, error } = await supabaseClient
+        .rpc("rpc_get_rota_assignment_comments", { p_assignment_ids: [assignment.id], p_token: token });
 
-    function updateNonStaffModalFields(){
-      const category = document.getElementById('nsCategory')?.value;
-      const roleWrap = document.getElementById('nsRoleGroupWrap');
-      const countsWrap = document.getElementById('nsCountsWrap');
-      const counts = document.getElementById('nsCounts');
-      if (!category) return;
-      if (category === 'student'){
-        if (roleWrap) roleWrap.style.display = 'none';
-        if (countsWrap) countsWrap.style.display = 'none';
-        if (counts) { counts.checked = false; counts.disabled = true; }
-      } else if (category === 'agency') {
-        if (roleWrap) roleWrap.style.display = '';
-        if (countsWrap) countsWrap.style.display = '';
-        if (counts) { counts.checked = true; counts.disabled = true; }
-      } else {
-        // bank: allow toggle
-        if (roleWrap) roleWrap.style.display = '';
-        if (countsWrap) countsWrap.style.display = '';
-        if (counts) { counts.disabled = false; }
+      if (error) {
+        console.error("Error loading comments:", error);
+        alert("Failed to load comments.");
+        return;
       }
-    }
 
-    function updateNonStaffModalFieldsCreate(){
-      const category = document.getElementById('nsCategoryCreate')?.value;
-      const roleWrap = document.getElementById('nsRoleGroupCreateWrap');
-      const countsWrap = document.getElementById('nsCountsWrap');
-      const counts = document.getElementById('nsCounts');
-      if (!category) return;
-      if (category === 'student'){
-        if (roleWrap) roleWrap.style.display = 'none';
-        if (countsWrap) countsWrap.style.display = 'none';
-        if (counts) { counts.checked = false; counts.disabled = true; }
-      } else if (category === 'agency') {
-        if (roleWrap) roleWrap.style.display = '';
-        if (countsWrap) countsWrap.style.display = '';
-        if (counts) { counts.checked = true; counts.disabled = true; }
-      } else {
-        // bank: allow toggle
-        if (roleWrap) roleWrap.style.display = '';
-        if (countsWrap) countsWrap.style.display = '';
-        if (counts) { counts.disabled = false; }
+      console.log("[COMMENTS DEBUG] Loaded comments:", comments);
+
+      // The RPC returns comments for the assignment(s), filter for this specific assignment if needed
+      let assignmentComments = comments || [];
+      if (assignmentComments.length > 0 && assignmentComments[0].assignment_id !== undefined) {
+        // If response includes assignment_id field, filter to just this assignment
+        assignmentComments = assignmentComments.filter(c => c.assignment_id === assignment.id);
       }
-    }
 
-    // ========== LOAD PERIOD DATA ==========
-    async function loadPeriod(periodId) {
-      if (!periodId) return;
-      const periodIdNum = Number(periodId);
-      const periodKey = Number.isFinite(periodIdNum) ? periodIdNum : periodId;
-      currentPeriod = periodKey;
-      // Expose to window for swap-functions/admin operations
-      window.currentPeriod = { id: periodKey };
+      // Filter comments based on visibility
+      const isAdmin = window.currentUser?.is_admin;
+      const visibleComments = assignmentComments.filter(c => {
+        const visibility = c.comment_visibility || (c.is_admin_only ? 'admin_only' : 'all_staff');
+        if (visibility === 'admin_only') return isAdmin;
+        if (visibility === 'all_staff') return true;
+        if (visibility === 'user_only') return window.currentUser?.id === userId;
+        return false;
+      });
 
-      try {
-        // Load period info
-        console.log("[LOAD] Loading period...");
-        const { data: period, error: pErr } = await supabaseClient
-          .from("rota_periods")
-          .select("*")
-          .eq("id", periodId)
-          .single();
-
-        if (pErr) throw new Error(`Period load failed: ${pErr.message}`);
-        if (!period) throw new Error("Period not found");
-        periodData = period;
-        window.periodData = periodData;
-        displayPeriodStatus(period);
+      // Populate modal
+      const modal = document.getElementById("commentsModalBackdrop");
+      const subtitle = document.getElementById("commentsModalSubtitle");
+      const commentsList = document.getElementById("commentsList");
+      const newCommentText = document.getElementById("newCommentText");
+      const isAdminCheckbox = document.getElementById("isAdminOnlyCheckbox");
+      const addBtn = document.getElementById("addCommentBtn");
 
-        // Generate dates from period start_date to end_date
-        const dates = generateDatesForPeriod(period.start_date, period.end_date);
-        allWeeks = groupDatesIntoWeeks(dates);
+      const dateStr = new Date(date).toLocaleDateString("en-GB", { weekday: "short", day: "numeric", month: "short", year: "numeric" });
+      subtitle.textContent = `${user?.name || "Staff"} ÔÇô ${dateStr}`;
 
-        // Load users (active only) using same ordering as main app (role -> display_order -> created_at)
-        console.log("[LOAD] Loading users...");
-        const { data: users, error: uErr } = await supabaseClient
-          .from("users")
-          .select("id, name, role_id, is_admin, display_order")
-          .eq("is_active", true)
-          .order("role_id", { ascending: true })
-          .order("display_order", { ascending: true })
-          .order("created_at", { ascending: true });
+      // Render comments
+      commentsList.innerHTML = "";
+      if (visibleComments.length === 0) {
+        const empty = document.createElement("p");
+        empty.style.color = "#9ca3af";
+        empty.style.fontSize = "13px";
+        empty.textContent = "No comments yet.";
+        commentsList.appendChild(empty);
+      } else {
+        visibleComments.forEach(comment => {
+          const div = document.createElement("div");
+          div.style.padding = "12px";
+          div.style.borderLeft = "3px solid #3b82f6";
+          div.style.backgroundColor = "#f0f9ff";
+          div.style.borderRadius = "4px";
+          div.style.position = "relative";
 
-        if (uErr) throw new Error(`Users load failed: ${uErr.message}`);
-        allUsers = (users || []).map(u => ({ ...u, name: u.name, is_non_staff: false }));
+          // User info
+          const header = document.createElement("div");
+          header.style.fontSize = "12px";
+          header.style.color = "#64748b";
+          header.style.marginBottom = "6px";
+          header.style.display = "flex";
+          header.style.justifyContent = "space-between";
+          header.style.alignItems = "center";
 
-        // Load non-staff for this period
-        console.log("[LOAD] Loading period non-staff...");
-        try {
-          const { data: nonStaff, error: nsErr } = await supabaseClient.rpc("rpc_get_period_non_staff", {
-            p_token: window.currentToken,
-            p_period_id: periodId
-          });
+          const userTime = document.createElement("span");
+          const createdUser = allUsers.find(u => u.id === comment.created_by);
+          console.log("[COMMENTS RENDER] comment.created_by:", comment.created_by, "createdUser found:", createdUser, "allUsers:", allUsers);
+          const createdAt = new Date(comment.created_at).toLocaleString("en-GB");
+          userTime.textContent = `${createdUser?.name || "Unknown"} ÔÇó ${createdAt}`;
+          header.appendChild(userTime);
 
-          if (nsErr) {
-            console.error("Non-staff load failed:", nsErr);
-          } else if (nonStaff && nonStaff.length > 0) {
-            console.log("[LOAD] Loaded", nonStaff.length, "non-staff");
-            
-            // Merge non-staff into allUsers with special flags
-            nonStaff.forEach(ns => {
-              // Use period_non_staff_id as the primary identifier so assignments map aligns
-              allUsers.push({
-                id: ns.period_non_staff_id,
-                non_staff_person_id: ns.id,
-                period_non_staff_id: ns.period_non_staff_id,
-                name: ns.name,
-                role_id: ns.role_group === 'staff_nurse' ? 2 : 3, // Map to SN or NA for grouping
-                is_admin: false,
-                display_order: ns.display_order,
-                is_non_staff: true,
-                category: ns.category, // 'student', 'bank', 'agency'
-                role_group: ns.role_group, // 'staff_nurse', 'nursing_assistant'
-                counts_towards_staffing: ns.counts_towards_staffing,
-                notes: ns.notes
-              });
+          // Delete button (discreet, only visible on hover)
+          const canDelete = window.currentUser?.id === comment.created_by || window.currentUser?.is_admin;
+          if (canDelete) {
+            const deleteBtn = document.createElement("button");
+            deleteBtn.type = "button";
+            deleteBtn.innerHTML = "+ù";
+            deleteBtn.style.background = "none";
+            deleteBtn.style.border = "none";
+            deleteBtn.style.fontSize = "18px";
+            deleteBtn.style.color = "#94a3b8";
+            deleteBtn.style.cursor = "pointer";
+            deleteBtn.style.padding = "0 4px";
+            deleteBtn.style.opacity = "0";
+            deleteBtn.style.transition = "opacity 0.2s, color 0.2s";
+            deleteBtn.title = "Delete comment";
+
+            deleteBtn.addEventListener("mouseenter", () => {
+              deleteBtn.style.color = "#dc2626";
+            });
+            deleteBtn.addEventListener("mouseleave", () => {
+              deleteBtn.style.color = "#94a3b8";
             });
-          }
-        } catch (e) {
-          console.error("Failed to load non-staff:", e);
-        }
 
-        // Load shift catalogue
-        console.log("[LOAD] Loading shifts...");
-        const { data: shifts, error: sErr } = await supabaseClient
-          .from("shifts")
-          .select("*");
+            deleteBtn.addEventListener("click", async (e) => {
+              e.stopPropagation();
+              if (!confirm("Delete this comment?")) return;
 
-        if (sErr) throw new Error(`Shifts load failed: ${sErr.message}`);
-        shiftMap.clear();
-        (shifts || []).forEach(s => shiftMap.set(s.id, s));
+              try {
+                const token = sessionStorage.getItem('calpe_ward_token');
+                const { error } = await supabaseClient
+                  .rpc("rpc_delete_rota_assignment_comment", { p_comment_id: comment.id, p_token: token });
 
-        // Load assignments for this date range
-        // Only show assignments if user has draft permission OR period is published
-        console.log("[LOAD] Loading assignments...");
-        const canViewDraft = window.PermissionsModule.hasPermission("rota.view_draft");
-        const isPeriodPublished = period.status === "published";
-        
-        assignmentsMap.clear();
-        overridesMap.clear();
-        if (canViewDraft || isPeriodPublished) {
-          const { data: assignments, error: aErr } = await supabaseClient
-            .from("rota_assignments")
-            .select("*")
-            .gte("date", period.start_date)
-            .lte("date", period.end_date);
+                if (error) throw error;
 
-          if (aErr) throw new Error(`Assignments load failed: ${aErr.message}`);
-          
-          const assignmentIds = [];
-          (assignments || []).forEach(a => {
-            // Handle both regular users and non-staff assignments
-            const key = a.user_id ? `${a.user_id}_${a.date}` : `${a.period_non_staff_id}_${a.date}`;
-            assignmentsMap.set(key, a);
-            if (a.id) assignmentIds.push(a.id);
-          });
-          
-          // Load overrides ONLY for published periods
-          if (isPeriodPublished && assignmentIds.length > 0) {
-            const { data: overrides, error: oErr } = await supabaseClient
-              .from("rota_assignment_overrides")
-              .select("*")
-              .in("rota_assignment_id", assignmentIds);
+                // Reload comments
+                await handlePublishedComments();
+              } catch (err) {
+                console.error("[COMMENTS] Delete failed:", err);
+                alert("Failed to delete comment.");
+              }
+            });
 
-            if (oErr) console.error("Error loading overrides:", oErr);
-            else {
-              (overrides || []).forEach(o => {
-                overridesMap.set(o.rota_assignment_id, o);
-              });
-            }
+            header.appendChild(deleteBtn);
+
+            // Show delete button on hover
+            div.addEventListener("mouseenter", () => {
+              deleteBtn.style.opacity = "1";
+            });
+            div.addEventListener("mouseleave", () => {
+              deleteBtn.style.opacity = "0";
+            });
           }
-        }
 
-        // Load requests for this date range using RPC function (respects RLS policies)
-        console.log("[LOAD] Loading requests via RPC...");
-        try {
-          const { data: requests, error: rErr } = await supabaseClient.rpc("get_requests_for_period", {
-            p_token: window.currentToken,
-            p_start_date: period.start_date,
-            p_end_date: period.end_date,
-            p_force_view_all: false
-          });
-
-          if (rErr) {
-            console.error("[LOAD] RPC error details:", rErr.code, rErr.message, rErr.details);
-            throw new Error(`Requests load failed: ${rErr.message}`);
+          // Show visibility badge
+          const visibility = comment.comment_visibility || (comment.is_admin_only ? 'admin_only' : 'all_staff');
+          if (visibility !== 'all_staff') {
+            const badge = document.createElement("span");
+            badge.style.fontSize = "11px";
+            badge.style.fontWeight = "600";
+            if (visibility === 'admin_only') {
+              badge.style.color = "#dc2626";
+              badge.textContent = "ADMIN ONLY";
+            } else if (visibility === 'user_only') {
+              badge.style.color = "#2563eb";
+              badge.textContent = "USER ONLY";
+            }
+            header.appendChild(badge);
           }
-          
-          requestsMap.clear();
-          (requests || []).forEach(r => {
-            requestsMap.set(`${r.user_id}_${r.date}`, r);
-          });
-          console.log("[LOAD] requestsMap populated with", requestsMap.size, "entries");
-        } catch (err) {
-          console.error("[LOAD] Failed to load requests:", err.message || err);
-          // Continue without requests if RPC fails
-          requestsMap.clear();
-        }
 
-        // Load assignment comments (for published periods only)
-        console.log("[LOAD] Loading comments...");
-        commentsMap.clear();
-        if (isPeriodPublished) {
-          const { data: comments, error: cErr } = await supabaseClient
-            .from("rota_assignment_comments")
-            .select("*");
-
-          if (cErr) throw new Error(`Comments load failed: ${cErr.message}`);
-          (comments || []).forEach(c => {
-            const existing = commentsMap.get(c.rota_assignment_id) || [];
-            existing.push(c);
-            commentsMap.set(c.rota_assignment_id, existing);
-          });
-          console.log('[LOAD] CommentsMap populated:', commentsMap.size, 'assignments with comments');
-        }
+          div.appendChild(header);
 
-        // Load patterns
-        console.log("[LOAD] Loading patterns...");
-        try {
-          const { data: pats, error: patErr } = await supabaseClient
-            .from("pattern_definitions")
-            .select("*");
+          // Comment text
+          const text = document.createElement("div");
+          text.style.fontSize = "13px";
+          text.style.color = "#0f172a";
+          text.style.whiteSpace = "pre-wrap";
+          text.textContent = comment.comment;
+          div.appendChild(text);
 
-          if (patErr) {
-            console.warn(`[LOAD] Patterns load warning (non-critical): ${patErr.message}. Will continue without patterns.`);
-          } else {
-            patterns.clear();
-            (pats || []).forEach(p => patterns.set(p.id, p));
-            console.log('[LOAD] Patterns loaded:', patterns.size, 'patterns');
-          }
-        } catch (patErr) {
-          console.warn(`[LOAD] Patterns load exception (non-critical):`, patErr.message);
-        }
+          commentsList.appendChild(div);
+        });
+      }
 
-        console.log("[LOAD] Loading user patterns...");
-        try {
-          const { data: upats, error: upatErr } = await supabaseClient
-            .from("user_patterns")
-            .select("*");
+      // Clear form
+      newCommentText.value = "";
+      const visibilityDropdown = document.getElementById("commentVisibilityDropdown");
+      if (visibilityDropdown) visibilityDropdown.value = 'all_staff';
 
-          if (upatErr) {
-            console.warn(`[LOAD] User patterns load warning (non-critical): ${upatErr.message}`);
-          } else {
-            userPatterns.clear();
-            (upats || []).forEach(up => userPatterns.set(up.user_id, up));
-            console.log('[LOAD] User patterns loaded:', userPatterns.size, 'entries');
-          }
-        } catch (upatErr) {
-          console.warn(`[LOAD] User patterns load exception (non-critical):`, upatErr.message);
+      // Store current cell for add handler
+      window._commentsModalCell = { userId, assignmentId: assignment.id, date };
+
+      // Clear old listeners and attach new
+      addBtn.onclick = null;
+      addBtn.addEventListener("click", async () => {
+        const commentText = newCommentText.value.trim();
+        if (!commentText) {
+          alert("Comment cannot be empty.");
+          return;
         }
 
-        // Load all shifts for admin editing from the shifts table
-        console.log("[LOAD] Loading draft shifts...");
-        const { data: draftShiftsData, error: dsErr } = await supabaseClient
-          .from("shifts")
-          .select("*")
-          .order("code", { ascending: true });
+        console.log("[COMMENTS] window.currentUser:", window.currentUser);
+        console.log("[COMMENTS] window.currentUser?.id:", window.currentUser?.id);
+
+        const visibilityDropdown = document.getElementById("commentVisibilityDropdown");
+        const commentVisibility = visibilityDropdown?.value || 'all_staff';
 
-        if (dsErr) throw new Error(`Draft shifts load failed: ${dsErr.message}`);
-        draftShifts = draftShiftsData || [];
-        console.log("[ROTA] Loaded draftShifts:", draftShifts);
-        console.log("[ROTA] Sample shift object:", draftShifts[0]);
+        console.log("[COMMENTS] Saving comment:", { assignmentId: assignment.id, commentText, commentVisibility, userId: window.currentUser?.id });
 
-        // Configure editing context for this period
-        updateEditingControls(period);
+        const token = sessionStorage.getItem('calpe_ward_token');
+        const { error: insertErr, data: newComment } = await supabaseClient
+          .rpc("rpc_add_rota_assignment_comment", {
+            p_assignment_id: assignment.id,
+            p_comment_text: commentText,
+            p_comment_visibility: commentVisibility,
+            p_token: token
+          });
 
-        // Render
-        if (allWeeks.length) {
-          const periodText = `${fmt(allWeeks[0].weekStart)} ÔÇô ${fmt(allWeeks[allWeeks.length - 1].weekEnd)}`;
-          // Don't set periodLabel here anymore since it's part of the header controls
-          // Update page title with period dates
-          const pageTitle = document.querySelector("title");
-          if (pageTitle) {
-            pageTitle.textContent = `Calpe Ward - ${periodText}`;
-          }
+        if (insertErr) {
+          console.error("[COMMENTS] Error saving:", insertErr);
+          alert("Failed to save comment.");
+          return;
         }
 
-        renderRota();
-        generatePatternWarnings();
-
-      } catch (err) {
-        console.error("[LOAD] Fatal error:", err);
-        console.error("[LOAD] Error details:", {
-          message: err?.message,
-          code: err?.code,
-          details: err?.details,
-          fullError: JSON.stringify(err)
-        });
-        alert("Error loading rota: " + (err?.message || err?.toString() || "Unknown error"));
-      }
-    }
+        console.log("[COMMENTS] Comment saved successfully");
 
-    // ========== GENERATE DATES FOR PERIOD ==========
-    function generateDatesForPeriod(startDateStr, endDateStr) {
-      const start = new Date(startDateStr);
-      const end = new Date(endDateStr);
-      const dates = [];
+        // Update commentsMap with the new comment
+        if (newComment) {
+          const existing = commentsMap.get(assignment.id) || [];
+          existing.push(newComment);
+          commentsMap.set(assignment.id, existing);
+          renderRota(); // Re-render to show blue dot
+        }
 
-      for (let d = new Date(start); d <= end; d.setDate(d.getDate() + 1)) {
-        const dateStr = d.toISOString().split('T')[0];
-        dates.push({ date: dateStr });
-      }
+        // Reload comments in modal
+        await handlePublishedComments();
+      });
 
-      return dates;
+      modal.setAttribute("aria-hidden", "false");
     }
 
-    // ========== GROUP DATES INTO WEEKS ==========
-    function groupDatesIntoWeeks(dates) {
-      const weekMap = new Map();
-      
-      dates.forEach(d => {
-        const dt = new Date(d.date);
-        const sun = getWeekStart(dt);
-        const key = sun.toISOString().split('T')[0];
-        
-        if (!weekMap.has(key)) {
-          weekMap.set(key, {
-            weekStart: sun,
-            weekEnd: new Date(sun.getTime() + 6 * 24 * 60 * 60 * 1000),
-            days: []
-          });
-        }
-        
-        weekMap.get(key).days.push(d);
-      });
-      
-      return Array.from(weekMap.values()).sort((a, b) => a.weekStart - b.weekStart);
-    }
+    async function handlePublishedSwap() {
+      const cell = window.lastPublishedCell || lastPublishedCell;
+      if (!cell) return;
+      if (!window.currentUser) return;
 
-    // ========== RENDER ROTA ==========
-    function renderRota() {
-      const table = document.getElementById("rota");
-      table.innerHTML = "";
+      const { userId, date } = cell;
+      // Allow all logged-in staff; admins can still act. Permission gate removed for staff.
+      const isAdmin = !!window.currentUser.is_admin;
 
-      const thead = document.createElement("thead");
-      const tbody = document.createElement("tbody");
-      table.appendChild(thead);
-      table.appendChild(tbody);
+      // Get initiator's user data and shift
+      const initiatorUser = allUsers.find(u => u.id === userId);
+      const initiatorAssignment = assignmentsMap.get(`${userId}_${date}`);
+      const initiatorShift = shiftMap.get(initiatorAssignment?.shift_id);
 
-      // Row 1: Week labels
-      const r1 = document.createElement("tr");
-      const h1 = document.createElement("th");
-      h1.className = "name-col";
-      h1.textContent = "Name";
-      r1.appendChild(h1);
+      if (!initiatorUser || !initiatorShift) {
+        alert("Could not load your shift details.");
+        return;
+      }
 
-      allWeeks.forEach(w => {
-        const th = document.createElement("th");
-        th.className = "week-head";
-        th.colSpan = 7;
-        th.innerHTML = `<span class="week-label">${fmt(w.weekStart)} ÔÇô ${fmt(w.weekEnd)}</span>`;
-        r1.appendChild(th);
+      const initiatorRoleId = initiatorUser.role_id;
+      const initiatorDate = new Date(date);
+      const initiatorWeekStart = new Date(initiatorDate);
+      initiatorWeekStart.setDate(initiatorDate.getDate() - initiatorDate.getDay() + 1); // Monday
 
-        const sep = document.createElement("th");
-        sep.className = "week-sep";
-        r1.appendChild(sep);
-      });
-      thead.appendChild(r1);
+      // Helper: check if two dates are in the same week
+      function isSameWeek(date1Str, date2Str) {
+        const d1 = new Date(date1Str);
+        const d2 = new Date(date2Str);
+        const week1 = new Date(d1);
+        week1.setDate(d1.getDate() - d1.getDay() + 1);
+        const week2 = new Date(d2);
+        week2.setDate(d2.getDate() - d2.getDay() + 1);
+        return week1.getTime() === week2.getTime();
+      }
 
-      // Row 2: Day letters
-      const r2 = document.createElement("tr");
-      const h2 = document.createElement("th");
-      h2.className = "name-col";
-      r2.appendChild(h2);
+      // Get list of other staff with shifts on other dates
+      const candidates = allUsers
+        .filter(u => u.id !== userId) // Remove is_active check - it's not in the users selection
+        .map(u => ({
+          id: u.id,
+          name: u.name,
+          role_id: u.role_id,
+          dates: Array.from(assignmentsMap.entries())
+            .filter(([key, asn]) => {
+              if (!key.startsWith(u.id + "_")) return false;
+              const shift = shiftMap.get(asn.shift_id);
+              if (!shift || shift.code === "O") return false;
 
-      const dayLetters = ["S", "M", "T", "W", "T", "F", "S"];
-      allWeeks.forEach(w => {
-        for (let i = 0; i < 7; i++) {
-          const th = document.createElement("th");
-          th.className = "day";
-          th.textContent = dayLetters[i];
-          r2.appendChild(th);
-        }
-        const sep = document.createElement("th");
-        sep.className = "week-sep";
-        r2.appendChild(sep);
-      });
-      thead.appendChild(r2);
+              const shiftDate = key.split("_")[1];
 
-      // Row 3: Dates
-      const r3 = document.createElement("tr");
-      const h3 = document.createElement("th");
-      h3.className = "name-col";
-      r3.appendChild(h3);
+              // Swap must be within roles (RNÔåöRN or NAÔåöNA only)
+              const initiatorRole = initiatorRoleId; // 1 or 2 = RN, 3 = NA
+              const counterpartyRole = u.role_id;
+              const isInitiatorRN = initiatorRole === 1 || initiatorRole === 2;
+              const isCounterpartyRN = counterpartyRole === 1 || counterpartyRole === 2;
 
-      allWeeks.forEach(w => {
-        for (let i = 0; i < 7; i++) {
-          const d = new Date(w.days[i].date);
-          const isWeekend = (d.getDay() === 0 || d.getDay() === 6);
-          const isBankHol = isBankHoliday(d);
-          const th = document.createElement("th");
-          th.className = "date" + (isWeekend ? " weekend" : "") + (isBankHol ? " bank-holiday" : "");
-          th.textContent = d.getDate();
-          r3.appendChild(th);
-        }
-        const sep = document.createElement("th");
-        sep.className = "week-sep";
-        r3.appendChild(sep);
-      });
-      thead.appendChild(r3);
+              // Must be within same role group (RN with RN, NA with NA)
+              if (isInitiatorRN !== isCounterpartyRN) return false;
 
-      // Body: group by role
-      const groups = groupUsers(allUsers);
+              // Must be same week
+              if (!isSameWeek(date, shiftDate)) return false;
 
-      for (const g of groups) {
-        // Section header
-        const sectionTr = document.createElement("tr");
-        sectionTr.className = "section-row";
-        const sectionTd = document.createElement("td");
-        sectionTd.className = `name-col ${g.className}`;
-        sectionTd.colSpan = 1 + (allWeeks.length * 7) + allWeeks.length;
-        sectionTd.innerHTML = `<span>${g.title}</span>`;
-        sectionTr.appendChild(sectionTd);
-        tbody.appendChild(sectionTr);
+              return true;
+            })
+            .map(([key, asn]) => {
+              const d = key.split("_")[1];
+              const shift = shiftMap.get(asn.shift_id);
+              const code = shift?.code || "?";
+              return {
+                date: d,
+                code: code,
+                label: new Date(d).toLocaleDateString("en-GB", { weekday: "short", day: "numeric", month: "short" }) + ` (${code})`
+              };
+            })
+        }))
+        .filter(c => c.dates.length > 0);
 
-        // User rows
-        for (const u of g.items) {
-          const tr = document.createElement("tr");
-          tr.dataset.userId = u.id;
+      if (!candidates.length) {
+        alert("No compatible staff with shifts to swap with.");
+        return;
+      }
 
-          const nameTd = document.createElement("td");
-          nameTd.className = "name-col";
-          nameTd.textContent = u.name;
+      // Show swap picker modal
+      const swapModal = document.getElementById("shiftSwapModal");
+      if (!swapModal) {
+        alert("Swap interface not ready.");
+        return;
+      }
 
-          // Badge for non-staff categories
-          if (u.is_non_staff) {
-            const badge = document.createElement("span");
-            badge.className = "badge pill";
-            badge.style.marginLeft = "8px";
-            badge.style.fontSize = "11px";
-            badge.style.padding = "2px 6px";
-            badge.style.borderRadius = "999px";
-
-            // Only show badges for non-student non-staff
-            if (u.category !== "student") {
-              if (u.category === "agency") {
-                badge.textContent = "AGENCY";
-                badge.style.background = "#fef3c7";
-                badge.style.color = "#92400e";
-              } else if (u.category === "bank") {
-                badge.textContent = "BANK";
-                badge.style.background = "#ecfccb";
-                badge.style.color = "#365314";
-              }
-              nameTd.appendChild(badge);
-            }
-          }
-
-          tr.appendChild(nameTd);
-
-          allWeeks.forEach(w => {
-            w.days.forEach(day => {
-              const dateObj = day.date ? new Date(day.date) : null;
-              const isWeekend = dateObj && (dateObj.getDay() === 0 || dateObj.getDay() === 6);
-              const dateStr = day.date;
-
-              const td = document.createElement("td");
-              td.className = "cell" + (isWeekend ? " weekend" : "");
-              td.dataset.userId = u.id;
-              if (u.is_non_staff && u.category === "student") {
-                td.dataset.isStudentNonStaff = "true";
-              }
-              td.dataset.date = dateStr;
-
-              // Get assignment
-              const key = `${u.id}_${dateStr}`;
-              const assignment = assignmentsMap.get(key);
-              
-              if (assignment) {
-                td.dataset.assignmentId = assignment.id;
-                const shift = shiftMap.get(assignment.shift_id);
-                const override = (periodData?.status === "published" && assignment.id) ? overridesMap.get(assignment.id) : null;
-                
-                if (shift) {
-                  console.log('[ROTA RENDER] Cell:', shift.code, 'assignmentId:', assignment.id, 'override:', override);
-                  
-                  // Wrap cell content in a container for positioning badges
-                  const wrapper = document.createElement("div");
-                  wrapper.style.position = "relative";
-                  wrapper.style.width = "100%";
-                  wrapper.style.height = "100%";
-                  wrapper.style.display = "flex";
-                  wrapper.style.flexDirection = "column";
-                  wrapper.style.alignItems = "stretch";
-                  wrapper.style.justifyContent = "flex-start";
-                  wrapper.style.padding = "4px 2px";
-                  wrapper.style.boxSizing = "border-box";
-                  wrapper.style.rowGap = "2px";
-
-                  const shiftBlock = document.createElement("div");
-                  shiftBlock.className = "shift-block";
-                  const codeSpan = document.createElement("span");
-                  codeSpan.textContent = shift.code;
-                  shiftBlock.appendChild(codeSpan);
-                  wrapper.appendChild(shiftBlock);
-                  
-                  // Add badges container (for published periods only)
-                  if (periodData?.status === "published" && assignment.id) {
-                    const badges = document.createElement("div");
-                    badges.style.position = "absolute";
-                    badges.style.top = "2px";
-                    badges.style.right = "2px";
-                    badges.style.display = "flex";
-                    badges.style.gap = "2px";
-                    
-                    // Override indicator (red dot) - show if ANY override field is set
-                    if (override) {
-                      const hasOverride = override.override_start_time || override.override_end_time || override.override_hours;
-                      if (hasOverride) {
-                        const overrideBadge = document.createElement("span");
-                        overrideBadge.style.width = "6px";
-                        overrideBadge.style.height = "6px";
-                        overrideBadge.style.borderRadius = "50%";
-                        overrideBadge.style.backgroundColor = "#dc2626";
-                        overrideBadge.title = "Actual times/hours differ from scheduled";
-                        badges.appendChild(overrideBadge);
-                      }
-                    }
-                    
-                    // Comment indicator (blue dot) - show if there are any comments for this assignment
-                    const assignmentComments = commentsMap.get(assignment.id);
-                    console.log('[BADGE DEBUG] Assignment ID:', assignment.id, 'Comments:', assignmentComments);
-                    if (assignmentComments && assignmentComments.length > 0) {
-                      // Filter comments based on visibility
-                      const visibleComments = assignmentComments.filter(c => {
-                        const visibility = c.comment_visibility || (c.is_admin_only ? 'admin_only' : 'all_staff');
-                        if (visibility === 'admin_only') return window.currentUser?.is_admin;
-                        if (visibility === 'all_staff') return true;
-                        if (visibility === 'user_only') return window.currentUser?.id === userId;
-                        return false;
-                      });
-                      console.log('[BADGE DEBUG] Visible comments:', visibleComments.length);
-                      
-                      if (visibleComments.length > 0) {
-                        const commentBadge = document.createElement("span");
-                        commentBadge.style.width = "6px";
-                        commentBadge.style.height = "6px";
-                        commentBadge.style.borderRadius = "50%";
-                        commentBadge.style.backgroundColor = "#3b82f6";
-                        commentBadge.title = "Has comments";
-                        badges.appendChild(commentBadge);
-                      }
-                    }
-                    
-                    if (badges.children.length > 0) {
-                      wrapper.appendChild(badges);
-                    }
-                  }
-                  
-                  td.appendChild(wrapper);
-
-                  console.log('[ROTA] Applying shift metadata for', shift.code, ':', {
-                    text_bold: shift.text_bold,
-                    text_italic: shift.text_italic,
-                    text_color: shift.text_color,
-                    fill_color: shift.fill_color
-                  });
+      // Display current shift info
+      const currentShift = shiftMap.get(assignmentsMap.get(`${userId}_${date}`)?.shift_id);
+      const currentCode = currentShift?.code || "?";
+      const dateStr = new Date(date).toLocaleDateString("en-GB", { weekday: "short", day: "numeric", month: "short" });
+      document.getElementById("swapYourShift").textContent = `${currentCode} on ${dateStr}`;
 
-                  // Apply shift metadata styling from catalogue
-                  if (shift.text_bold) {
-                    shiftBlock.style.fontWeight = "700";
-                  }
-                  if (shift.text_italic) {
-                    shiftBlock.style.fontStyle = "italic";
-                  }
-                  if (shift.text_color) {
-                    shiftBlock.style.color = shift.text_color;
-                  }
-                  if (shift.fill_color) {
-                    td.style.backgroundColor = shift.fill_color; // color the whole cell like before
-                  }
+      // Store context for swap submission
+      window.swapInitiatorContext = { userId, date, isAdmin };
+      window.swapCandidates = candidates;
 
-                  // Add request hint if exists (only if showRequests is enabled)
-                  if (showRequests) {
-                    const request = requestsMap.get(key);
-                    if (request) {
-                      const hint = document.createElement("div");
-                      const requestValue = (request.value || "").trim();
-                      const isImportant = request.important_rank && (request.important_rank === 1 || request.important_rank === 2);
+      // Populate peer dropdown
+      const peerSelect = document.getElementById("swapPeerSelect");
+      peerSelect.innerHTML = `<option value="">Select staff member...</option>` +
+        candidates.map(c => `<option value="${c.id}">${c.name}</option>`).join("");
 
-                      hint.className = "request-hint";
-                      hint.classList.add(isImportant ? "important" : "normal");
-                      hint.textContent = isImportant
-                        ? `${requestValue}${request.important_rank === 1 ? "-¦" : "-¦"}`
-                        : requestValue;
+      // Clear date dropdown
+      const dateSelect = document.getElementById("swapDateSelect");
+      dateSelect.innerHTML = `<option value="">Select their shift date...</option>`;
+      dateSelect.disabled = true;
 
-                      // Stack under the shift inside wrapper so it always shows beneath
-                      wrapper.appendChild(hint);
-                    }
-                  }
-                }
-              } else {
-                // Show requests only when toggle is on
-                if (showRequests) {
-                  const request = requestsMap.get(key);
-                  if (request) {
-                    const requestValue = request.value?.trim();
-                    const isImportant = request.important_rank && (request.important_rank === 1 || request.important_rank === 2);
+      // Wire peer change event
+      peerSelect.onchange = () => {
+        const peerId = peerSelect.value;
+        if (!peerId) {
+          dateSelect.innerHTML = `<option value="">Select their shift date...</option>`;
+          dateSelect.disabled = true;
+          return;
+        }
+        const peer = candidates.find(c => c.id === peerId);
+        if (peer) {
+          dateSelect.innerHTML = `<option value="">Select their shift date...</option>` +
+            peer.dates.map(d => `<option value="${d.date}">${d.label}</option>`).join("");
+          dateSelect.disabled = false;
+        }
+      };
 
-                    if (isImportant) {
-                      // Important requests (O-¦/O-¦) show in RED (not bold)
-                      const superscript = request.important_rank === 1 ? "-¦" : "-¦";
-                      td.textContent = `${requestValue}${superscript}`;
-                      td.style.color = "#e57373"; // paler red to mirror lighter gray emphasis
-                    } else {
-                      // Other requests show in faint gray italic
-                      td.textContent = requestValue || "";
-                      td.style.color = "#d1d5db";
-                      td.style.fontStyle = "italic";
-                    }
-                  }
-                }
-              }
+      swapModal.setAttribute("aria-hidden", "false");
+      closePublishedDetails();
+    }
 
-              tr.appendChild(td);
-              // Event delegation handled by shift-editor.js
-            });
+    function saveOverrideAmendment() {
+      const modal = document.getElementById("overrideAmendmentModalBackdrop");
+      if (modal) modal.setAttribute("aria-hidden", "true");
+      alert("Override amendment saved (placeholder).");
+    }
 
-            // Week separator (pattern target)
-            const sep = document.createElement("td");
-            sep.className = "week-sep";
-            sep.dataset.userId = u.id;
-            sep.dataset.weekStart = w.weekStart.toISOString().split('T')[0];
+    function closeOverrideAmendmentModal() {
+      const modal = document.getElementById("overrideAmendmentModalBackdrop");
+      if (modal) modal.setAttribute("aria-hidden", "true");
+    }
 
-            // Pattern-first separator display
-            // 1) If the user has an assigned pattern, prefer using it.
-            //    - Anchored patterns: show `weekly_targets` aligned from the user's anchor.
-            //    - Non-anchored patterns: show flexible baseline for that pattern (e.g., nurses baseline 3),
-            //      and highlight weeks where assigned shifts exceed baseline.
-            // 2) If no pattern is assigned, leave the separator blank (no assumptions).
-            const upat = userPatterns.get(u.id);
-            // Count only non-time-off shifts for the weekly count
-            const assignedCount = w.days.reduce((acc, d) => {
-              const assignment = assignmentsMap.get(`${u.id}_${d.date}`);
-              if (!assignment) return acc;
-              const shift = shiftMap.get(assignment.shift_id);
-              // Only count if it's not a time-off shift
-              if (shift && shift.is_time_off !== true) {
-                return acc + 1;
-              }
-              return acc;
-            }, 0);
+    function attachAmendmentHourAutoCalc() {
+      const start = document.getElementById("amendmentStartTime");
+      const end = document.getElementById("amendmentEndTime");
+      const hours = document.getElementById("amendmentHours");
+      const update = () => {
+        if (!start?.value || !end?.value) return;
+        const [sh, sm] = start.value.split(":").map(Number);
+        const [eh, em] = end.value.split(":").map(Number);
+        let mins = (eh * 60 + em) - (sh * 60 + sm);
+        if (mins < 0) mins += 24 * 60;
+        const decimal = Math.round((mins / 60) * 4) / 4;
+        if (hours) hours.value = decimal.toString();
+      };
+      if (start) start.addEventListener("change", update);
+      if (end) end.addEventListener("change", update);
+    }
 
-            if (upat && upat.pattern_id) {
-              const pat = patterns.get(upat.pattern_id);
-              if (pat && pat.requires_anchor && upat.anchor_week_start_date && Array.isArray(pat.weekly_targets) && pat.weekly_targets.length) {
-                // Anchored pattern: compute target based on cycle and anchor
-                const weekStart = new Date(sep.dataset.weekStart);
-                const anchorDateRaw = new Date(upat.anchor_week_start_date);
-                const anchorDate = getWeekStart(anchorDateRaw);
-                const weeksDiff = Math.floor((weekStart - anchorDate) / (7 * 24 * 60 * 60 * 1000));
-                const cycleLen = pat.weekly_targets.length;
-                const weekInCycle = ((weeksDiff % cycleLen) + cycleLen) % cycleLen;
-                const target = pat.weekly_targets[weekInCycle];
-                sep.textContent = String(target);
-                const baseline = Math.min(...pat.weekly_targets);
-                
-                // Green when target is met, red when exceeded
-                if (assignedCount >= target && assignedCount <= target) {
-                  // Exactly meeting the target - green
-                  sep.style.backgroundColor = "#c1ffc1";
-                  sep.style.color = "#1a5c1a";
-                  sep.style.fontWeight = "700";
-                } else if (assignedCount > target || target > baseline) {
-                  // Exceeding target OR higher than baseline week - red
-                  sep.style.color = "#dc2626";
-                  sep.style.fontWeight = "700";
-                }
-              } else {
-                // Non-anchored or undefined weekly targets: treat as flexible
-                // Use pattern weekly_targets (if present) to infer baseline, else fallback for nurses
-                const baselineCandidates = Array.isArray(pat?.weekly_targets) && pat.weekly_targets.length ? pat.weekly_targets : [];
-                let baseline = baselineCandidates.length ? Math.min(...baselineCandidates) : null;
-                if (baseline == null && (u.role_id === 1 || u.role_id === 2)) baseline = 3; // nurse baseline if pattern implies flexibility
-                // Display assigned count if any, otherwise show baseline where known
-                sep.textContent = String(assignedCount > 0 ? assignedCount : (baseline ?? ""));
-                
-                // Green when target is met or exceeded, red when exceeded
-                if (baseline != null) {
-                  if (assignedCount >= baseline && assignedCount <= baseline) {
-                    // Exactly meeting the target - green
-                    sep.style.backgroundColor = "#c1ffc1";
-                    sep.style.color = "#1a5c1a";
-                    sep.style.fontWeight = "700";
-                  } else if (assignedCount > baseline) {
-                    // Exceeding the target - red
-                    sep.style.color = "#dc2626";
-                    sep.style.fontWeight = "700";
-                  }
-                }
-              }
-            } else {
-              // No pattern assigned: do not apply role defaults; leave blank
-              sep.textContent = "";
+    // Load bank holidays for the current and next few years
+    async function loadBankHolidays() {
+      bankHolidaysByDate = {};
+      try {
+        const currentYear = new Date().getFullYear();
+        const years = [currentYear, currentYear + 1];
+        for (const year of years) {
+          const { data: holidays, error } = await supabaseClient.rpc("rpc_list_bank_holidays", {
+            p_year: year
+          });
+          if (error) throw error;
+          (holidays || []).forEach(row => {
+            if (row?.holiday_date) {
+              bankHolidaysByDate[row.holiday_date] = row;
             }
-            
-            tr.appendChild(sep);
           });
-
-          tbody.appendChild(tr);
         }
+      } catch (e) {
+        console.error("Failed to load bank holidays:", e);
       }
-      
-      // Render totals at the end
-      renderTotals();
     }
 
-    // ========== GET ROLE GROUP KEY (resilient mapping) ==========
-    function getRoleGroupKey(user) {
-      // Deterministic mapping from role_id to canonical group key
-      const roleId = user.role_id;
-      if (roleId === 1) return "charge_nurse";
-      if (roleId === 2) return "staff_nurse";
-      if (roleId === 3) return "nursing_assistant";
-      return "staff_nurse"; // fallback
-    }
+    // ========== PERIOD STATUS DISPLAY ==========
+    
+    function displayPeriodStatus(period) {
+      const status = document.getElementById("periodStatus");
+      const badge = document.getElementById("statusBadge");
+      const text = document.getElementById("statusText");
 
-    // ========== GROUP USERS BY ROLE ==========
-    function groupUsers(users) {
-      const buckets = {
-        charge_nurse: [],
-        staff_nurse: [],
-        nursing_assistant: [],
-        students: []
+      const rawStatus = (period?.status || "draft").toString().toLowerCase();
+      const isPublished = rawStatus === "published";
+
+      badge.textContent = isPublished ? "Published" : "Draft";
+      badge.className = `status-badge status-${isPublished ? "published" : "draft"}`;
+
+      const start = new Date(period.start_date).toLocaleDateString('en-GB', { day: 'numeric', month: 'short', year: 'numeric' });
+      const end = new Date(period.end_date).toLocaleDateString('en-GB', { day: 'numeric', month: 'short', year: 'numeric' });
+      text.textContent = `${period.label || period.name || 'Period'} (${start} - ${end})`;
+
+      status.style.display = "flex";
+
+      const publishBtn = document.getElementById("publishBtn");
+      const unpublishBtn = document.getElementById("unpublishBtn");
+      const canPublish = window.PermissionsModule?.hasPermission("rota.publish") || window.currentUser?.is_admin;
+      if (canPublish) {
+        publishBtn.style.display = isPublished ? "none" : "inline-block";
+        unpublishBtn.style.display = isPublished ? "inline-block" : "none";
+      } else {
+        publishBtn.style.display = "none";
+        unpublishBtn.style.display = "none";
+      }
+    }
+
+    function updateEditingControls(period) {
+      const toggleEditingBtn = document.getElementById("toggleEditingBtn");
+      const addNsBtn = document.getElementById("addNonStaffBtn");
+      const metadataDisplay = document.getElementById("metadataDisplay");
+      const publishedBanner = document.getElementById("publishedEditBanner");
+      const isPublished = period?.status === "published";
+      const canEditCurrent = isPublished ? canEditPublished : canEditDraft;
+
+      if (toggleEditingBtn) {
+        if (isPublished) {
+          toggleEditingBtn.style.display = "none";
+        } else {
+          toggleEditingBtn.style.display = canEditCurrent ? "inline-block" : "none";
+          toggleEditingBtn.textContent = "­öÆ Locked";
+          toggleEditingBtn.classList.remove("primary");
+        }
+      }
+
+      if (addNsBtn) {
+        const isMentor = window.PermissionsModule?.hasPermission?.('non_staff.edit_student_shifts');
+        const canShowNonStaff = isPublished && (window.currentUser?.is_admin || isMentor);
+        addNsBtn.style.display = canShowNonStaff ? "inline-block" : "none";
+      }
+
+      // Show published edit banner when period is published
+      if (publishedBanner) {
+        if (isPublished) {
+          publishedBanner.style.display = canEditCurrent ? "block" : "none";
+        } else {
+          publishedBanner.style.display = "none";
+        }
+      }
+
+      if (typeof window.setShiftEditContext === "function") {
+        if (isPublished) {
+          window.setShiftEditContext({
+            permissionKey: "rota.edit_published",
+            contextLabel: "published rota",
+            mode: "published",
+            lockedLabelText: "­öÆ Published Locked",
+            unlockedLabelText: "­öô Published Editing",
+            shiftFilter: (shift) => shift?.allow_post_publish === true
+          });
+          currentEditContext = "published";
+          window.currentEditContext = currentEditContext;
+        } else {
+          window.setShiftEditContext({
+            permissionKey: "rota.edit_draft",
+            contextLabel: "draft rota",
+            mode: "draft",
+            lockedLabelText: "­öÆ Locked",
+            unlockedLabelText: "­öô Editing",
+            shiftFilter: (shift) => shift?.allow_draft !== false
+          });
+          currentEditContext = "draft";
+          window.currentEditContext = currentEditContext;
+        }
+      }
+    }
+
+    async function publishPeriod() {
+      if (!periodData?.id) return;
+      if (!window.currentUser?.is_admin) {
+        alert("Admin access required.");
+        return;
+      }
+      if (!confirm(`Publish "${periodData.name}"? This will make the rota visible to staff.`)) return;
+
+      try {
+        const { data: published, error } = await supabaseClient.rpc("admin_publish_rota_period", {
+          p_token: window.currentToken,
+          p_period_id: periodData.id
+        });
+
+        if (error) throw error;
+        const publishedRow = Array.isArray(published) ? published[0] : published;
+        if (!publishedRow) throw new Error("Publish succeeded but no period returned (check RLS)");
+
+        periodData = publishedRow;
+        displayPeriodStatus(periodData);
+        updateEditingControls(periodData);
+        await loadPeriod(periodData.id);
+
+        alert("Period published.");
+      } catch (e) {
+        console.error("Error publishing period:", e);
+        alert("Failed to publish period: " + e.message);
+      }
+    }
+
+    async function unpublishPeriod() {
+      if (!periodData?.id) return;
+      if (!window.currentUser?.is_admin) {
+        alert("Admin access required.");
+        return;
+      }
+      if (!confirm(`Unpublish "${periodData.name}"? Staff will only see the last published rota.`)) return;
+
+      try {
+        const { data: unpublished, error } = await supabaseClient.rpc("admin_unpublish_rota_period", {
+          p_token: window.currentToken,
+          p_period_id: periodData.id
+        });
+
+        if (error) throw error;
+        const unpublishedRow = Array.isArray(unpublished) ? unpublished[0] : unpublished;
+        if (!unpublishedRow) throw new Error("Unpublish succeeded but no period returned (check RLS)");
+
+        periodData = unpublishedRow;
+        displayPeriodStatus(periodData);
+        updateEditingControls(periodData);
+        await loadPeriod(periodData.id);
+
+        alert("Period unpublished. Status reverted to draft.");
+      } catch (e) {
+        console.error("Error unpublishing period:", e);
+        alert("Failed to unpublish period: " + e.message);
+      }
+    }
+
+    // ========== DRAFT EDITING ==========
+
+    function toggleRequests() {
+      const canViewAll = window.PermissionsModule.hasPermission("requests.view_all");
+      const canViewOwn = window.PermissionsModule.hasPermission("requests.view_own");
+      
+      if (!canViewAll && !canViewOwn) {
+        alert("You don't have permission to view requests.");
+        return;
+      }
+      
+      showRequests = !showRequests;
+      const btn = document.getElementById("toggleRequestsBtn");
+      btn.textContent = showRequests ? "­æü´©Å Hide Requests" : "­æü´©Å Show Requests";
+      btn.classList.toggle("primary", showRequests);
+      
+      // Debug: log what's in requestsMap
+      console.log("[REQUESTS DEBUG] showRequests toggled to:", showRequests);
+      console.log("[REQUESTS DEBUG] requestsMap size:", requestsMap.size);
+      console.log("[REQUESTS DEBUG] requestsMap contents:", Array.from(requestsMap.entries()));
+      
+      // Re-render the table to apply request visibility
+      renderRota();
+    }
+
+    function toggleEditing() {
+      if (!window.PermissionsModule.hasPermission("rota.edit_draft")) {
+        alert("You don't have permission to edit draft rotas.");
+        return;
+      }
+
+      isEditingUnlocked = !isEditingUnlocked;
+      const btn = document.getElementById("toggleEditingBtn");
+      const metadataDisplay = document.getElementById("metadataDisplay");
+      
+      btn.textContent = isEditingUnlocked ? "­öô Editing" : "­öÆ Locked";
+      btn.classList.toggle("primary", isEditingUnlocked);
+      
+      // Show/hide metadata display
+      if (metadataDisplay) {
+        metadataDisplay.style.display = isEditingUnlocked ? "block" : "none";
+      }
+
+      // Update cell editability
+      document.querySelectorAll("#rota td.cell").forEach(td => {
+        td.classList.toggle("editable", isEditingUnlocked);
+      });
+    }
+
+
+
+    // ========== HELPER FUNCTIONS ==========
+    
+    function fmt(date) {
+      const d = new Date(date);
+      return d.toLocaleDateString("en-GB", { day: "numeric", month: "short" });
+    }
+
+    function isBankHoliday(date) {
+      if (!date) return false;
+      const dateStr = date.toISOString().split('T')[0];
+      return bankHolidaysByDate.hasOwnProperty(dateStr);
+    }
+
+    function getWeekStart(date) {
+      const d = new Date(date);
+      const day = d.getDay();
+      d.setDate(d.getDate() - day);
+      d.setHours(0, 0, 0, 0);
+      return d;
+    }
+
+    function getRoleGroupKey(user) {
+      if (!user) return "staff_nurse";
+      const roleIdNum = Number(user.role_id);
+      if (roleIdNum === 1) return "charge_nurse";
+      if (roleIdNum === 2) return "staff_nurse";
+      if (roleIdNum === 3) return "nursing_assistant";
+      return "staff_nurse";
+    }
+
+    function groupUsers(users) {
+      const buckets = {
+        charge_nurse: [],
+        staff_nurse: [],
+        nursing_assistant: [],
+        students: []
       };
 
       users.forEach(u => {
-        // Students go into separate group
         if (u.is_non_staff && u.category === 'student') {
           buckets.students.push(u);
         } else {
-          // Bank/agency and regular staff grouped by role
           const groupKey = getRoleGroupKey(u);
           (buckets[groupKey] || buckets.staff_nurse).push(u);
         }
       });
 
-      // Sort within buckets: primary by display_order (nulls last), secondary by name, and push non-staff to bottom within the bucket
       const sortBucket = (arr) => {
         arr.sort((a, b) => {
-          // Push non-staff to bottom of each group
           if (a.is_non_staff && !b.is_non_staff) return 1;
           if (!a.is_non_staff && b.is_non_staff) return -1;
 
@@ -1822,7 +1894,6 @@
         { title: "Staff Nurses", className: "section-sn", items: buckets.staff_nurse }
       ];
 
-      // Add students group if there are any (between Staff Nurses and Nursing Assistants)
       if (buckets.students.length > 0) {
         groups.push({ title: "Students", className: "section-students", items: buckets.students });
       }
@@ -1832,114 +1903,36 @@
       return groups.filter(g => g.items.length > 0);
     }
 
-    // ========== PATTERN WARNINGS ==========
-    function generatePatternWarnings() {
-      if (!window.currentUser?.is_admin) return;
-
-      const warnings = [];
-
-      allUsers.forEach(u => {
-        const upat = userPatterns.get(u.id);
-        if (!upat || !upat.pattern_id) return; // Only validate users with an assigned pattern
-
-        const pat = patterns.get(upat.pattern_id);
-        if (!pat) return;
-
-        // Compute total assigned shifts in the 5-week period
-        const totalAssigned = allWeeks.reduce((acc, w) => {
-          const wkCount = w.days.reduce((c, d) => c + (assignmentsMap.get(`${u.id}_${d.date}`) ? 1 : 0), 0);
-          return acc + wkCount;
-        }, 0);
-
-        // Determine expected total based on the assigned pattern
-        let expectedTotal = null;
-        if (pat.requires_anchor && upat.anchor_week_start_date && Array.isArray(pat.weekly_targets) && pat.weekly_targets.length) {
-          // Anchored cycle: sum targets over the 5 weeks using anchor alignment
-          expectedTotal = allWeeks.reduce((sum, w) => {
-            const weekStart = getWeekStart(w.weekStart);
-            const anchorDate = getWeekStart(new Date(upat.anchor_week_start_date));
-            const weeksDiff = Math.floor((weekStart - anchorDate) / (7 * 24 * 60 * 60 * 1000));
-            const cycleLen = pat.weekly_targets.length;
-            const weekInCycle = ((weeksDiff % cycleLen) + cycleLen) % cycleLen;
-            const target = Number(pat.weekly_targets[weekInCycle]) || 0;
-            return sum + target;
-          }, 0);
-        } else {
-          // Non-anchored or flexible patterns: infer baseline from weekly_targets if present
-          const baselineCandidates = Array.isArray(pat.weekly_targets) && pat.weekly_targets.length ? pat.weekly_targets : [];
-          const baseline = baselineCandidates.length ? Math.min(...baselineCandidates) : null;
-          if (baseline != null) {
-            expectedTotal = baseline * allWeeks.length; // baseline across 5 weeks
-          }
-          // Recognize nurse flexible 16 pattern explicitly by type
-          if (String(pat.pattern_type || "").includes("nurse_flexible_16")) {
-            expectedTotal = 16;
-          }
-          // If still unknown and user is CN/SN, default to 16 as flexible guidance
-          if (expectedTotal == null && (u.role_id === 1 || u.role_id === 2)) {
-            expectedTotal = 16; // CN/SN flexible pattern: total 16 across 5 weeks
-          }
-        }
-
-        if (expectedTotal != null) {
-          if (totalAssigned < expectedTotal) {
-            warnings.push({ level: "error", user: u.name, msg: `Assigned ${totalAssigned} shifts; require ${expectedTotal}` });
-          } else if (totalAssigned > expectedTotal) {
-            warnings.push({ level: "warning", user: u.name, msg: `Assigned ${totalAssigned} (> ${expectedTotal})` });
-          }
-        }
-      });
-
-      if (warnings.length === 0) {
-        document.getElementById("patternWarnings").classList.remove("visible");
-        return;
-      }
-
-      const list = document.getElementById("warningsList");
-      list.innerHTML = "";
-      warnings.forEach(w => {
-        const div = document.createElement("div");
-        div.className = `warning-item ${w.level === "error" ? "error" : ""}`;
-        div.textContent = `${w.user}: ${w.msg}`;
-        list.appendChild(div);
-      });
-
-      document.getElementById("patternWarnings").classList.add("visible");
+    function getStaffingDefaults() {
+      return {
+        day_sn_required: 3,
+        day_na_required: 1,
+        night_sn_required: 2,
+        night_na_required: 1
+      };
     }
 
-    // ========== TOTALS ==========
     function renderTotals() {
       const table = document.getElementById("rota");
       const existingTfoot = table.querySelector("tfoot");
       if (existingTfoot) existingTfoot.remove();
-      
+
       const tfoot = document.createElement("tfoot");
       const STAFFING_DEFAULTS = getStaffingDefaults();
 
-      // Calculate staffing count: 0 for time-off, 1 for full shifts (12+ hrs), 0.5 for part shifts
       function getStaffingCount(shiftObj) {
         if (!shiftObj) return 0;
-        // Time-off doesn't count toward staffing
         if (shiftObj.is_time_off === true) return 0;
-        // Full day shifts (12+ hours) count as 1 person
         const hours = Number(shiftObj.hours_value) || 0;
         if (hours >= 12) return 1;
-        // Part day shifts count as 0.5 person
         return 0.5;
       }
 
-      // Check if shift is a time-off code (should be excluded from staffing totals)
-      function isTimeOff(shiftObj) {
-        if (!shiftObj) return false;
-        return shiftObj.is_time_off === true;
-      }
-
       function isNightShift(shiftCode) {
         if (!shiftCode) return false;
         return shiftCode.toUpperCase().trim() === "N";
       }
 
-      // Add separator
       const separatorTr = document.createElement("tr");
       separatorTr.className = "totals-separator";
       const separatorTd = document.createElement("td");
@@ -1950,7 +1943,6 @@
       separatorTr.appendChild(separatorTd);
       tfoot.appendChild(separatorTr);
 
-      // Row grouping: Day Shift, Night Shift
       const sections = [
         {
           sectionLabel: "Day Shift",
@@ -1969,7 +1961,6 @@
       ];
 
       sections.forEach(section => {
-        // Section header
         const sectionTr = document.createElement("tr");
         sectionTr.className = "totals-section-row";
         const sectionTd = document.createElement("td");
@@ -1979,7 +1970,6 @@
         sectionTr.appendChild(sectionTd);
         tfoot.appendChild(sectionTr);
 
-        // Each row in section
         section.rows.forEach(rowDef => {
           const tr = document.createElement("tr");
           tr.className = "totals-row";
@@ -1996,7 +1986,6 @@
               const cell = document.createElement("td");
               cell.className = "totals-cell";
 
-              // Calculate total for this role and shift type
               let total = 0;
               allUsers
                 .filter(u => rowDef.roleIds.includes(u.role_id))
@@ -2014,14 +2003,10 @@
                   }
                 });
 
-              // Get required (from defaults)
               const required = STAFFING_DEFAULTS[rowDef.reqField];
-
-              // Display total (handle decimals for part-day shifts)
               const displayValue = total % 1 === 0 ? total.toString() : total.toFixed(1);
               cell.textContent = displayValue;
 
-              // Softer orange if short
               if (total < required) {
                 cell.style.backgroundColor = "#ffc599";
                 cell.style.color = "#5d3e1f";
@@ -2032,7 +2017,6 @@
               tr.appendChild(cell);
             });
 
-            // Week separator
             const sep = document.createElement("td");
             sep.className = "week-sep";
             tr.appendChild(sep);
@@ -2045,1277 +2029,419 @@
       table.appendChild(tfoot);
     }
 
-    // ========== DISPLAY & EVENT HANDLERS ==========
+    function renderRota() {
+      const table = document.getElementById("rota");
+      table.innerHTML = "";
 
-    function describeAssignment(userId, date) {
-      const assignment = assignmentsMap.get(`${userId}_${date}`);
-      if (!assignment) return { text: "No planned shift", shift: null };
-      const shift = shiftMap.get(assignment.shift_id);
-      if (!shift) return { text: "Planned shift", shift: null };
-      const label = shift.label ? ` ${shift.label}` : "";
-      return { text: `${shift.code}${label}`, shift };
-    }
+      const thead = document.createElement("thead");
+      const tbody = document.createElement("tbody");
+      table.appendChild(thead);
+      table.appendChild(tbody);
 
-    function openPublishedDetails({ userId, date }) {
-      if (!periodData || periodData.status !== "published") return;
-      lastPublishedCell = { userId, date };
-      // Expose as activeCell so swap-functions can operate
-      window.activeCell = { userId, date };
+      const r1 = document.createElement("tr");
+      const h1 = document.createElement("th");
+      h1.className = "name-col";
+      h1.textContent = "Name";
+      r1.appendChild(h1);
 
-      const modal = document.getElementById("publishedDetailsModal");
-      const subtitleEl = document.getElementById("publishedDetailsSubtitle");
-      const codeEl = document.getElementById("publishedShiftCode");
-      const nameEl = document.getElementById("publishedShiftName");
-      const scheduledTimesRow = document.getElementById("scheduledTimesRow");
-      const scheduledTimes = document.getElementById("scheduledTimes");
-      const actualTimesRow = document.getElementById("actualTimesRow");
-      const actualTimes = document.getElementById("actualTimes");
-      const hoursEl = document.getElementById("publishedShiftHours");
-      const hoursRow = document.getElementById("hoursRow");
-      const restDayLabel = document.getElementById("restDayLabel");
-      const commentDisplay = document.getElementById("commentDisplay");
-      const commentText = document.getElementById("commentText");
+      allWeeks.forEach(w => {
+        const th = document.createElement("th");
+        th.className = "week-head";
+        th.colSpan = 7;
+        const weekEnd = new Date(w.weekStart);
+        weekEnd.setDate(weekEnd.getDate() + 6);
+        th.innerHTML = `<span class="week-label">${fmt(w.weekStart)} ÔÇö ${fmt(weekEnd)}</span>`;
+        r1.appendChild(th);
 
-      const btnChange = document.getElementById("publishedChangeBtn");
-      const btnComments = document.getElementById("publishedCommentsBtn");
-      const btnSwap = document.getElementById("publishedSwapBtn");
-      const btnHistory = document.getElementById("publishedHistoryBtn");
-
-      const user = allUsers.find(u => u.id === userId);
-      const assignmentInfo = describeAssignment(userId, date);
-      const assignment = assignmentsMap.get(`${userId}_${date}`);
-      const override = assignment?.id ? overridesMap.get(assignment.id) : null;
-
-      const dateStr = new Date(date).toLocaleDateString("en-GB", { weekday: "short", day: "numeric", month: "short", year: "numeric" });
-      subtitleEl.textContent = `${user?.name || "Staff"} ÔÇö ${dateStr}`;
-      
-      // Build shift display with metadata styling
-      if (assignmentInfo.shift) {
-        const s = assignmentInfo.shift;
-        
-        // Apply code with metadata styling
-        codeEl.textContent = s.code || '';
-        if (s.fill_color) {
-          codeEl.style.backgroundColor = s.fill_color;
-        }
-        if (s.text_color) {
-          codeEl.style.color = s.text_color;
-        }
-        
-        // Show label as shift name
-        nameEl.textContent = s.label ? ` ${s.label}` : '';
-        
-        // Build time display with override support
-        if (s.start_time && s.end_time) {
-          restDayLabel.style.display = 'none';
-          
-          if (override && override.override_start_time && override.override_end_time) {
-            // Show both scheduled and actual
-            scheduledTimes.textContent = `${s.start_time}ÔÇô${s.end_time}`;
-            scheduledTimesRow.style.display = '';
-            actualTimes.textContent = `${override.override_start_time}ÔÇô${override.override_end_time}`;
-            actualTimesRow.style.display = '';
-          } else {
-            // Show only scheduled
-            scheduledTimes.textContent = `${s.start_time}ÔÇô${s.end_time}`;
-            scheduledTimesRow.style.display = '';
-            actualTimesRow.style.display = 'none';
-          }
-        } else {
-          scheduledTimesRow.style.display = 'none';
-          actualTimesRow.style.display = 'none';
-          restDayLabel.style.display = '';
-        }
-        
-        // Show hours (override takes precedence)
-        const displayHours = override?.override_hours ?? s.hours_value;
-        if (displayHours) {
-          hoursEl.textContent = `${displayHours} hours`;
-          if (override?.override_hours) {
-            hoursEl.style.color = '#dc2626';
-            hoursEl.style.fontWeight = '600';
-          } else {
-            hoursEl.style.color = '';
-            hoursEl.style.fontWeight = '';
-          }
-          hoursRow.style.display = '';
-        } else {
-          hoursRow.style.display = 'none';
-        }
-      } else {
-        codeEl.textContent = assignmentInfo.text;
-        codeEl.style.backgroundColor = '';
-        codeEl.style.color = '';
-        nameEl.textContent = '';
-        scheduledTimesRow.style.display = 'none';
-        actualTimesRow.style.display = 'none';
-        hoursRow.style.display = 'none';
-      }
-      
-      // Show comment if exists AND user has permission to see it
-      const isAdmin = !!window.currentUser?.is_admin;
-      let canSeeComment = false;
-      
-      if (override?.comment) {
-        const visibility = override.comment_visibility || 'admin_only';
-        if (visibility === 'admin_only') {
-          canSeeComment = isAdmin;
-        } else if (visibility === 'all_staff') {
-          canSeeComment = true;
-        } else if (visibility === 'user_only') {
-          canSeeComment = (window.currentUser?.id === userId);
-        }
-      }
-      
-      if (override?.comment && canSeeComment) {
-        commentText.textContent = override.comment;
-        commentDisplay.style.display = '';
-      } else {
-        commentDisplay.style.display = 'none';
-      }
-
-      const canHistory = isAdmin || window.PermissionsModule?.hasPermission("rota.view_history");
-      const isOwnCell = (window.currentUser?.id === userId);
-
-      if (btnChange) btnChange.style.display = canEditPublished ? "" : "none";
-      // Override shift: admin only
-      const btnOverride = document.getElementById("publishedOverrideBtn");
-      if (btnOverride) btnOverride.style.display = isAdmin ? "" : "none";
-      // View comments always visible; comments filter by visibility flag internally
-      if (btnComments) btnComments.style.display = "";
-      // Swap shift: admin can swap any shift; staff can only swap their own
-      if (btnSwap) btnSwap.style.display = (isAdmin || isOwnCell) ? "" : "none";
-      if (btnHistory) btnHistory.style.display = canHistory ? "" : "none";
-
-      modal.setAttribute("aria-hidden", "false");
-    }
-
-    function closePublishedDetails() {
-      const modal = document.getElementById("publishedDetailsModal");
-      if (modal) modal.setAttribute("aria-hidden", "true");
-    }
-
-    function handlePublishedChange() {
-      const cell = window.lastPublishedCell || lastPublishedCell;
-      if (!cell) return;
-      if (!canEditPublished) {
-        alert("You don't have permission to edit published rotas.");
-        return;
-      }
-      closePublishedDetails();
-      if (typeof window.openShiftPickerForPublished === "function") {
-        window.openShiftPickerForPublished(cell.userId, cell.date);
-      } else {
-        alert("Editor not ready yet. Try again.");
-      }
-    }
-
-    function handlePublishedOverride() {
-      const cell = window.lastPublishedCell || lastPublishedCell;
-      if (!cell) return;
-      if (!canEditPublished) {
-        alert("You don't have permission to edit published rotas.");
-        return;
-      }
-      closePublishedDetails();
-      openOverrideAmendmentModal(cell.userId, cell.date);
-    }
-
-    function openOverrideAmendmentModal(userId, date) {
-      try {
-        const backdrop = document.getElementById("overrideAmendmentModalBackdrop");
-        const title = document.getElementById("overrideAmendmentTitle");
-        const subtitle = document.getElementById("overrideAmendmentSubtitle");
-        const startTimeInput = document.getElementById("amendmentStartTime");
-        const endTimeInput = document.getElementById("amendmentEndTime");
-        const hoursInput = document.getElementById("amendmentHours");
-        const reasonInput = document.getElementById("amendmentReason");
-        
-        if (!backdrop) {
-          console.error("[OVERRIDE AMENDMENT] Modal backdrop not found");
-          alert("Modal not initialized");
-          return;
-        }
-        
-        const assignment = (typeof getAssignment === "function"
-          ? getAssignment(userId, date)
-          : window.getAssignment?.(userId, date))
-          || assignmentsMap?.get(`${userId}_${date}`);
-        const user = allUsers?.find(u => u.id === userId);
-        const dateObj = new Date(date);
-        
-        console.log("[OVERRIDE AMENDMENT] Opening modal for assignment:", assignment);
-        
-        if (title) title.textContent = user ? `${user.name} - Override Shift Times` : "Override Shift Times";
-        if (subtitle) subtitle.textContent = dateObj.toLocaleDateString("en-GB", { weekday: "short", day: "numeric", month: "short", year: "numeric" });
-        
-        // Load existing override if any
-        if (assignment?.id) {
-          const override = overridesMap?.get(assignment.id);
-          console.log("[OVERRIDE AMENDMENT] Found override:", override);
-          if (override) {
-            if (startTimeInput) startTimeInput.value = override.override_start_time || "";
-            if (endTimeInput) endTimeInput.value = override.override_end_time || "";
-            if (hoursInput) hoursInput.value = override.override_hours || "";
-            if (reasonInput) reasonInput.value = override.comment || "";
-          } else {
-            // No override yet ÔÇô prefill with scheduled shift times to make entry quicker
-            const shift = assignment.shift_id ? shiftMap?.get(assignment.shift_id) : null;
-            const start = shift?.start_time ? shift.start_time.slice(0,5) : "";
-            const end = shift?.end_time ? shift.end_time.slice(0,5) : "";
-            if (startTimeInput) startTimeInput.value = start;
-            if (endTimeInput) endTimeInput.value = end;
-            if (hoursInput) {
-              if (shift?.hours != null) {
-                hoursInput.value = shift.hours;
-              } else if (start && end) {
-                const [sh, sm] = start.split(":").map(Number);
-                const [eh, em] = end.split(":").map(Number);
-                let mins = (eh*60 + em) - (sh*60 + sm);
-                if (mins < 0) mins += 24*60; // overnight safeguard
-                hoursInput.value = Math.round((mins/60)*4)/4;
-              } else {
-                hoursInput.value = "";
-              }
-            }
-            if (reasonInput) reasonInput.value = "";
-          }
-        }
-        
-        // Store context for save
-        window.overrideAmendmentContext = { userId, date, assignmentId: assignment?.id };
-        
-        console.log("[OVERRIDE AMENDMENT] Opening modal, context:", window.overrideAmendmentContext);
-        backdrop.setAttribute("aria-hidden", "false");
-      } catch (err) {
-        console.error("[OVERRIDE AMENDMENT] Error opening modal:", err);
-        alert("Error opening override modal. Check console.");
-      }
-    }
-
-    // Keep hours in sync if start/end change in the override amendment modal
-    function attachAmendmentHourAutoCalc() {
-      const startInput = document.getElementById("amendmentStartTime");
-      const endInput = document.getElementById("amendmentEndTime");
-      const hoursInput = document.getElementById("amendmentHours");
-      if (!startInput || !endInput || !hoursInput) return;
-
-      const recompute = () => {
-        if (!startInput.value || !endInput.value) return;
-        const [sh, sm] = startInput.value.split(":").map(Number);
-        const [eh, em] = endInput.value.split(":").map(Number);
-        let minutes = (eh * 60 + em) - (sh * 60 + sm);
-        if (minutes < 0) minutes += 24 * 60; // handle overnight
-        const hrs = Math.round((minutes / 60) * 4) / 4; // nearest 0.25
-        hoursInput.value = hrs;
-      };
-
-      startInput.addEventListener("change", recompute);
-      endInput.addEventListener("change", recompute);
-    }
-
-    function closeOverrideAmendmentModal() {
-      const backdrop = document.getElementById("overrideAmendmentModalBackdrop");
-      if (backdrop) backdrop.setAttribute("aria-hidden", "true");
-      window.overrideAmendmentContext = null;
-    }
-
-    function saveOverrideAmendment() {
-      const context = window.overrideAmendmentContext;
-      if (!context) {
-        alert("No amendment context.");
-        return;
-      }
-
-      const startTime = document.getElementById("amendmentStartTime")?.value || "";
-      const endTime = document.getElementById("amendmentEndTime")?.value || "";
-      const hours = parseFloat(document.getElementById("amendmentHours")?.value || 0);
-      const reason = document.getElementById("amendmentReason")?.value || "";
-
-      if (!startTime || !endTime) {
-        alert("Please enter both start and end times.");
-        return;
-      }
-
-      // Call the direct save function
-      console.log("[OVERRIDE AMENDMENT] Calling saveOverrideAmendmentDirect with:", {
-        assignmentId: context.assignmentId,
-        startTime,
-        endTime,
-        hours,
-        reason
+        const sep = document.createElement("th");
+        sep.className = "week-sep";
+        r1.appendChild(sep);
       });
-      window.saveOverrideAmendmentDirect(context.assignmentId, startTime, endTime, hours, reason);
-    }
+      thead.appendChild(r1);
 
-    // Simplified implementation: direct Supabase update
-    window.saveOverrideAmendmentDirect = async function(assignmentId, startTime, endTime, hours, reason) {
-      console.log("[OVERRIDE AMENDMENT DIRECT] Received parameters:", {
-        assignmentId,
-        assignmentIdType: typeof assignmentId,
-        startTime,
-        endTime,
-        hours,
-        reason
-      });
-      try {
-        if (!window.supabaseClient) {
-          alert("Database client not initialized.");
-          return;
-        }
+      const r2 = document.createElement("tr");
+      const h2 = document.createElement("th");
+      h2.className = "name-col";
+      r2.appendChild(h2);
 
-        const { data, error } = await window.supabaseClient
-          .from("rota_assignment_overrides")
-          .upsert({
-            rota_assignment_id: assignmentId,
-            override_start_time: startTime,
-            override_end_time: endTime,
-            override_hours: hours,
-            comment: reason,
-            updated_at: new Date().toISOString()
-          }, {
-            onConflict: 'rota_assignment_id'
-          })
-          .select();
-
-        if (error) {
-          console.error("[OVERRIDE AMENDMENT] Error:", error);
-          alert(`Failed to save override: ${error.message}`);
-          return;
+      const dayLetters = ["S", "M", "T", "W", "T", "F", "S"];
+      allWeeks.forEach(w => {
+        for (let i = 0; i < 7; i++) {
+          const th = document.createElement("th");
+          th.className = "day";
+          th.textContent = dayLetters[i];
+          r2.appendChild(th);
         }
+        const sep = document.createElement("th");
+        sep.className = "week-sep";
+        r2.appendChild(sep);
+      });
+      thead.appendChild(r2);
 
-          console.log("[OVERRIDE AMENDMENT] Override saved successfully", data);
-          
-          // Update overridesMap with the new/updated override
-          if (data && data[0]) {
-            overridesMap.set(assignmentId, data[0]);
-          }
+      const r3 = document.createElement("tr");
+      const h3 = document.createElement("th");
+      h3.className = "name-col";
+      r3.appendChild(h3);
 
-          // Record override action in history so it shows in View History
-          try {
-            const context = window.overrideAmendmentContext || {};
-            const userId = context.userId;
-            const date = context.date;
-            const userMeta = allUsers.find(u => u.id === userId);
-            const isNonStaff = userMeta?.is_non_staff;
-            const historyAssignee = isNonStaff
-              ? { user_id: null, period_non_staff_id: userId }
-              : { user_id: userId, period_non_staff_id: null };
-            const assignment = assignmentsMap.get(`${userId}_${date}`);
-            const currentShift = assignment ? shiftMap.get(assignment.shift_id) : null;
-            const shiftCode = currentShift?.code || null;
-
-            const { error: histErr } = await window.supabaseClient
-              .from("rota_assignment_history")
-              .insert([{
-                rota_assignment_id: assignmentId,
-                ...historyAssignee,
-                date: date,
-                old_shift_id: assignment?.shift_id || null,
-                old_shift_code: shiftCode,
-                new_shift_id: assignment?.shift_id || null,
-                new_shift_code: shiftCode,
-                change_reason: 'Shift override',
-                changed_by: window.currentUser?.id,
-                changed_by_name: window.currentUser?.name,
-                changed_at: new Date().toISOString()
-              }]);
-
-            if (histErr) {
-              console.error("[OVERRIDE AMENDMENT] Error recording history:", histErr);
-            }
-          } catch (historyErr) {
-            console.error("[OVERRIDE AMENDMENT] Unexpected history error:", historyErr);
-          }
-          
-          alert("Override amended successfully.");
-          closeOverrideAmendmentModal();
-        
-        // Reload the rota to show changes
-        if (typeof renderRota === "function") {
-          renderRota();
+      allWeeks.forEach(w => {
+        for (let i = 0; i < 7; i++) {
+          const d = new Date(w.weekStart);
+          d.setDate(d.getDate() + i);
+          const isWeekend = (d.getDay() === 0 || d.getDay() === 6);
+          const isBankHol = isBankHoliday(d);
+          const th = document.createElement("th");
+          th.className = "date" + (isWeekend ? " weekend" : "") + (isBankHol ? " bank-holiday" : "");
+          th.textContent = d.getDate();
+          r3.appendChild(th);
         }
-      } catch (err) {
-        console.error("[OVERRIDE AMENDMENT] Unexpected error:", err);
-        alert("Unexpected error saving override.");
-      }
-    };
-
-    function handlePublishedHistory() {
-      const cell = window.lastPublishedCell || lastPublishedCell;
-      if (!cell) return;
-      
-      if (window.AssignmentHistoryModule?.loadAssignmentHistory) {
-        closePublishedDetails();
-        window.AssignmentHistoryModule.loadAssignmentHistory(cell.userId, cell.date);
-      } else {
-        alert("History module not loaded.");
-      }
-    }
-
-    async function handlePublishedSwap() {
-      const cell = window.lastPublishedCell || lastPublishedCell;
-      if (!cell) return;
-      if (!window.currentUser) return;
-
-      const { userId, date } = cell;
-      // Allow all logged-in staff; admins can still act. Permission gate removed for staff.
-      const isAdmin = !!window.currentUser.is_admin;
-
-      // Get initiator's user data and shift
-      const initiatorUser = allUsers.find(u => u.id === userId);
-      const initiatorAssignment = assignmentsMap.get(`${userId}_${date}`);
-      const initiatorShift = shiftMap.get(initiatorAssignment?.shift_id);
-      
-      if (!initiatorUser || !initiatorShift) {
-        alert("Could not load your shift details.");
-        return;
-      }
-
-      const initiatorRoleId = initiatorUser.role_id;
-      const initiatorDate = new Date(date);
-      const initiatorWeekStart = new Date(initiatorDate);
-      initiatorWeekStart.setDate(initiatorDate.getDate() - initiatorDate.getDay() + 1); // Monday
+        const sep = document.createElement("th");
+        sep.className = "week-sep";
+        r3.appendChild(sep);
+      });
+      thead.appendChild(r3);
 
-      // Helper: check if two dates are in the same week
-      function isSameWeek(date1Str, date2Str) {
-        const d1 = new Date(date1Str);
-        const d2 = new Date(date2Str);
-        const week1 = new Date(d1);
-        week1.setDate(d1.getDate() - d1.getDay() + 1);
-        const week2 = new Date(d2);
-        week2.setDate(d2.getDate() - d2.getDay() + 1);
-        return week1.getTime() === week2.getTime();
-      }
+      const groups = groupUsers(allUsers);
 
-      // Get list of other staff with shifts on other dates
-      const candidates = allUsers
-        .filter(u => u.id !== userId) // Remove is_active check - it's not in the users selection
-        .map(u => ({
-          id: u.id,
-          name: u.name,
-          role_id: u.role_id,
-          dates: Array.from(assignmentsMap.entries())
-            .filter(([key, asn]) => {
-              if (!key.startsWith(u.id + "_")) return false;
-              const shift = shiftMap.get(asn.shift_id);
-              if (!shift || shift.code === "O") return false;
-
-              const shiftDate = key.split("_")[1];
-              
-              // Swap must be within roles (RNÔåöRN or NAÔåöNA only)
-              const initiatorRole = initiatorRoleId; // 1 or 2 = RN, 3 = NA
-              const counterpartyRole = u.role_id;
-              const isInitiatorRN = initiatorRole === 1 || initiatorRole === 2;
-              const isCounterpartyRN = counterpartyRole === 1 || counterpartyRole === 2;
-              
-              // Must be within same role group (RN with RN, NA with NA)
-              if (isInitiatorRN !== isCounterpartyRN) return false;
-              
-              // Must be same week
-              if (!isSameWeek(date, shiftDate)) return false;
-
-              return true;
-            })
-            .map(([key, asn]) => {
-              const d = key.split("_")[1];
-              const shift = shiftMap.get(asn.shift_id);
-              const code = shift?.code || "?";
-              return {
-                date: d,
-                code: code,
-                label: new Date(d).toLocaleDateString("en-GB", { weekday: "short", day: "numeric", month: "short" }) + ` (${code})`
-              };
-            })
-        }))
-        .filter(c => c.dates.length > 0);
-
-      if (!candidates.length) {
-        alert("No compatible staff with shifts to swap with.");
-        return;
-      }
-
-      // Show swap picker modal
-      const swapModal = document.getElementById("shiftSwapModal");
-      if (!swapModal) {
-        alert("Swap interface not ready.");
-        return;
-      }
-
-      // Display current shift info
-      const currentShift = shiftMap.get(assignmentsMap.get(`${userId}_${date}`)?.shift_id);
-      const currentCode = currentShift?.code || "?";
-      const dateStr = new Date(date).toLocaleDateString("en-GB", { weekday: "short", day: "numeric", month: "short" });
-      document.getElementById("swapYourShift").textContent = `${currentCode} on ${dateStr}`;
-
-      // Store context for swap submission
-      window.swapInitiatorContext = { userId, date, isAdmin };
-      window.swapCandidates = candidates;
-
-      // Populate peer dropdown
-      const peerSelect = document.getElementById("swapPeerSelect");
-      peerSelect.innerHTML = `<option value="">Select staff member...</option>` +
-        candidates.map(c => `<option value="${c.id}">${c.name}</option>`).join("");
-
-      // Clear date dropdown
-      const dateSelect = document.getElementById("swapDateSelect");
-      dateSelect.innerHTML = `<option value="">Select their shift date...</option>`;
-      dateSelect.disabled = true;
-
-      // Wire peer change event
-      peerSelect.onchange = () => {
-        const peerId = peerSelect.value;
-        if (!peerId) {
-          dateSelect.innerHTML = `<option value="">Select their shift date...</option>`;
-          dateSelect.disabled = true;
-          return;
-        }
-        const peer = candidates.find(c => c.id === peerId);
-        if (peer) {
-          dateSelect.innerHTML = `<option value="">Select their shift date...</option>` +
-            peer.dates.map(d => `<option value="${d.date}">${d.label}</option>`).join("");
-          dateSelect.disabled = false;
-        }
-      };
-
-      swapModal.setAttribute("aria-hidden", "false");
-      closePublishedDetails();
-    }
-
-    async function handlePublishedComments() {
-      if (!lastPublishedCell) return;
-      
-      const { userId, date } = lastPublishedCell;
-      const user = allUsers.find(u => u.id === userId);
-      const assignment = assignmentsMap.get(`${userId}_${date}`);
-      
-      console.log("[COMMENTS DEBUG] lastPublishedCell:", lastPublishedCell);
-      console.log("[COMMENTS DEBUG] Looking up assignment for key:", `${userId}_${date}`);
-      console.log("[COMMENTS DEBUG] Found assignment:", assignment);
-      
-      if (!assignment) {
-        alert("No assignment for this date.");
-        return;
-      }
-      
-      // Load comments for this assignment
-      console.log("[COMMENTS DEBUG] Loading comments for assignment ID:", assignment.id);
-      const { data: comments, error } = await supabaseClient
-        .from("rota_assignment_comments")
-        .select("*")
-        .eq("rota_assignment_id", assignment.id)
-        .order("created_at", { ascending: false });
-      
-      if (error) {
-        console.error("Error loading comments:", error);
-        alert("Failed to load comments.");
-        return;
-      }
-      
-      console.log("[COMMENTS DEBUG] Loaded comments:", comments);
-      
-      // Filter comments based on visibility
-      const isAdmin = window.currentUser?.is_admin;
-      const visibleComments = (comments || []).filter(c => {
-        const visibility = c.comment_visibility || (c.is_admin_only ? 'admin_only' : 'all_staff');
-        if (visibility === 'admin_only') return isAdmin;
-        if (visibility === 'all_staff') return true;
-        if (visibility === 'user_only') return window.currentUser?.id === userId;
-        return false;
-      });
-      
-      // Populate modal
-      const modal = document.getElementById("commentsModalBackdrop");
-      const subtitle = document.getElementById("commentsModalSubtitle");
-      const commentsList = document.getElementById("commentsList");
-      const newCommentText = document.getElementById("newCommentText");
-      const isAdminCheckbox = document.getElementById("isAdminOnlyCheckbox");
-      const addBtn = document.getElementById("addCommentBtn");
-      
-      const dateStr = new Date(date).toLocaleDateString("en-GB", { weekday: "short", day: "numeric", month: "short", year: "numeric" });
-      subtitle.textContent = `${user?.name || "Staff"} ÔÇö ${dateStr}`;
-      
-      // Render comments
-      commentsList.innerHTML = "";
-      if (visibleComments.length === 0) {
-        const empty = document.createElement("p");
-        empty.style.color = "#9ca3af";
-        empty.style.fontSize = "13px";
-        empty.textContent = "No comments yet.";
-        commentsList.appendChild(empty);
-      } else {
-        visibleComments.forEach(comment => {
-          const div = document.createElement("div");
-          div.style.padding = "12px";
-          div.style.borderLeft = "3px solid #3b82f6";
-          div.style.backgroundColor = "#f0f9ff";
-          div.style.borderRadius = "4px";
-          div.style.position = "relative";
-          
-          // User info
-          const header = document.createElement("div");
-          header.style.fontSize = "12px";
-          header.style.color = "#64748b";
-          header.style.marginBottom = "6px";
-          header.style.display = "flex";
-          header.style.justifyContent = "space-between";
-          header.style.alignItems = "center";
-          
-          const userTime = document.createElement("span");
-          const createdUser = allUsers.find(u => u.id === comment.created_by);
-          console.log("[COMMENTS RENDER] comment.created_by:", comment.created_by, "createdUser found:", createdUser, "allUsers:", allUsers);
-          const createdAt = new Date(comment.created_at).toLocaleString("en-GB");
-          userTime.textContent = `${createdUser?.name || "Unknown"} ÔÇó ${createdAt}`;
-          header.appendChild(userTime);
-          
-          // Delete button (discreet, only visible on hover)
-          const canDelete = window.currentUser?.id === comment.created_by || window.currentUser?.is_admin;
-          if (canDelete) {
-            const deleteBtn = document.createElement("button");
-            deleteBtn.type = "button";
-            deleteBtn.innerHTML = "+ù";
-            deleteBtn.style.background = "none";
-            deleteBtn.style.border = "none";
-            deleteBtn.style.fontSize = "18px";
-            deleteBtn.style.color = "#94a3b8";
-            deleteBtn.style.cursor = "pointer";
-            deleteBtn.style.padding = "0 4px";
-            deleteBtn.style.opacity = "0";
-            deleteBtn.style.transition = "opacity 0.2s, color 0.2s";
-            deleteBtn.title = "Delete comment";
-            
-            deleteBtn.addEventListener("mouseenter", () => {
-              deleteBtn.style.color = "#dc2626";
-            });
-            deleteBtn.addEventListener("mouseleave", () => {
-              deleteBtn.style.color = "#94a3b8";
-            });
-            
-            deleteBtn.addEventListener("click", async (e) => {
-              e.stopPropagation();
-              if (!confirm("Delete this comment?")) return;
-              
-              try {
-                const { error } = await supabaseClient
-                  .from("rota_assignment_comments")
-                  .delete()
-                  .eq("id", comment.id);
-                
-                if (error) throw error;
-                
-                // Reload comments
-                await handlePublishedComments();
-              } catch (err) {
-                console.error("[COMMENTS] Delete failed:", err);
-                alert("Failed to delete comment.");
-              }
-            });
-            
-            header.appendChild(deleteBtn);
-            
-            // Show delete button on hover
-            div.addEventListener("mouseenter", () => {
-              deleteBtn.style.opacity = "1";
-            });
-            div.addEventListener("mouseleave", () => {
-              deleteBtn.style.opacity = "0";
-            });
-          }
-          
-          // Show visibility badge
-          const visibility = comment.comment_visibility || (comment.is_admin_only ? 'admin_only' : 'all_staff');
-          if (visibility !== 'all_staff') {
-            const badge = document.createElement("span");
-            badge.style.fontSize = "11px";
-            badge.style.fontWeight = "600";
-            if (visibility === 'admin_only') {
-              badge.style.color = "#dc2626";
-              badge.textContent = "ADMIN ONLY";
-            } else if (visibility === 'user_only') {
-              badge.style.color = "#2563eb";
-              badge.textContent = "USER ONLY";
-            }
-            header.appendChild(badge);
-          }
-          
-          div.appendChild(header);
-          
-          // Comment text
-          const text = document.createElement("div");
-          text.style.fontSize = "13px";
-          text.style.color = "#0f172a";
-          text.style.whiteSpace = "pre-wrap";
-          text.textContent = comment.comment;
-          div.appendChild(text);
-          
-          commentsList.appendChild(div);
-        });
-      }
-      
-      // Clear form
-      newCommentText.value = "";
-      const visibilityDropdown = document.getElementById("commentVisibilityDropdown");
-      if (visibilityDropdown) visibilityDropdown.value = 'all_staff';
-      
-      // Store current cell for add handler
-      window._commentsModalCell = { userId, assignmentId: assignment.id, date };
-      
-      // Clear old listeners and attach new
-      addBtn.onclick = null;
-      addBtn.addEventListener("click", async () => {
-        const commentText = newCommentText.value.trim();
-        if (!commentText) {
-          alert("Comment cannot be empty.");
-          return;
-        }
-        
-        console.log("[COMMENTS] window.currentUser:", window.currentUser);
-        console.log("[COMMENTS] window.currentUser?.id:", window.currentUser?.id);
-        
-        const visibilityDropdown = document.getElementById("commentVisibilityDropdown");
-        const commentVisibility = visibilityDropdown?.value || 'all_staff';
-        
-        console.log("[COMMENTS] Saving comment:", { assignmentId: assignment.id, commentText, commentVisibility, userId: window.currentUser?.id });
-        
-        const { error: insertErr, data: newComment } = await supabaseClient
-          .from("rota_assignment_comments")
-          .insert([{
-            rota_assignment_id: assignment.id,
-            comment: commentText,
-            comment_visibility: commentVisibility,
-            created_by: window.currentUser?.id,
-            updated_by: window.currentUser?.id
-          }])
-          .select()
-          .single();
-        
-        if (insertErr) {
-          console.error("[COMMENTS] Error saving:", insertErr);
-          alert("Failed to save comment.");
-          return;
-        }
-        
-        console.log("[COMMENTS] Comment saved successfully");
-        
-        // Update commentsMap with the new comment
-        if (newComment) {
-          const existing = commentsMap.get(assignment.id) || [];
-          existing.push(newComment);
-          commentsMap.set(assignment.id, existing);
-          renderRota(); // Re-render to show blue dot
-        }
-        
-        // Reload comments in modal
-        await handlePublishedComments();
-      });
-      
-      modal.setAttribute("aria-hidden", "false");
-    }
+      for (const g of groups) {
+        const sectionTr = document.createElement("tr");
+        sectionTr.className = "section-row";
+        const sectionTd = document.createElement("td");
+        sectionTd.className = `name-col ${g.className}`;
+        sectionTd.colSpan = 1 + (allWeeks.length * 7) + allWeeks.length;
+        sectionTd.innerHTML = `<span>${g.title}</span>`;
+        sectionTr.appendChild(sectionTd);
+        tbody.appendChild(sectionTr);
 
+        for (const u of g.items) {
+          const tr = document.createElement("tr");
+          tr.dataset.userId = u.id;
 
-    function displayPeriodStatus(period) {
-      const status = document.getElementById("periodStatus");
-      const badge = document.getElementById("statusBadge");
-      const text = document.getElementById("statusText");
+          const nameTd = document.createElement("td");
+          nameTd.className = "name-col";
+          nameTd.textContent = u.name;
 
-      // Normalize status (treat null/unknown as draft)
-      const rawStatus = (period?.status || "draft").toString().toLowerCase();
-      const isPublished = rawStatus === "published";
+          if (u.is_non_staff) {
+            const badge = document.createElement("span");
+            badge.className = "badge pill";
+            badge.style.marginLeft = "8px";
+            badge.style.fontSize = "11px";
+            badge.style.padding = "2px 6px";
+            badge.style.borderRadius = "999px";
 
-      badge.textContent = isPublished ? "Published" : "Draft";
-      badge.className = `status-badge status-${isPublished ? "published" : "draft"}`;
-      
-      // Format dates
-      const start = new Date(period.start_date).toLocaleDateString('en-GB', { day: 'numeric', month: 'short', year: 'numeric' });
-      const end = new Date(period.end_date).toLocaleDateString('en-GB', { day: 'numeric', month: 'short', year: 'numeric' });
-      text.textContent = `${period.label || 'Period'} (${start} - ${end})`;
+            if (u.category !== "student") {
+              if (u.category === "agency") {
+                badge.textContent = "AGENCY";
+                badge.style.background = "#fef3c7";
+                badge.style.color = "#92400e";
+              } else if (u.category === "bank") {
+                badge.textContent = "BANK";
+                badge.style.background = "#ecfccb";
+                badge.style.color = "#365314";
+              }
+              nameTd.appendChild(badge);
+            }
+          }
 
-      status.style.display = "flex";
-      
-      // Show publish/unpublish buttons based on status and permission
-      const publishBtn = document.getElementById("publishBtn");
-      const unpublishBtn = document.getElementById("unpublishBtn");
-      const canPublish = window.PermissionsModule.hasPermission("rota.publish");
-      if (canPublish) {
-        publishBtn.style.display = isPublished ? "none" : "inline-block";
-        unpublishBtn.style.display = isPublished ? "inline-block" : "none";
-      } else {
-        publishBtn.style.display = "none";
-        unpublishBtn.style.display = "none";
-      }
-    }
+          tr.appendChild(nameTd);
 
-    function updateEditingControls(period) {
-      const toggleEditingBtn = document.getElementById("toggleEditingBtn");
-      const addNsBtn = document.getElementById("addNonStaffBtn");
-      const metadataDisplay = document.getElementById("metadataDisplay");
-      const publishedBanner = document.getElementById("publishedEditBanner");
-      const isPublished = period?.status === "published";
-      const canEditCurrent = isPublished ? canEditPublished : canEditDraft;
+          allWeeks.forEach(w => {
+            for (let i = 0; i < 7; i++) {
+              const dayDate = new Date(w.weekStart);
+              dayDate.setDate(dayDate.getDate() + i);
+              const dateStr = dayDate.toISOString().split('T')[0];
+              const isWeekend = (dayDate.getDay() === 0 || dayDate.getDay() === 6);
 
-      if (toggleEditingBtn) {
-        if (isPublished) {
-          // No global toggle in published mode; actions go through Change Shift
-          toggleEditingBtn.style.display = "none";
-        } else {
-          toggleEditingBtn.style.display = canEditCurrent ? "inline-block" : "none";
-          toggleEditingBtn.textContent = "­öÆ Locked";
-          toggleEditingBtn.classList.remove("primary");
-        }
-      }
+              const td = document.createElement("td");
+              td.className = "cell" + (isWeekend ? " weekend" : "");
+              td.dataset.userId = u.id;
+              if (u.is_non_staff && u.category === "student") {
+                td.dataset.isStudentNonStaff = "true";
+              }
+              td.dataset.date = dateStr;
 
-      // Show Add Non-Staff only in published mode (non-staff are post-publish only)
-      if (addNsBtn) {
-        const isMentor = window.PermissionsModule?.hasPermission?.('non_staff.edit_student_shifts');
-        const canShowNonStaff = isPublished && (window.currentUser?.is_admin || isMentor);
-        addNsBtn.style.display = canShowNonStaff ? "inline-block" : "none";
-      }
+              const key = `${u.id}_${dateStr}`;
+              const assignment = assignmentsMap.get(key);
 
-      // Configure shift editor context (falls back silently if shift-editor not ready yet)
-      if (typeof window.setShiftEditContext === "function") {
-        if (isPublished) {
-          window.setShiftEditContext({
-            permissionKey: "rota.edit_published",
-            contextLabel: "published rota",
-            mode: "published",
-            lockedLabelText: "­öÆ Published Locked",
-            unlockedLabelText: "­öô Published Editing",
-            shiftFilter: (shift) => shift?.allow_post_publish === true
-          });
-          currentEditContext = "published";
-          window.currentEditContext = currentEditContext;
-        } else {
-          window.setShiftEditContext({
-            permissionKey: "rota.edit_draft",
-            contextLabel: "draft rota",
-            mode: "draft",
-            lockedLabelText: "­öÆ Locked",
-            unlockedLabelText: "­öô Editing",
-            shiftFilter: (shift) => shift?.allow_draft !== false
-          });
-          currentEditContext = "draft";
-          window.currentEditContext = currentEditContext;
-        }
-      }
+              if (assignment) {
+                td.dataset.assignmentId = assignment.id;
+                const shift = shiftMap.get(assignment.shift_id);
+                const override = (periodData?.status === "published" && assignment.id) ? overridesMap.get(assignment.id) : null;
 
-      if (typeof window.resetEditingLock === "function") {
-        window.resetEditingLock();
-      }
+                if (shift) {
+                  const wrapper = document.createElement("div");
+                  wrapper.style.position = "relative";
+                  wrapper.style.width = "100%";
+                  wrapper.style.height = "100%";
+                  wrapper.style.display = "flex";
+                  wrapper.style.flexDirection = "column";
+                  wrapper.style.alignItems = "stretch";
+                  wrapper.style.justifyContent = "flex-start";
+                  wrapper.style.padding = "4px 2px";
+                  wrapper.style.boxSizing = "border-box";
+                  wrapper.style.rowGap = "2px";
 
-      // Banner for draft editing only
-      if (metadataDisplay) metadataDisplay.style.display = "none";
-    }
+                  const shiftBlock = document.createElement("div");
+                  shiftBlock.className = "shift-block";
+                  const codeSpan = document.createElement("span");
+                  codeSpan.textContent = shift.code;
+                  shiftBlock.appendChild(codeSpan);
+                  wrapper.appendChild(shiftBlock);
 
-    async function publishPeriod() {
-      if (!window.PermissionsModule.hasPermission("rota.publish")) {
-        alert("You don't have permission to publish periods.");
-        return;
-      }
-      
-      if (!periodData) {
-        alert("No period selected.");
-        return;
-      }
+                  if (periodData?.status === "published" && assignment.id) {
+                    const badges = document.createElement("div");
+                    badges.style.position = "absolute";
+                    badges.style.top = "2px";
+                    badges.style.right = "2px";
+                    badges.style.display = "flex";
+                    badges.style.gap = "2px";
 
-      if (!periodData.id) {
-        alert("Period ID missing; reload and try again.");
-        return;
-      }
-      
-      const confirmed = confirm(
-        `Publish ${periodData.label}?\n\n` +
-        `This will make the rota visible to all staff. Draft assignments will become final.\n\n` +
-        `Are you sure you want to publish?`
-      );
-      
-      if (!confirmed) return;
-      
-      try {
-        const nowIso = new Date().toISOString();
-        const publishedBy = window.currentUser?.id || null;
-
-        // Update period status
-        const { error: updErr } = await supabaseClient
-          .from("rota_periods")
-          .update({
-            status: "published",
-            published_at: nowIso,
-            published_by: publishedBy,
-            published_version: (periodData.published_version || 0) + 1
-          })
-          .eq("id", periodData.id);
-
-        if (updErr) throw updErr;
-
-        // Update all rota_assignments for this period from draft to published
-        const { error: assignErr } = await supabaseClient
-          .from("rota_assignments")
-          .update({ status: "published" })
-          .gte("date", periodData.start_date)
-          .lte("date", periodData.end_date)
-          .eq("status", "draft");
-
-        if (assignErr) {
-          console.error("Error updating assignment status:", assignErr);
-          // Don't throw - period is already published, this is just cleanup
-        }
+                    if (override) {
+                      const hasOverride = override.override_start_time || override.override_end_time || override.override_hours;
+                      if (hasOverride) {
+                        const overrideBadge = document.createElement("span");
+                        overrideBadge.style.width = "6px";
+                        overrideBadge.style.height = "6px";
+                        overrideBadge.style.borderRadius = "50%";
+                        overrideBadge.style.backgroundColor = "#dc2626";
+                        overrideBadge.title = "Actual times/hours differ from scheduled";
+                        badges.appendChild(overrideBadge);
+                      }
+                    }
 
-        // Create history records for all assignments at publication time
-        // Note: Only create ONE history record per unique user/date combination to avoid duplicates
-        try {
-          console.log('[PUBLISH] Creating history records for assignments in date range:', periodData.start_date, 'to', periodData.end_date);
-          
-          const { data: assignments, error: assignFetchErr } = await supabaseClient
-            .from("rota_assignments")
-            .select("id, user_id, period_non_staff_id, date, shift_id, shifts!shift_id(code), created_at")
-            .gte("date", periodData.start_date)
-            .lte("date", periodData.end_date)
-            .order("date, created_at", { ascending: true });
-
-          console.log('[PUBLISH] Fetch assignments result:', { assignFetchErr, assignmentCount: assignments?.length });
-          
-          if (assignFetchErr) throw assignFetchErr;
+                    const assignmentComments = commentsMap.get(assignment.id);
+                    if (assignmentComments && assignmentComments.length > 0) {
+                      const visibleComments = assignmentComments.filter(c => {
+                        const visibility = c.comment_visibility || (c.is_admin_only ? 'admin_only' : 'all_staff');
+                        if (visibility === 'admin_only') return window.currentUser?.is_admin;
+                        if (visibility === 'all_staff') return true;
+                        if (visibility === 'user_only') return window.currentUser?.id === u.id;
+                        return false;
+                      });
 
-          if (assignments && assignments.length > 0) {
-            console.log('[PUBLISH] Sample assignment:', assignments[0]);
-            
-            // Remove duplicates by keeping only the most recent assignment per user/date
-            const seenUserDates = new Set();
-            const uniqueAssignments = [];
-            
-            // Process in reverse chronological order and keep only the latest per user/date
-            for (let i = assignments.length - 1; i >= 0; i--) {
-              const a = assignments[i];
-              const key = `${a.user_id || a.period_non_staff_id}_${a.date}`;
-              if (!seenUserDates.has(key)) {
-                seenUserDates.add(key);
-                uniqueAssignments.push(a);
+                      if (visibleComments.length > 0) {
+                        const commentBadge = document.createElement("span");
+                        commentBadge.style.width = "6px";
+                        commentBadge.style.height = "6px";
+                        commentBadge.style.borderRadius = "50%";
+                        commentBadge.style.backgroundColor = "#3b82f6";
+                        commentBadge.title = "Has comments";
+                        badges.appendChild(commentBadge);
+                      }
+                    }
+
+                    if (badges.children.length > 0) {
+                      wrapper.appendChild(badges);
+                    }
+                  }
+
+                  td.appendChild(wrapper);
+
+                  if (shift.text_bold) {
+                    shiftBlock.style.fontWeight = "700";
+                  }
+                  if (shift.text_italic) {
+                    shiftBlock.style.fontStyle = "italic";
+                  }
+                  if (shift.text_color) {
+                    shiftBlock.style.color = shift.text_color;
+                  }
+                  if (shift.fill_color) {
+                    td.style.backgroundColor = shift.fill_color;
+                  }
+
+                  if (showRequests) {
+                    const request = requestsMap.get(key);
+                    if (request) {
+                      const hint = document.createElement("div");
+                      const requestValue = (request.value || "").trim();
+                      const isImportant = request.important_rank && (request.important_rank === 1 || request.important_rank === 2);
+
+                      hint.className = "request-hint";
+                      hint.classList.add(isImportant ? "important" : "normal");
+                      hint.textContent = isImportant
+                        ? `${requestValue}${request.important_rank === 1 ? "-¦" : "-¦"}`
+                        : requestValue;
+
+                      wrapper.appendChild(hint);
+                    }
+                  }
+                }
               } else {
-                console.log('[PUBLISH] Skipping duplicate assignment for', key);
+                if (showRequests) {
+                  const request = requestsMap.get(key);
+                  if (request) {
+                    const requestValue = request.value?.trim();
+                    const isImportant = request.important_rank && (request.important_rank === 1 || request.important_rank === 2);
+
+                    if (isImportant) {
+                      const superscript = request.important_rank === 1 ? "-¦" : "-¦";
+                      td.textContent = `${requestValue}${superscript}`;
+                      td.style.color = "#e57373";
+                    } else {
+                      td.textContent = requestValue || "";
+                      td.style.color = "#d1d5db";
+                      td.style.fontStyle = "italic";
+                    }
+                  }
+                }
+              }
+
+              tr.appendChild(td);
+            }
+
+            const sep = document.createElement("td");
+            sep.className = "week-sep";
+            sep.dataset.userId = u.id;
+            sep.dataset.weekStart = w.weekStart.toISOString().split('T')[0];
+
+            const upat = userPatterns.get(u.id);
+            let assignedCount = 0;
+            for (let i = 0; i < 7; i++) {
+              const dayDate = new Date(w.weekStart);
+              dayDate.setDate(dayDate.getDate() + i);
+              const dateStr = dayDate.toISOString().split('T')[0];
+              const assignment = assignmentsMap.get(`${u.id}_${dateStr}`);
+              if (assignment) {
+                const shift = shiftMap.get(assignment.shift_id);
+                if (shift && shift.is_time_off !== true) {
+                  assignedCount++;
+                }
               }
             }
-            
-            const historyRecords = uniqueAssignments
-              .filter(a => a.shifts) // Only include if shift data exists
-              .map(a => ({
-                rota_assignment_id: a.id,
-                user_id: a.user_id,
-                period_non_staff_id: a.period_non_staff_id,
-                date: a.date,
-                old_shift_id: null,
-                old_shift_code: null,
-                new_shift_id: a.shift_id,
-                new_shift_code: a.shifts.code,
-                change_reason: 'Rota published',
-                changed_by: publishedBy,
-                changed_by_name: window.currentUser?.name || "System",
-                changed_at: nowIso
-              }));
-
-            console.log('[PUBLISH] Created', historyRecords.length, 'history records from', assignments.length, 'assignments (', seenUserDates.size, 'unique user/dates)');
-            
-            if (historyRecords.length > 0) {
-              const { error: histErr } = await supabaseClient
-                .from("rota_assignment_history")
-                .insert(historyRecords);
 
-              console.log('[PUBLISH] History insert result:', { histErr, recordCount: historyRecords.length });
+            if (upat && upat.pattern_id) {
+              const pat = patterns.get(upat.pattern_id);
+              if (pat && pat.requires_anchor && upat.anchor_week_start_date && Array.isArray(pat.weekly_targets) && pat.weekly_targets.length) {
+                const weekStart = new Date(sep.dataset.weekStart);
+                const anchorDateRaw = new Date(upat.anchor_week_start_date);
+                const anchorDate = getWeekStart(anchorDateRaw);
+                const weeksDiff = Math.floor((weekStart - anchorDate) / (7 * 24 * 60 * 60 * 1000));
+                const cycleLen = pat.weekly_targets.length;
+                const weekInCycle = ((weeksDiff % cycleLen) + cycleLen) % cycleLen;
+                const target = pat.weekly_targets[weekInCycle];
+                sep.textContent = String(target);
+                const baseline = Math.min(...pat.weekly_targets);
 
-              if (histErr) {
-                console.error("Error creating history records:", histErr);
-                // Don't throw - publication was successful, just history recording failed
+                if (assignedCount >= target && assignedCount <= target) {
+                  sep.style.backgroundColor = "#c1ffc1";
+                  sep.style.color = "#1a5c1a";
+                  sep.style.fontWeight = "700";
+                } else if (assignedCount > target || target > baseline) {
+                  sep.style.color = "#dc2626";
+                  sep.style.fontWeight = "700";
+                }
               } else {
-                console.log('[PUBLISH] Successfully created history records');
+                const baselineCandidates = Array.isArray(pat?.weekly_targets) && pat.weekly_targets.length ? pat.weekly_targets : [];
+                let baseline = baselineCandidates.length ? Math.min(...baselineCandidates) : null;
+                if (baseline == null && (u.role_id === 1 || u.role_id === 2)) baseline = 3;
+                sep.textContent = String(assignedCount > 0 ? assignedCount : (baseline ?? ""));
+
+                if (baseline != null) {
+                  if (assignedCount >= baseline && assignedCount <= baseline) {
+                    sep.style.backgroundColor = "#c1ffc1";
+                    sep.style.color = "#1a5c1a";
+                    sep.style.fontWeight = "700";
+                  } else if (assignedCount > baseline) {
+                    sep.style.color = "#dc2626";
+                    sep.style.fontWeight = "700";
+                  }
+                }
               }
+            } else {
+              sep.textContent = "";
             }
-          }
-        } catch (e) {
-          console.error("Error recording publication history:", e);
-          // Don't throw - publication was successful, just history recording failed
-        }
 
-        // Re-fetch to confirm state and update UI
-        const { data: refreshed, error: fetchErr } = await supabaseClient
-          .from("rota_periods")
-          .select("*")
-          .eq("id", periodData.id)
-          .maybeSingle();
-
-        if (fetchErr) throw fetchErr;
-        if (!refreshed) throw new Error("Publish succeeded but refetch returned no row (check RLS)");
+            tr.appendChild(sep);
+          });
 
-        periodData = refreshed;
-        displayPeriodStatus(periodData);
-        updateEditingControls(periodData);
-        
-        // Reload the rota to show published assignments
-        await loadPeriod(periodData.id);
-        
-        alert("Period published successfully!");
-      } catch (e) {
-        console.error("Error publishing period:", e);
-        alert("Failed to publish period: " + e.message);
+          tbody.appendChild(tr);
+        }
       }
+
+      renderTotals();
     }
 
-    async function unpublishPeriod() {
-      if (!window.PermissionsModule.hasPermission("rota.publish")) {
-        alert("You don't have permission to unpublish periods.");
-        return;
-      }
-      
-      if (!periodData) {
-        alert("No period selected.");
-        return;
-      }
+    function isTimeOff(shiftObj) {
+      if (!shiftObj) return false;
+      return shiftObj.is_time_off === true;
+    }
 
-      if (!periodData.id) {
-        alert("Period ID missing; reload and try again.");
-        return;
-      }
+    function describeAssignment(assignment) {
+      if (!assignment) return "N/A";
       
-      // Format period display (matching what's shown in the UI)
-      const start = new Date(periodData.start_date).toLocaleDateString('en-GB', { day: 'numeric', month: 'short', year: 'numeric' });
-      const end = new Date(periodData.end_date).toLocaleDateString('en-GB', { day: 'numeric', month: 'short', year: 'numeric' });
-      const periodLabel = `${start} - ${end}`;
-      
-      const confirmed = confirm(
-        `ÔÜá´©Å WARNING: Unpublish period (${periodLabel})?\n\n` +
-        `This will REVERT the period back to draft status.\n\n` +
-        `ÔÜá´©Å IMPORTANT:\n` +
-        `ÔÇó Only use this if you need to make changes BEFORE staff see the rota\n` +
-        `ÔÇó DO NOT use this once the rota is in active use\n` +
-        `ÔÇó For changes to published rotas, use post-publish editing instead\n\n` +
-        `Are you absolutely sure you want to unpublish?`
-      );
+      const shift = shiftMap?.get(assignment.shift_id);
+      const user = allUsers?.find(u => u.id === assignment.user_id);
+      const override = overridesMap?.get(assignment.id);
       
-      if (!confirmed) return;
+      if (!shift) return "No shift assigned";
+      if (isTimeOff(shift)) return `Time Off`;
       
-      // Second confirmation
-      const doubleCheck = confirm(
-        `Final confirmation:\n\n` +
-        `You are about to unpublish the period (${periodLabel}).\n` +
-        `This should only be used for testing or emergency corrections.\n\n` +
-        `Proceed?`
-      );
+      // Use override times if available, otherwise use shift times
+      const startTime = override?.override_start_time || shift.start_time;
+      const endTime = override?.override_end_time || shift.end_time;
+      const hours = override?.override_hours || shift.hours || 0;
       
-      if (!doubleCheck) return;
+      const start = startTime ? startTime.slice(0, 5) : "??:??";
+      const end = endTime ? endTime.slice(0, 5) : "??:??";
       
-      try {
-        // Update period status
-        const { error: updErr } = await supabaseClient
-          .from("rota_periods")
-          .update({
-            status: "draft",
-            published_at: null,
-            published_by: null
-          })
-          .eq("id", periodData.id);
-
-        if (updErr) throw updErr;
-
-        // Update all rota_assignments for this period from published back to draft
-        const { error: assignErr } = await supabaseClient
-          .from("rota_assignments")
-          .update({ status: "draft" })
-          .gte("date", periodData.start_date)
-          .lte("date", periodData.end_date)
-          .eq("status", "published");
-
-        if (assignErr) {
-          console.error("Error updating assignment status:", assignErr);
-          // Don't throw - period is already unpublished, this is just cleanup
-        }
-
-        // Delete all history records for this period (since we're reverting to draft)
-        try {
-          const { error: histErr } = await supabaseClient
-            .from("rota_assignment_history")
-            .delete()
-            .gte("date", periodData.start_date)
-            .lte("date", periodData.end_date);
-          
-          if (histErr) {
-            console.error("Error deleting history records:", histErr);
-          } else {
-            console.log("History records cleared for unpublished period");
-          }
-        } catch (e) {
-          console.error("Error clearing history:", e);
-        }
-
-        // Delete all swap requests for this period (by date range)
-        try {
-          const { error: swapReqErr } = await supabaseClient
-            .from("swap_requests")
-            .delete()
-            .or(`initiator_shift_date.gte.${periodData.start_date},initiator_shift_date.lte.${periodData.end_date},counterparty_shift_date.gte.${periodData.start_date},counterparty_shift_date.lte.${periodData.end_date}`);
-          
-          if (swapReqErr) {
-            console.error("Error deleting swap requests:", swapReqErr);
-          } else {
-            console.log("Swap requests cleared for unpublished period");
-          }
-        } catch (e) {
-          console.error("Error clearing swap requests:", e);
-        }
-
-        // Delete all swap executions for this period (by date range)
-        try {
-          const { error: swapExecErr } = await supabaseClient
-            .from("swap_executions")
-            .delete()
-            .or(`initiator_old_shift_date.gte.${periodData.start_date},initiator_old_shift_date.lte.${periodData.end_date},initiator_new_shift_date.gte.${periodData.start_date},initiator_new_shift_date.lte.${periodData.end_date},counterparty_old_shift_date.gte.${periodData.start_date},counterparty_old_shift_date.lte.${periodData.end_date},counterparty_new_shift_date.gte.${periodData.start_date},counterparty_new_shift_date.lte.${periodData.end_date}`);
-          
-          if (swapExecErr) {
-            console.error("Error deleting swap executions:", swapExecErr);
-          } else {
-            console.log("Swap executions cleared for unpublished period");
-          }
-        } catch (e) {
-          console.error("Error clearing swap executions:", e);
-        }
-
-        // Delete all comments on assignments in this period
-        try {
-          // First, get all assignment IDs for this period
-          const { data: assignments, error: assignListErr } = await supabaseClient
-            .from("rota_assignments")
-            .select("id")
-            .gte("date", periodData.start_date)
-            .lte("date", periodData.end_date);
-          
-          if (assignListErr) {
-            console.error("Error fetching assignments:", assignListErr);
-          } else if (assignments && assignments.length > 0) {
-            const assignmentIds = assignments.map(a => a.id);
-            
-            // Delete comments for these assignments
-            const { error: commErr } = await supabaseClient
-              .from("rota_assignment_comments")
-              .delete()
-              .in("rota_assignment_id", assignmentIds);
-            
-            if (commErr) {
-              console.error("Error deleting comments:", commErr);
-            } else {
-              console.log("Comments cleared for unpublished period");
-            }
-          }
-        } catch (e) {
-          console.error("Error clearing comments:", e);
-        }
-
-        // Delete all notifications related to swap requests in this period
-        try {
-          // Delete notifications of type 'swap_request' created during this period
-          // These are tied to swap operations in the period
-          const { error: notifErr } = await supabaseClient
-            .from("notifications")
-            .delete()
-            .eq("type", "swap_request")
-            .gte("created_at", new Date(periodData.start_date).toISOString())
-            .lte("created_at", new Date(periodData.end_date).toISOString() + "T23:59:59Z");
-          
-          if (notifErr) {
-            console.error("Error deleting swap notifications:", notifErr);
-          } else {
-            console.log("Swap notifications cleared for unpublished period");
-          }
-        } catch (e) {
-          console.error("Error clearing swap notifications:", e);
-        }
-
-        // Remove all non-staff from this period (since non-staff are only for published rotas)
-        try {
-          const { error: nsErr } = await supabaseClient
-            .from("period_non_staff")
-            .update({ removed_at: new Date().toISOString(), removed_by: window.currentUser?.id })
-            .eq("period_id", periodData.id)
-            .is("removed_at", null);
-          
-          if (nsErr) {
-            console.error("Error removing non-staff from period:", nsErr);
-          } else {
-            console.log("Non-staff removed from unpublished period");
-          }
-        } catch (e) {
-          console.error("Error clearing non-staff:", e);
-        }
-
-        const { data: refreshed, error: fetchErr } = await supabaseClient
-          .from("rota_periods")
-          .select("*")
-          .eq("id", periodData.id)
-          .maybeSingle();
-
-        if (fetchErr) throw fetchErr;
-        if (!refreshed) throw new Error("Unpublish succeeded but refetch returned no row (check RLS)");
-
-        periodData = refreshed;
-        displayPeriodStatus(periodData);
-        updateEditingControls(periodData);
-        
-        // Reload the rota
-        await loadPeriod(periodData.id);
-        
-        alert("Period unpublished. Status reverted to draft.");
-      } catch (e) {
-        console.error("Error unpublishing period:", e);
-        alert("Failed to unpublish period: " + e.message);
-      }
+      return `${shift.code} ${start}ÔÇô${end} (${hours}h)`;
     }
 
-    // ========== DRAFT EDITING ==========
-
-    function toggleRequests() {
-      const canViewAll = window.PermissionsModule.hasPermission("requests.view_all");
-      const canViewOwn = window.PermissionsModule.hasPermission("requests.view_own");
+    function generatePatternWarnings(userId, date) {
+      const warnings = [];
+      const userPatterns = patternsMap?.get(userId);
       
-      if (!canViewAll && !canViewOwn) {
-        alert("You don't have permission to view requests.");
-        return;
-      }
+      if (!userPatterns) return warnings;
       
-      showRequests = !showRequests;
-      const btn = document.getElementById("toggleRequestsBtn");
-      btn.textContent = showRequests ? "­æü´©Å Hide Requests" : "­æü´©Å Show Requests";
-      btn.classList.toggle("primary", showRequests);
+      const dateObj = new Date(date);
+      const dayOfWeek = dateObj.getDay(); // 0 = Sunday, 1 = Monday, etc.
+      const weekStart = getWeekStart(dateObj);
       
-      // Debug: log what's in requestsMap
-      console.log("[REQUESTS DEBUG] showRequests toggled to:", showRequests);
-      console.log("[REQUESTS DEBUG] requestsMap size:", requestsMap.size);
-      console.log("[REQUESTS DEBUG] requestsMap contents:", Array.from(requestsMap.entries()));
+      // Check for patterns
+      const shiftCode = assignmentsMap?.get(`${userId}_${date}`)?.shift_id
+        ? shiftMap?.get(assignmentsMap.get(`${userId}_${date}`).shift_id)?.code
+        : null;
       
-      // Re-render the table to apply request visibility
-      renderRota();
-    }
-
-    function toggleEditing() {
-      if (!window.PermissionsModule.hasPermission("rota.edit_draft")) {
-        alert("You don't have permission to edit draft rotas.");
-        return;
+      if (shiftCode === "N") {
+        // Night shift - check if pattern discourages nights
+        if (userPatterns.avoid_nights === true) {
+          warnings.push("User prefers to avoid night shifts");
+        }
       }
-
-      isEditingUnlocked = !isEditingUnlocked;
-      const btn = document.getElementById("toggleEditingBtn");
-      const metadataDisplay = document.getElementById("metadataDisplay");
-      
-      btn.textContent = isEditingUnlocked ? "­öô Editing" : "­öÆ Locked";
-      btn.classList.toggle("primary", isEditingUnlocked);
       
-      // Show/hide metadata display
-      if (metadataDisplay) {
-        metadataDisplay.style.display = isEditingUnlocked ? "block" : "none";
+      // Check consecutive days pattern
+      if (userPatterns.max_consecutive_days) {
+        let consecutive = 1;
+        let checkDate = new Date(dateObj);
+        
+        // Count forward
+        for (let i = 1; i < 7; i++) {
+          checkDate = new Date(dateObj);
+          checkDate.setDate(checkDate.getDate() + i);
+          const nextKey = checkDate.toISOString().split('T')[0];
+          const nextAssignment = assignmentsMap?.get(`${userId}_${nextKey}`);
+          if (nextAssignment?.shift_id && !isTimeOff(shiftMap.get(nextAssignment.shift_id))) {
+            consecutive++;
+          } else {
+            break;
+          }
+        }
+        
+        if (consecutive > userPatterns.max_consecutive_days) {
+          warnings.push(`Exceeds ${userPatterns.max_consecutive_days}-day limit (${consecutive} assigned)`);
+        }
       }
-
-      // Update cell editability
-      document.querySelectorAll("#rota td.cell").forEach(td => {
-        td.classList.toggle("editable", isEditingUnlocked);
-      });
+      
+      return warnings;
     }
 
-
+    function getBankHolidayName(date) {
+      if (!date) return null;
+      const dateStr = date.toISOString().split('T')[0];
+      const holiday = bankHolidaysByDate[dateStr];
+      if (!holiday) return null;
+      return holiday.holiday_name || "Bank Holiday";
+    }
 
     // ========== INIT ==========
     async function bootRotaPage(){
@@ -3540,198 +2666,90 @@
                   period_non_staff_id: isNonStaff ? userId : null,
                   date,
                   shift_id: shiftId,
-                  status: "draft"
+                  status: currentEditContext === "published" ? "published" : "draft"
                 });
               }
               
               // Re-render immediately
               renderRota();
-              
-              // Sync to database in background
-              const { data: existingDb, error: getErr } = await supabaseClient
-                .from("rota_assignments")
-                .select("id")
-                .eq(isNonStaff ? "period_non_staff_id" : "user_id", userId)
-                .eq("date", date)
-                .maybeSingle();
-              
-              let assignmentId = existingDb?.id;
-              
-              if (!getErr) {
-                if (existingDb?.id) {
-                  assignmentId = existingDb.id;
-                  await supabaseClient
-                    .from("rota_assignments")
-                    .update({ shift_id: shiftId })
-                    .eq("id", existingDb.id);
-                  // Update assignmentsMap with the ID
-                  const existing = assignmentsMap.get(key);
-                  if (existing) existing.id = existingDb.id;
-                  
-                  // Record history if in published mode and shift changed or added
-                  if (currentEditContext === "published") {
-                    // Only record if shift actually changed (or was added to empty cell)
-                    if (!oldShiftId || oldShiftId !== shiftId) {
-                      console.log("[ROTA ONSAVE] Recording history for shift change:", { oldShiftId, newShiftId: shiftId, assignmentId });
-                      const { error: histErr } = await supabaseClient
-                        .from("rota_assignment_history")
-                        .insert([{
-                          rota_assignment_id: assignmentId,
-                          ...historyAssignee,
-                          date: date,
-                          old_shift_id: oldShiftId || null,
-                          old_shift_code: oldShiftCode || null,
-                          new_shift_id: shiftId,
-                          new_shift_code: newShift?.code || 'UNKNOWN',
-                          change_reason: oldShiftId ? 'Admin changed shift' : 'Admin added shift',
-                          changed_by: window.currentUser?.id,
-                          changed_by_name: window.currentUser?.name,
-                          changed_at: new Date().toISOString()
-                        }]);
-                      if (histErr) {
-                        console.error("[ROTA ONSAVE] Error recording history:", histErr);
-                      } else {
-                        console.log("[ROTA ONSAVE] History recorded successfully");
-                      }
-                    }
-                  }
-                } else {
-                  const { data: newAssignment } = await supabaseClient
-                    .from("rota_assignments")
-                    .insert([{
-                      user_id: isNonStaff ? null : userId,
-                      period_non_staff_id: isNonStaff ? userId : null,
-                      date,
-                      shift_id: shiftId,
-                      status: currentEditContext === "published" ? "published" : "draft"
-                    }])
-                    .select()
-                    .single();
-                  assignmentId = newAssignment?.id;
-                  // Update assignmentsMap with the new ID
+
+              try {
+                const { data: assignmentId, error: saveErr } = await supabaseClient.rpc("admin_upsert_rota_assignment", {
+                  p_token: window.currentToken,
+                  p_user_id: isNonStaff ? null : userId,
+                  p_period_non_staff_id: isNonStaff ? userId : null,
+                  p_date: date,
+                  p_shift_id: shiftId,
+                  p_status: currentEditContext === "published" ? "published" : "draft"
+                });
+
+                if (saveErr) throw saveErr;
+                const assignmentIdValue = Array.isArray(assignmentId) ? assignmentId[0] : assignmentId;
+                if (assignmentIdValue) {
                   const existing = assignmentsMap.get(key);
-                  if (existing && assignmentId) existing.id = assignmentId;
-                  
-                  // Record history for new assignment (if in published mode)
-                  if (currentEditContext === "published" && assignmentId) {
-                    console.log("[ROTA ONSAVE] Recording history for new shift:", { shiftId, assignmentId });
-                    const { error: histErr } = await supabaseClient
-                      .from("rota_assignment_history")
-                      .insert([{
-                        rota_assignment_id: assignmentId,
-                        ...historyAssignee,
-                        date: date,
-                        old_shift_id: null,
-                        old_shift_code: null,
-                        new_shift_id: shiftId,
-                        new_shift_code: newShift?.code || 'UNKNOWN',
-                        change_reason: 'Admin added shift',
-                        changed_by: window.currentUser?.id,
-                        changed_by_name: window.currentUser?.name,
-                        changed_at: new Date().toISOString()
-                      }]);
+                  if (existing) existing.id = assignmentIdValue;
+                }
+
+                if (currentEditContext === "published") {
+                  if (!oldShiftId || oldShiftId !== shiftId) {
+                    const { error: histErr } = await supabaseClient.rpc("admin_insert_rota_assignment_history", {
+                      p_token: window.currentToken,
+                      p_assignment_id: assignmentIdValue,
+                      p_user_id: historyAssignee.user_id,
+                      p_period_non_staff_id: historyAssignee.period_non_staff_id,
+                      p_date: date,
+                      p_old_shift_id: oldShiftId || null,
+                      p_old_shift_code: oldShiftCode || null,
+                      p_new_shift_id: shiftId,
+                      p_new_shift_code: newShift?.code || 'UNKNOWN',
+                      p_change_reason: oldShiftId ? 'Admin changed shift' : 'Admin added shift',
+                      p_changed_by_name: window.currentUser?.name
+                    });
                     if (histErr) {
                       console.error("[ROTA ONSAVE] Error recording history:", histErr);
-                    } else {
-                      console.log("[ROTA ONSAVE] History recorded successfully");
                     }
                   }
                 }
-                
-                // Save override data if provided (published mode only)
-                // Only save if there's actual override data (not just empty fields)
+
                 const hasActualOverride = overrideData && (
                   overrideData.override_start_time || 
                   overrideData.override_end_time || 
                   overrideData.override_hours
                 );
-                
-                if (hasActualOverride && assignmentId) {
-                  console.log("[ROTA ONSAVE] Saving override for assignmentId:", assignmentId, overrideData);
-                  const { data: existingOverride } = await supabaseClient
-                    .from("rota_assignment_overrides")
-                    .select("id")
-                    .eq("rota_assignment_id", assignmentId)
-                    .maybeSingle();
-                  
-                  const overridePayload = {
-                    rota_assignment_id: assignmentId,
-                    override_start_time: overrideData.override_start_time,
-                    override_end_time: overrideData.override_end_time,
-                    override_hours: overrideData.override_hours,
-                    comment: overrideData.comment,
-                    comment_visibility: overrideData.comment_visibility || 'admin_only'
-                  };
-                  
-                  console.log("[ROTA ONSAVE] Override payload:", overridePayload);
-                  
-                  if (existingOverride?.id) {
-                    console.log("[ROTA ONSAVE] Updating existing override:", existingOverride.id);
-                    const { data: updateData, error: updateErr } = await supabaseClient
-                      .from("rota_assignment_overrides")
-                      .update(overridePayload)
-                      .eq("id", existingOverride.id);
-                    if (updateErr) {
-                      console.error("[ROTA ONSAVE] Error updating override:", updateErr);
-                    } else {
-                      console.log("[ROTA ONSAVE] Override updated successfully");
-                      overridesMap.set(assignmentId, { ...existingOverride, ...overridePayload });
-                      renderRota(); // Re-render to show override badge
-                    }
+
+                if (hasActualOverride && assignmentIdValue) {
+                  const { data: overrideRow, error: overrideErr } = await supabaseClient.rpc("admin_upsert_rota_assignment_override", {
+                    p_token: window.currentToken,
+                    p_assignment_id: assignmentIdValue,
+                    p_override_start_time: overrideData.override_start_time,
+                    p_override_end_time: overrideData.override_end_time,
+                    p_override_hours: overrideData.override_hours,
+                    p_comment: overrideData.comment,
+                    p_comment_visibility: overrideData.comment_visibility || 'admin_only'
+                  });
+                  if (overrideErr) {
+                    console.error("[ROTA ONSAVE] Error saving override:", overrideErr);
                   } else {
-                    console.log("[ROTA ONSAVE] Inserting new override");
-                    const { data: newOverride, error: insertErr } = await supabaseClient
-                      .from("rota_assignment_overrides")
-                      .insert([overridePayload])
-                      .select()
-                      .single();
-                    if (insertErr) {
-                      console.error("[ROTA ONSAVE] Error inserting override:", insertErr);
-                      console.error("[ROTA ONSAVE] Error details:", {
-                        message: insertErr.message,
-                        status: insertErr.status,
-                        code: insertErr.code,
-                        hint: insertErr.hint
-                      });
-                    } else if (newOverride) {
-                      console.log("[ROTA ONSAVE] Override inserted successfully:", newOverride);
-                      overridesMap.set(assignmentId, newOverride);
-                    }
+                    const row = Array.isArray(overrideRow) ? overrideRow[0] : overrideRow;
+                    if (row) overridesMap.set(assignmentIdValue, row);
+                    renderRota();
                   }
-                  
-                  // Re-render to show override badges
-                  renderRota();
-                } else {
-                  console.log("[ROTA ONSAVE] No override data to save");
-                  
-                  // If there's an existing override but no new override data, delete it
-                  if (assignmentId) {
-                    const { data: existingOverride } = await supabaseClient
-                      .from("rota_assignment_overrides")
-                      .select("id")
-                      .eq("rota_assignment_id", assignmentId)
-                      .maybeSingle();
-                    
-                    if (existingOverride?.id) {
-                      console.log("[ROTA ONSAVE] Deleting old override:", existingOverride.id);
-                      const { error: deleteErr } = await supabaseClient
-                        .from("rota_assignment_overrides")
-                        .delete()
-                        .eq("id", existingOverride.id);
-                      
-                      if (deleteErr) {
-                        console.error("[ROTA ONSAVE] Error deleting override:", deleteErr);
-                      } else {
-                        console.log("[ROTA ONSAVE] Override deleted successfully");
-                        overridesMap.delete(assignmentId);
-                        renderRota(); // Re-render to remove override badge
-                      }
-                    }
+                } else if (assignmentIdValue) {
+                  const { error: deleteErr } = await supabaseClient.rpc("admin_delete_rota_assignment_override", {
+                    p_token: window.currentToken,
+                    p_assignment_id: assignmentIdValue
+                  });
+                  if (deleteErr) {
+                    console.error("[ROTA ONSAVE] Error deleting override:", deleteErr);
+                  } else {
+                    overridesMap.delete(assignmentIdValue);
+                    renderRota();
                   }
                 }
+              } catch (err) {
+                console.error("[ROTA ONSAVE] Error saving assignment:", err);
               }
-            },
-            onClear: async (userId, date) => {
+            },onClear: async (userId, date) => {
               const key = `${userId}_${date}`;
               const userMeta = allUsers.find(u => u.id === userId);
               const isNonStaff = userMeta?.is_non_staff;
@@ -3739,63 +2757,49 @@
                 ? { user_id: null, period_non_staff_id: userId }
                 : { user_id: userId, period_non_staff_id: null };
               
-              // Get the current shift info before deleting (for history)
               const existingAssignment = assignmentsMap.get(key);
               const oldShiftId = existingAssignment?.shift_id;
               const oldShift = oldShiftId ? shiftMap.get(oldShiftId) : null;
               const oldShiftCode = oldShift?.code;
               
-              // Optimistic update: remove from local map immediately
               assignmentsMap.delete(key);
-              
-              // Re-render immediately
               renderRota();
-              
-              // Sync to database in background
-              const { data: existing, error: getErr } = await supabaseClient
-                .from("rota_assignments")
-                .select("id")
-                .eq(isNonStaff ? "period_non_staff_id" : "user_id", userId)
-                .eq("date", date)
-                .maybeSingle();
-              
-              if (!getErr && existing?.id) {
-                // Record history before deleting (if in published mode)
-                if (currentEditContext === "published" && oldShiftId) {
-                  console.log("[ROTA ONCLEAR] Recording history for cleared shift:", { oldShiftId, assignmentId: existing.id });
-                  const { error: histErr } = await supabaseClient
-                    .from("rota_assignment_history")
-                    .insert([{
-                      rota_assignment_id: existing.id,
-                      ...historyAssignee,
-                      date: date,
-                      old_shift_id: oldShiftId,
-                      old_shift_code: oldShiftCode || 'UNKNOWN',
-                      new_shift_id: null,
-                      new_shift_code: null,
-                      change_reason: 'Admin cleared shift',
-                      changed_by: window.currentUser?.id,
-                      changed_by_name: window.currentUser?.name,
-                      changed_at: new Date().toISOString()
-                    }]);
+
+              try {
+                if (currentEditContext === "published" && oldShiftId && existingAssignment?.id) {
+                  const { error: histErr } = await supabaseClient.rpc("admin_insert_rota_assignment_history", {
+                    p_token: window.currentToken,
+                    p_assignment_id: existingAssignment.id,
+                    p_user_id: historyAssignee.user_id,
+                    p_period_non_staff_id: historyAssignee.period_non_staff_id,
+                    p_date: date,
+                    p_old_shift_id: oldShiftId,
+                    p_old_shift_code: oldShiftCode || 'UNKNOWN',
+                    p_new_shift_id: null,
+                    p_new_shift_code: null,
+                    p_change_reason: 'Admin cleared shift',
+                    p_changed_by_name: window.currentUser?.name
+                  });
                   if (histErr) {
                     console.error("[ROTA ONCLEAR] Error recording history:", histErr);
-                  } else {
-                    console.log("[ROTA ONCLEAR] History recorded successfully");
                   }
                 }
-                
-                // Now delete the assignment
-                await supabaseClient
-                  .from("rota_assignments")
-                  .delete()
-                  .eq("id", existing.id);
+
+                const { error: deleteErr } = await supabaseClient.rpc("admin_delete_rota_assignment", {
+                  p_token: window.currentToken,
+                  p_user_id: isNonStaff ? null : userId,
+                  p_period_non_staff_id: isNonStaff ? userId : null,
+                  p_date: date
+                });
+                if (deleteErr) throw deleteErr;
+              } catch (err) {
+                console.error("[ROTA ONCLEAR] Error clearing assignment:", err);
               }
             },
             getCurrentUser: () => window.currentUser,
             getCurrentPeriod: () => currentPeriod,
             getAllUsers: () => allUsers,
-            getDraftShifts: () => draftShifts,
+            getDraftShifts: () => shifts, // Return main shifts array
             getAssignment: (userId, date) => assignmentsMap.get(`${userId}_${date}`),
             getOverride: (assignmentId) => overridesMap.get(assignmentId),
             refreshGrid: () => {
@@ -3822,6 +2826,28 @@
           throw err;
         }
         
+        // Auto-select and load the first available period
+        console.log("[ROTA BOOT] Auto-selecting first period...");
+        // periodSelect was already retrieved at line 1127 with getElement()
+        if (periodSelect && periodSelect.options && periodSelect.options.length > 0) {
+          const firstPeriodId = periodSelect.options[0].value;
+          periodSelect.value = firstPeriodId;
+          console.log("[ROTA BOOT] Auto-loading period:", firstPeriodId);
+          try {
+            if (typeof loadPeriod === "function") {
+              await loadPeriod(firstPeriodId);
+              console.log("[ROTA BOOT] Period loaded successfully");
+            } else {
+              console.warn("[ROTA BOOT] loadPeriod function not available");
+            }
+          } catch (err) {
+            console.error("[ROTA BOOT] Failed to load first period:", err);
+            throw err;
+          }
+        } else {
+          console.warn("[ROTA BOOT] No periods available in dropdown");
+        }
+        
         // Initialize notices/notifications (from app.js)
         console.log("[ROTA BOOT] Loading notices bell...");
         try {
@@ -3929,56 +2955,8 @@
       const roleId = Number(window.currentUser.role_id);
       const isAdmin = !!window.currentUser.is_admin;
       
-      // Check if user is in Admin permission group
-      let isAdminGroup = false;
-      if (!isAdmin) {
-        try {
-          const { data: groups } = await supabaseClient
-            .from("user_permission_groups")
-            .select("permission_groups(name)")
-            .eq("user_id", window.currentUser.id);
-          if (groups && groups.some(g => g.permission_groups?.name === "Admin")) {
-            isAdminGroup = true;
-          }
-        } catch (e) {
-          console.warn("Failed to check admin group", e);
-        }
-      }
-      
-      const clauses = ["target_scope.eq.all_staff"];
-
-      if (window.currentUser.id) {
-        clauses.push(`and(target_scope.eq.user,target_user_id.eq.${window.currentUser.id})`);
-      }
-
-      if (isAdmin || isAdminGroup) {
-        clauses.push(`target_scope.eq.admin`);
-      }
-
-      if (!Number.isNaN(roleId)) {
-        clauses.push(`and(target_scope.eq.role,target_role_ids.cs.{${roleId}})`);
-      }
-
       const { data, error } = await supabaseClient
-        .from("notifications")
-        .select(`
-          id,
-          type,
-          payload,
-          target_scope,
-          target_role_ids,
-          target_user_id,
-          requires_action,
-          status,
-          created_by,
-          created_at,
-          updated_by,
-          updated_at,
-          acted_by,
-          acted_at
-        `)
-        .or(clauses.join(","))
-        .order("updated_at", { ascending: false });
+        .rpc("rpc_get_notifications", { p_token: window.currentToken });
 
       if (error) throw error;
 
@@ -3987,8 +2965,8 @@
         // Only show pending notifications
         if ((item.status || 'pending') !== 'pending') return false;
         
-        // all_staff scope matches everyone
-        if (item.target_scope === 'all_staff') return true;
+        // all/all_staff scope matches everyone
+        if (item.target_scope === 'all' || item.target_scope === 'all_staff') return true;
         
         // user scope must match current user ID
         if (item.target_scope === 'user') {
@@ -4132,14 +3110,11 @@
     async function updateNotificationStatus(notifId, status){
       if (!window.currentUser) throw new Error("Not logged in.");
       const { error } = await supabaseClient
-        .from("notifications")
-        .update({
-          status: status,
-          acted_by: window.currentUser.id,
-          acted_at: new Date().toISOString(),
-          updated_by: window.currentUser.id
-        })
-        .eq("id", notifId);
+        .rpc("rpc_update_notification_status", {
+          p_token: window.currentToken,
+          p_notification_id: notifId,
+          p_status: status
+        });
 
       if (error) throw error;
     }
@@ -4818,3 +3793,8 @@ window.addEventListener('load',function(){requestAnimationFrame(function(){reque
 
 
 
+
+
+
+
+
\n
==== DIFF: supabase/functions/ics/index.ts ====\n
diff --git "a/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\Calpe-Ward Backup\\Calpe-Ward\\supabase\\functions\\ics\\index.ts" "b/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\supabase\\functions\\ics\\index.ts"
index db6349c..9da4379 100644
--- "a/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\Calpe-Ward Backup\\Calpe-Ward\\supabase\\functions\\ics\\index.ts"	
+++ "b/C:\\Users\\Sean\\Documents\\Calpe Ward\\Git\\Calpe-Ward\\supabase\\functions\\ics\\index.ts"	
@@ -143,7 +143,7 @@ function buildVEvent(shift: ShiftRow): string {
     // Description: times + comments
     const startTimeDisplay = formatTimeDisplay(shift.start_time);
     const endTimeDisplay = formatTimeDisplay(shift.end_time);
-    let description = `Hours: ${startTimeDisplay} ÔÇô ${endTimeDisplay}`;
+    let description = `Hours: ${startTimeDisplay} - ${endTimeDisplay}`;
     
     if (shift.comments && shift.comments.trim()) {
       description += `\n\nNotes:\n${shift.comments}`;
\n
